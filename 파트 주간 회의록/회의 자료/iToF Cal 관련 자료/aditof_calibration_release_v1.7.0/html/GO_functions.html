<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>GO_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>GO_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
#
# Copyright (c) 2020 Analog Devices, Inc. All Rights Reserved.   
# This software is proprietary to Analog Devices, Inc. and its licensors.  
#

# import numpy as np
# import numpy.matlib
# import csv
# import os
# import time
# import matplotlib.pyplot as plt
# import pickle
# import sys
# from . import CalibAPI as tof
# import cv2
# from . import Raw2Lx5 as R2L
# from datetime import datetime
# import logging
# import yaml

class GainOffset:
        def __init__(self, GO_settings, file, CalibfolderName):
                self.GO_settings = GO_settings
                self.cal_dict = dict()
                self.origSetting = dict()
                self.CalibfolderName = CalibfolderName
                self.folderName = os.path.join(CalibfolderName, str(file[&#39;GainOffsetCalibration&#39;][&#39;output_directory&#39;]))
                self.cfg_file = file[&#39;GainOffsetCalibration&#39;][&#39;configuration_file&#39;]
                module_class = file[&#39;module_class&#39;]

                if not os.path.exists(self.folderName):
                        os.mkdir(self.folderName)
                else:
                        now = datetime.now()
                        print(&#39;\nALERT: &#39; + self.folderName + &#39; already exists&#39;)
                        old_folderName = self.folderName + str(now.strftime(&#39;_old_%Y%m%d_%H%M%S&#39;))
                        os.rename(self.folderName, old_folderName)
                        print(&#39;ALERT: RENAMING OLD FOLDER: &#39; + self.folderName + &#39; as &#39;+ old_folderName +&#39;\n&#39;)
                        os.mkdir(self.folderName)

                time.sleep(0.1)
                logging.basicConfig(filename=os.path.join(self.folderName, &#39;GainOffset.log&#39;), 
                                                        filemode=&#39;w&#39;, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;,
                                                        level=logging.INFO)
                print(&#39;Created log file&#39;)

                print(&#34;module_class = &#34; + str(module_class))
                logging.info(&#34;module_class = &#34; + str(module_class))

                print(&#34;configuration file cfg = &#34; + str(self.cfg_file))
                logging.info(&#34;configuration file cfg = &#34; + str(self.cfg_file))

                self.yaml_file = file
                self.ADC_cal_settings = file[&#39;GainOffsetCalibration&#39;][&#39;ADC_calibration&#39;]
                self.Comp_DAC_cal_settings = file[&#39;GainOffsetCalibration&#39;][&#39;Comp_DAC_calibration&#39;]

                self.API = tof.CalibAPI(module_class = module_class)
                self.API.ConnectSensor(Mode=3, cfg = self.cfg_file)


        def const_hex(self, val):
                &#39;&#39;&#39;
                Formats hex values to 0x0000 form 
                
                Inputs: 
                  val                   - hex value to be formatted 
                  
                Outputs: 
                  val                   - formatted hex value 
                
                &#39;&#39;&#39;
                val = np.uint16(val)
                return &#39;0x&#39; + &#39;0&#39;*(max(0,4-len(str(hex(val))[2:]))) + str(hex(val))[2:]


        def ConfigureChip(self):
                &#39;&#39;&#39;
                Configures the camera before per-column-Gain and Offset calibration. 
                Performs ADC calibration and CompDAC calibration. 
                
                Inputs:  
                  None  
                   
                Outputs:  
                  True  
                
                &#39;&#39;&#39;
                val = self.API.regread(274)
                success= val == 22833
                self.API.error_assert(success, &#34;Cannot communicate with chip&#34;)

                # ## TODO confirm chip  info
                # status, cfgver = self.API.N_APIComm(2, self.API.API[&#39;IO&#39;][&#39;config_version&#39;][&#39;get&#39;])
                # self.API.error_assert(status, &#34;Cannot get Config version&#34;)

                val = self.API.regread(0x0528)
                # self.API.error_assert(status, &#34;Cannot determine if multigain settings have already been applied&#34;)

                if (int(val)&amp;6) == 6:
                        print(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
                        logging.info(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
                else:
                        success = self.API.regrmw(0x0528, 0x0FFFF, 0x0006)

                success = success and self.API.regwrite(0x0014, 0x0000) # blindly unclock gate all digital
                success = success and self.API.regwrite(0x0500, 0x1002) # Configure read from LX5 DRAM          
                success = success and self.API.regwrite(0x0502, 0x0006) 
                s, val = self.API.regreadburst(0x0506, 5)
                self.cal_dict[&#39;gainCalConfigVersion&#39;] = int(val[4])

                val = self.API.regread(0x0D1A)
                # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

                self.tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)
                self.cal_dict[&#39;ADC&#39;] = dict()


                ADC_dict = dict(
                                                sensormodeID = self.ADC_cal_settings[&#39;sensormodeID&#39;], # PCM
                                                nFrames = self.ADC_cal_settings[&#39;nFrames&#39;],
                                                DAC_AMPTEST0 = self.ADC_cal_settings[&#39;DAC_AMPTEST0&#39;], # ~1.61V
                                                DAC_AMPTEST1 = self.ADC_cal_settings[&#39;DAC_AMPTEST1&#39;], # ~2.05V
                                                iramp = self.ADC_cal_settings[&#39;iramp&#39;],
                                                ADC_FS = self.ADC_cal_settings[&#39;ADC_FS&#39;], # ADC Full Scale = 2Vpp
                                                Cin = self.ADC_cal_settings[&#39;Cin&#39;], # Ampgain setting of 0.99x
                                                Cfb = self.ADC_cal_settings[&#39;Cfb&#39;],
                                                AmpGainMeas = self.ADC_cal_settings[&#39;AmpGainMeas&#39;], # actual amp gain (measured using two single ended probes)
                                                cleanup = self.ADC_cal_settings[&#39;cleanup&#39;] # cleanup after calibration, i,e restore original settings
                                                )

                #Comp_DAC_cal_settings  =file[&#39;Comp_DAC_calibration&#39;]

                compDict = dict(
                                                NFRAMES = self.Comp_DAC_cal_settings[&#39;NFRAMES&#39;], # number of frames to collect per DAC step
                                                doplot = self.Comp_DAC_cal_settings[&#39;doplot&#39;], # flag to generate plots and intermediate outputs
                                                compCalThres = self.Comp_DAC_cal_settings[&#39;compCalThres&#39;], # Threshold for number of comparator samples per column that must have transitioned to the next gain (default if not specified is 99.5%)
                                                compCalSatLimit = self.Comp_DAC_cal_settings[&#39;compCalSatLimit&#39;], # Fail gain calibration if more than compCalSatLimit pixels are saturated within any column at the original comparator DAC setting (default if not specified is 2 pixels per column)
                                                compCalMargin = self.Comp_DAC_cal_settings[&#39;compCalMargin&#39;] # Required margin from max/min ADC value.  This margin is used when adjusting comparator DAC after finding the existing switching point (default if not specified is 5% of full scale)
                                                )

                # Calibrate ADC ramp and up/dn counters
                self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;] = self.ADCCalib(ADC_dict)
                print(&#39;ADC Calibration values: \nADC iramp: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], &#39;\nADC updnoffset: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])
                logging.info(&#39;ADC Calibration values: \nADC iramp: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;]) + &#39;\nADC updnoffset: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;]))


                # Calibrate gain comparators
                compDac, self.info = self.ComparatorDACCal(compDict)

                self.cal_dict[&#39;gainComparator&#39;] = dict()
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;] = compDac[0]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;] = not np.isnan(compDac[0])
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;] = compDac[1]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;] = not np.isnan(compDac[1])
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;] = compDac[2]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;] = not np.isnan(compDac[2])
                if len(compDac) &gt; 3:
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;] = compDac[2]
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = not np.isnan(compDac[2])
                else:
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = False

                print(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
                logging.info(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
                f = open(os.path.join(self.folderName, &#39;GO_cal_dict_intermediate.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.cal_dict, f)
                f.close()

                f = open(os.path.join(self.folderName, &#39;GO_info_intermediate.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.info, f)
                f.close()

                return True


        def PerColGOCalib(self):
                &#39;&#39;&#39;
                Performs Per column Gain and Offset calibration and generates gain and offset
                table. 
                
                Inputs: 
                  None 
                  
                Outputs: 
                  cal_dict              - Dictionary containing calibrated values 
                  info                  - Dictionary containing calibration info 
                
                &#39;&#39;&#39;

                cal_dict = self.cal_dict
                info = self.info

                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])

                print(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)
                logging.info(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)

                tmp = info[&#39;dacDiffVoltageTargetPre&#39;]
                tmp = np.append(tmp, np.reshape(tmp[:,2],(len(tmp[:,2]),1)), axis=1)
                info[&#39;dacDiffVoltageTargetPre&#39;] = tmp # Use 3rd gain transition voltage to calibrate 4th gain
                info[&#39;DacSel&#39;] = np.append(info[&#39;DacSel&#39;], info[&#39;DacSel&#39;][2])
                info[&#39;normalizedSatPerCol&#39;] = 0

                forceSingleGain = [0x2A00, 0x2C00, 0x3400, 0x5400]
                dumpTimingLastState = &#39;&#39;
                info[&#39;gainCalVoltageDiff&#39;] = np.zeros([4,2])

                NFRAMES = self.GO_settings[&#39;NFRAMES&#39;]
                compCalSatLimit = self.GO_settings[&#39;compCalSatLimit&#39;]
                ADC_FS = self.GO_settings[&#39;ADC_FS&#39;]
                doplot = self.GO_settings[&#39;doplot&#39;]

                ta, tb, SAT_test = self.API.GetFramesPCGO(NFRAMES) #
                ADC_Native = np.zeros(np.append(np.shape(SAT_test), (4,2)))


                s=self.API.regwrite(0x0014,0x0000)


                for gainTransition in range(3,-1,-1):
                        for posNeg in range(1,-1,-1):
                                print(&#39;\n--- Gain&#39;, gainTransition, &#39;---&#39;)
                                logging.info(&#39;\n--- Gain&#39; + str(gainTransition) + &#39;---&#39;)
                                print(&#39;Setting %17s to target: %3.0fmV&#39;
                                        %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %17s to target: %3.0fmV&#39;
                                        %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(info[&#39;DacCal&#39;],info[&#39;DacSel&#39;][gainTransition],
                                                                                                        info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition],info[&#39;CMwindow&#39;])
                                success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                                self.API.error_assert(success, &#39;Failed to force single gain&#39;)

                                if info[&#39;DacSel&#39;][gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                                        
                                        if dumpTimingLastState != &#39;CMREF-AMPTEST0&#39;: # configure DE timing to use DAC inputs for both native and binned modes
                                                tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                                tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                        count = 5
                                        while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                                time.sleep(1)
                                                self.API.testBoardADC()
                                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                                count = count - 1

                                elif info[&#39;DacSel&#39;][gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:

                                        if dumpTimingLastState != &#39;AMPTEST1-AMPTEST0&#39;:
                                                tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                                tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                        while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                                time.sleep(1)
                                                self.API.testBoardADC()
                                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                                count = count - 1

                                else:
                                        raise Exception(&#39;Incorrect DacSel value&#39;)
                                        logging.error(&#39;Incorrect DacSel value&#39;)

                                dumpTimingLastState = info[&#39;DacSel&#39;][gainTransition].upper()
                                print(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000))
                                logging.info(str(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000)))

                                GT, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                                # GT = ta
                                # ADC_tmp = tb 
                                # SAT = SAT_test

                                if np.any(GT != gainTransition):
                                        raise Exception(&#39;Incorrect forced comparator gain setting returned&#39;)
                                        logging.error(&#39;Incorrect forced comparator gain setting returned&#39;)

                                if np.any(SAT):
                                        normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                                        (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                                        print(&#34;Pixels saturated!&#34;, np.max(normalizedSatPerCol), &#34;limit:&#34;,compCalSatLimit)
                                        logging.warning(&#34;Pixels saturated!&#34; + str(np.max(normalizedSatPerCol)) + &#34;limit:&#34;+ str(compCalSatLimit))
                                        if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                                raise Exception(&#39;Saturation occurred for gain&#39;)
                                                logging.error(&#39;Saturation occurred for gain&#39;)
                                        else:
                                                print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                                logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                                ADC_tmp = ADC_tmp.astype(np.float)
                                                ADC_tmp[SAT] = np.nan

                                ADC_Native[:,:,:,:,gainTransition,posNeg] = ADC_tmp


                print(&#39;\nMeasuring per column offsets (native dump)&#39;)
                logging.info(&#39;\nMeasuring per column offsets (native dump)&#39;)

                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])


                status = self.API.UpdateUseCaseFrameSetting(3, &#39;DRAINSTYLE&#39;, 1)
                self.API.error_assert(status, &#39;Unable to set drain style&#39;)
                s = self.API.regwrite(0x0014, 0x0000)

                s = self.API.regwrite(0x0E1C, 0x0000)
                s = self.API.regwrite(0x0E1E, 0x0010)
                s = self.API.regwrite(0x0E20, 0x0000)
                s = self.API.regwrite(0x0E22, 0x0010)
                s = self.API.regwrite(0x0E24, 0x0000)
                s = self.API.regwrite(0x0E26, 0x0010)
                s = self.API.regwrite(0x0E28, 0x0000)
                s = self.API.regwrite(0x0E2A, 0x0010)
                s = self.API.regwrite(0x0E2C, 0x0000)
                s = self.API.regwrite(0x0E2E, 0x0010)
                _, _, SAT_test = self.API.GetFramesPCGO(NFRAMES) 

                self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
                measuredOffsetNative = np.zeros([1024,2,4])

                for gainTransition in range(3,-1,-1):
                        success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                        time.sleep(0.1)
                        # print(&#39;regrmw value&#39;, gainTransition, &#39;--&gt;&#39;, forceSingleGain[gainTransition])
                        self.API.error_assert(success, &#39;Failed to force single gain&#39;)
                        _, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                        print(&#39;Max ADC:&#39;, np.max(ADC_tmp))
                        logging.info(&#39;Max ADC:&#39; + str(np.max(ADC_tmp)))
                        print(&#39;Min ADC:&#39;, np.min(ADC_tmp))
                        logging.info(&#39;Min ADC:&#39; + str(np.min(ADC_tmp)))
                        print(&#39;Mean ADC:&#39;, np.mean(ADC_tmp))
                        logging.info(&#39;Mean ADC:&#39; + str(np.mean(ADC_tmp)))
                        # np.save(&#39;Offsetframe&#39; + str(gainTransition), ADC_tmp)

                        if np.any(SAT):
                                normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                                (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                                if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                        raise Exception(&#39;Saturation occurred for gain&#39;)
                                        logging.error(&#39;Saturation occurred for gain&#39;)
                                else:
                                        print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        ADC_tmp = ADC_tmp.astype(np.float)
                                        ADC_tmp[SAT] = np.nan

                        ADC_tmp = np.squeeze(np.transpose(ADC_tmp, (1,0,2,3)))
                        measuredOffsetNative[:,0,gainTransition] = np.nanmean(ADC_tmp[:, ::2],1) # even rows offset
                        measuredOffsetNative[:,1,gainTransition] = np.nanmean(ADC_tmp[:, 1::2],1) # even rows offset

                del GT, SAT, ADC_tmp

                ADC_Native = np.transpose(ADC_Native, (1,0,4,5,2,3)) # change to order: [column, row, gain,upper/lower value, phase, frame#]

                f = open(os.path.join(self.folderName, &#39;ADC_Native.pkl&#39;), &#39;wb&#39;)
                pickle.dump(ADC_Native,f)
                f.close()

                tmp = np.transpose(ADC_Native[:,:,:,0,:,:], (2,0,1,3,4))
                info[&#39;ADC_Native_max&#39;] = np.max(np.reshape(tmp,(4,-1)), 1)
                info[&#39;ADC_Native_max&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
                info[&#39;ADC_Native_mean_high&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)
                tmp = np.transpose(ADC_Native[:,:,:,1,:,:], (2,0,1,3,4))
                info[&#39;ADC_Native_min&#39;] = np.min(np.reshape(tmp,(4,-1)), 1)
                info[&#39;ADC_Native_min&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
                info[&#39;ADC_Native_mean_low&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)

                print(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;]))
                logging.info(str(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;])))

                print(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;]))
                logging.info(str(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;])))

                print(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;]))
                logging.info(str(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;])))

                print(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;]))
                logging.info(str(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;])))

                ADC_Native = np.nanmean(ADC_Native, axis = 5)  # take mean of dimensions [frame#, phase]
                ADC_Native = np.squeeze(np.nanmean(ADC_Native, axis = 4))

                tmp = list(np.shape(ADC_Native))
                tmp[1] = 2
                ADC_out = np.zeros(tmp) # take mean of every 2nd row (dimensions [col, even/odd row, gain, upper/lower value])

                ADC_out[:,0,:,:] = np.nanmean(ADC_Native[:,::2,:,:], axis=1)
                ADC_out[:,1,:,:] = np.nanmean(ADC_Native[:,1::2,:,:], axis=1)

                tmp_divisor = np.reshape(info[&#39;gainCalVoltageDiff&#39;][:,1] - info[&#39;gainCalVoltageDiff&#39;][:,0],(1,1,4))
                measuredGainNative = (ADC_out[:,:,:,1] - ADC_out[:,:,:,0]) / tmp_divisor

                info[&#39;ampgainMeasuredNative&#39;] = np.squeeze(np.mean(np.median(measuredGainNative,axis=0),axis=0)) / (2**(9+self.tenBitMode)/(ADC_FS*2))
                print(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;]))
                logging.info(str(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;])))
                expectedAmpGain = self.API.ReadAmpGainSetting()

                # perform a gross check that gains are within 20% of expected value
                measuredGainLimit = 0.2
                ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &gt; (1+measuredGainLimit))
                if np.any(ampGainLimit):
                        raise Exception(&#39;Measured gain above limit&#39;)
                        logging.error(&#39;Measured gain above limit&#39;)
                ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &lt; (1-measuredGainLimit))
                if np.any(ampGainLimit):
                        raise Exception(&#39;Measured gain below limit&#39;)
                        logging.error(&#39;Measured gain below limit&#39;)

                f1 = open(os.path.join(self.folderName, &#34;measuredGainNative.pkl&#34;), &#39;wb&#39;)
                measuredGainNative_dict = dict()
                measuredGainNative_dict[&#39;measuredGainNative&#39;] = measuredGainNative
                measuredGainNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
                measuredGainNative_dict[&#39;ADC_FS&#39;] = ADC_FS
                pickle.dump(measuredGainNative_dict, f1)
                f1.close()

                f2 = open(os.path.join(self.folderName, &#34;measuredOffsetNative.pkl&#34;), &#39;wb&#39;)
                measuredOffsetNative_dict = dict()
                measuredOffsetNative_dict[&#39;measuredOffsetNative&#39;] = measuredOffsetNative
                measuredOffsetNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
                measuredOffsetNative_dict[&#39;ADC_FS&#39;] = ADC_FS
                pickle.dump(measuredOffsetNative_dict, f2)
                f2.close()


                # Gain and Offset Correction
                highestGainMeas = np.mean(np.median(measuredGainNative[:,:,0],axis=0))
                nominalGain = np.append(np.array([1]), highestGainMeas/ np.mean(np.median(measuredGainNative[:,:,1:4],axis=0),axis=0))
                targetGainNative = highestGainMeas / measuredGainNative

                inverseGlobalADCGain, perColGainAdj, clampedGain = R2L.GainRaw2Lx5(targetGainNative, nominalGain)
                if np.any(clampedGain) == True:
                        raise Exception(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)
                        logging.error(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)

                success, ramDataGain, perColumnGainAdjustment = R2L.GeneratePerColRam(perColGainAdj)
                # ramDataGain is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
                # perColumnGainAdjustment is a dictionary with data per mode
                # ramDataGain = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]

                if self.tenBitMode:
                        perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-512,&#39;bpp_10&#39;)
                else:
                        perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-256,&#39;bpp_9&#39;)

                if np.any(clampedOffset) == True:
                        raise Exception(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)
                        logging.error(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)

                success, ramDataOffset, perColumnOffsetAdjustment = R2L.GeneratePerColRam(perColOffset)
                # ramDataOffset is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
                # perColumnOffsetAdjustment is a dictionary with data per mode
                # ramDataOffset = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]
                self.cal_dict[&#39;inverseGlobalADCGain&#39;] = inverseGlobalADCGain
                self.cal_dict[&#39;perColumnGainAdjustment&#39;] = perColumnGainAdjustment
                self.cal_dict[&#39;perColumnOffsetAdjustment&#39;] = perColumnOffsetAdjustment
                self.cal_dict[&#39;ramDataGain&#39;] = ramDataGain
                self.cal_dict[&#39;ramDataOffset&#39;] = ramDataOffset

                self.cal_dict[&#39;info&#39;] = dict()
                now = datetime.now()
                self.cal_dict[&#39;info&#39;][&#39;CheckSum&#39;] = 0
                self.cal_dict[&#39;info&#39;][&#39;Year&#39;] = int(now.strftime(&#39;%Y&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Month&#39;] = int(now.strftime(&#39;%m&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Day&#39;] = int(now.strftime(&#39;%d&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Hour&#39;] = int(now.strftime(&#39;%H&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Minute&#39;] = int(now.strftime(&#39;%M&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Second&#39;] = int(now.strftime(&#39;%S&#39;))
                self.cal_dict[&#39;info&#39;][&#39;configuration_file&#39;] = self.cfg_file

                limits_file = self.yaml_file[&#39;limits_file&#39;]
                try:
                        with open(limits_file) as y:
                                limits = yaml.load(y, Loader=yaml.SafeLoader)[&#39;GainOffsetCalibration&#39;]
                except:
                        raise Exception(&#34;\n\nWARNING: Incorrect/non-existing limits file\n\n&#34;)

                self.cal_dict[&#39;gain_offset_pass&#39;] = True #Initialize to True

                adc_delay = np.round(self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;],3)
                if limits[&#39;adc_delay&#39;][0] &lt; adc_delay &lt; limits[&#39;adc_delay&#39;][1]:
                        adc_delay_status = &#34;PASSED&#34;
                else:
                        adc_delay_status = &#34;FAILED&#34;
                        print(&#39;\nADC offset delay FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = [adc_delay, adc_delay_status, limits[&#39;adc_delay&#39;][0], limits[&#39;adc_delay&#39;][1]]

                MeasuredGain0 = np.round(info[&#39;ampgainMeasuredNative&#39;][0],3)
                if MeasuredGain0 &gt; limits[&#39;Gain0_MeasNative&#39;][0]:
                        Gain0_Native_status = &#34;PASSED&#34;
                else:
                        Gain0_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_MeasNative&#39;] = [MeasuredGain0, Gain0_Native_status, limits[&#39;Gain0_MeasNative&#39;][0], limits[&#39;Gain0_MeasNative&#39;][1]]

                MeasuredGain1 = np.round(info[&#39;ampgainMeasuredNative&#39;][1],3)
                if MeasuredGain1 &gt; limits[&#39;Gain1_MeasNative&#39;][0]:
                        Gain1_Native_status = &#34;PASSED&#34;
                else:
                        Gain1_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_MeasNative&#39;] = [MeasuredGain1, Gain1_Native_status, limits[&#39;Gain1_MeasNative&#39;][0], limits[&#39;Gain1_MeasNative&#39;][1]]

                MeasuredGain2 = np.round(info[&#39;ampgainMeasuredNative&#39;][2],3)
                if MeasuredGain2 &gt; limits[&#39;Gain2_MeasNative&#39;][0]:
                        Gain2_Native_status = &#34;PASSED&#34;
                else:
                        Gain2_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_MeasNative&#39;] = [MeasuredGain2, Gain2_Native_status, limits[&#39;Gain2_MeasNative&#39;][0], limits[&#39;Gain2_MeasNative&#39;][1]]

                MeasuredGain3 = np.round(info[&#39;ampgainMeasuredNative&#39;][3],3)
                if MeasuredGain3 &gt; limits[&#39;Gain3_MeasNative&#39;][0]:
                        Gain3_Native_status = &#34;PASSED&#34;
                else:
                        Gain3_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain3 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain3_MeasNative&#39;] = [MeasuredGain3, Gain3_Native_status, limits[&#39;Gain3_MeasNative&#39;][0], limits[&#39;Gain3_MeasNative&#39;][1]]

                Gain0_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][0],3)
                if limits[&#39;Gain0_ADC_min&#39;][0] &lt; Gain0_ADC_min &lt; limits[&#39;Gain0_ADC_min&#39;][1]:
                        Gain0_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain0_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_ADC_min&#39;] = [Gain0_ADC_min, Gain0_ADC_min_status, limits[&#39;Gain0_ADC_min&#39;][0], limits[&#39;Gain0_ADC_min&#39;][1]]

                Gain0_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][0],3)
                if limits[&#39;Gain0_ADC_max&#39;][0] &lt; Gain0_ADC_max &lt; limits[&#39;Gain0_ADC_max&#39;][1]:
                        Gain0_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain0_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_ADC_max&#39;] = [Gain0_ADC_max, Gain0_ADC_max_status, limits[&#39;Gain0_ADC_max&#39;][0], limits[&#39;Gain0_ADC_max&#39;][1]]

                Gain1_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][1],3)
                if limits[&#39;Gain1_ADC_min&#39;][0] &lt; Gain1_ADC_min &lt; limits[&#39;Gain1_ADC_min&#39;][1]:
                        Gain1_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain1_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_ADC_min&#39;] = [Gain1_ADC_min, Gain1_ADC_min_status, limits[&#39;Gain1_ADC_min&#39;][0], limits[&#39;Gain1_ADC_min&#39;][1]]

                Gain1_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][1],3)
                if limits[&#39;Gain1_ADC_max&#39;][0] &lt; Gain1_ADC_max &lt; limits[&#39;Gain1_ADC_max&#39;][1]:
                        Gain1_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain1_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_ADC_max&#39;] = [Gain1_ADC_max, Gain1_ADC_max_status, limits[&#39;Gain1_ADC_max&#39;][0], limits[&#39;Gain1_ADC_max&#39;][1]]

                Gain2_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][2],3)
                if limits[&#39;Gain2_ADC_min&#39;][0] &lt; Gain2_ADC_min &lt; limits[&#39;Gain2_ADC_min&#39;][1]:
                        Gain2_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain2_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_ADC_min&#39;] = [Gain2_ADC_min, Gain2_ADC_min_status, limits[&#39;Gain2_ADC_min&#39;][0], limits[&#39;Gain2_ADC_min&#39;][1]]

                Gain2_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][2],3)
                if limits[&#39;Gain2_ADC_max&#39;][0] &lt; Gain2_ADC_max &lt; limits[&#39;Gain2_ADC_max&#39;][1]:
                        Gain2_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain2_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_ADC_max&#39;] = [Gain2_ADC_max, Gain2_ADC_max_status, limits[&#39;Gain2_ADC_max&#39;][0], limits[&#39;Gain2_ADC_max&#39;][1]]

                comp_vref1 = self.info[&#39;voltage_comp_vref1&#39;]
                if comp_vref1 &gt; limits[&#39;comp_vref1&#39;][0]:
                        comp_vref1_status = &#34;PASSED&#34;
                else:
                        comp_vref1_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref1 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref1&#39;] = [comp_vref1, comp_vref1_status, limits[&#39;comp_vref1&#39;][0], limits[&#39;comp_vref1&#39;][1]]

                comp_vref2 = self.info[&#39;voltage_comp_vref2&#39;]
                if comp_vref2 &gt; limits[&#39;comp_vref2&#39;][0]:
                        comp_vref2_status = &#34;PASSED&#34;
                else:
                        comp_vref2_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref2 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref2&#39;] = [comp_vref2, comp_vref2_status, limits[&#39;comp_vref2&#39;][0], limits[&#39;comp_vref2&#39;][1]]

                comp_vref3 = self.info[&#39;voltage_comp_vref3&#39;]
                if comp_vref3 &gt; limits[&#39;comp_vref3&#39;][0]:
                        comp_vref3_status = &#34;PASSED&#34;
                else:
                        comp_vref3_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref3 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref3&#39;] = [comp_vref3, comp_vref3_status, limits[&#39;comp_vref3&#39;][0], limits[&#39;comp_vref3&#39;][1]]

                self.cal_dict[&#39;info&#39;][&#39;Pass&#39;] = self.cal_dict[&#39;gain_offset_pass&#39;]

                f1 = open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_pkl&#39;] + &#39;.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.cal_dict, f1)
                f1.close()

                f2 = open(os.path.join(self.folderName, &#34;GO_info.pkl&#34;), &#39;wb&#39;)
                pickle.dump(self.info, f2)
                f2.close()


                print(&#39;Calibration file with&#39;, self.cal_dict.keys())
                c = csv.writer(open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_csv&#39;] +&#39;.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

                if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
                else:
                        c.writerow([self.const_hex(0x0000)])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

                tmp = self.cal_dict[&#39;ramDataGain&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                tmp = self.cal_dict[&#39;ramDataOffset&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])



                c = csv.writer(open(os.path.join(&#39;_tempCalFiles&#39;, &#39;GO_cal_dict.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

                if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
                else:
                        c.writerow([self.const_hex(0x0000)])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

                tmp = self.cal_dict[&#39;ramDataGain&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                tmp = self.cal_dict[&#39;ramDataOffset&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                print(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
                logging.info(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
                
                return self.cal_dict, self.info

        
        def ADCCalib(self, ADC_dict):
                &#39;&#39;&#39;
                Performs ADC calibration 
                
                Inputs: 
                  ADC_dict              - input dictionary. 
                  
                Outputs: 
                  calib_iramp           - ADC ramp. 
                  adc_delay             - ADC delay 
                
                &#39;&#39;&#39;
                self.API.testBoardADC()
                print(&#34;\n-------ADC Calibration-------\n&#34;)
                logging.info(&#34;\n-------ADC Calibration-------\n&#34;)
                self.origSetting[&#39;reg&#39;] = dict()
                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.array([],dtype=np.uint16)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.array([],dtype=np.uint16)

                sensormodeID = ADC_dict[&#39;sensormodeID&#39;] # PCM
                nFrames = ADC_dict[&#39;nFrames&#39;]
                DAC_AMPTEST0 = ADC_dict[&#39;DAC_AMPTEST0&#39;]
                DAC_AMPTEST1 = ADC_dict[&#39;DAC_AMPTEST1&#39;]
                iramp = ADC_dict[&#39;iramp&#39;]
                ADC_FS = ADC_dict[&#39;ADC_FS&#39;]
                Cin = ADC_dict[&#39;Cin&#39;]
                Cfb = ADC_dict[&#39;Cfb&#39;]
                AmpGainMeas = ADC_dict[&#39;AmpGainMeas&#39;]
                cleanup = ADC_dict[&#39;cleanup&#39;]


                val = self.API.regread(0x0D1A)
                # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

                tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)

        #       #######################
        #       ## iramp calibration ##
        #       #######################

        #       # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
                status, origDrainStyleVal = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, 1)
                self.API.error_assert(status, &#34;Unable to set drainstyle&#34;)

                # Initialize outputs
                # pre-setup

                origDAC_AMPTEST0 = self.API.dac_amptest0_get()
                origDAC_AMPTEST1 = self.API.dac_amptest1_get()
                origDAC_CMREF = self.API.dac_cmref_get()

                success = self.API.dac_amptest0_set(ADC_dict[&#39;DAC_AMPTEST0&#39;])
                self.API.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
                success = self.API.dac_amptest1_set(ADC_dict[&#39;DAC_AMPTEST1&#39;])
                self.API.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
                success = self.API.dac_cmref_set(255)
                self.API.error_assert(success, &#34;Cannot set dac_cmref&#34;)

                success = self.API.tregwrite(0x010E, self.API.repmatdec2Hex(ADC_dict[&#39;Cin&#39;], 4)) # &#39;1111&#39;
                self.API.error_assert(success, &#34;Cannot write to reg 0x010E Cin&#34;)
                success = self.API.tregwrite(0x010C, self.API.repmatdec2Hex(ADC_dict[&#39;Cfb&#39;], 4)) # &#39;DDDD&#39;
                self.API.error_assert(success, &#34;Cannot write to reg 0x010C Cfb&#34;)

                success = self.API.tregwrite(0x0160, 0x0012) # ana_test_mux = test_sfp (amp_testn_sf)/test_sfn (amp_testp_sf)
                self.API.error_assert(success, &#34;Cannot set register 0x0160&#34;)
                success = self.API.tregwrite(0x0D1A, 0x0004, 0x0007) # enable overflow, disable saturation encoding
                self.API.error_assert(success, &#34;Cannot set register 0x0D1A&#34;)

                success, amp_mux_sel = self.API.regreadburst(0x0E1C, 10, &#39;increment&#39;) # save amp_mux_sel register values before overwriting with wave WAVE_FUNCTION_0
                self.API.error_assert(success, &#34;Unable to read original AMP mux sel register values&#34;)

                for k in range(len(amp_mux_sel)):
                        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E1C + k*2)
                        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], amp_mux_sel[k])

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0234)
                temp = self.API.regread(0x0234) # Read original REG_LP_CTRL register value
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                success, origSettingWaveFunction0 = self.API.GetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;)
                self.API.error_assert(success, &#39;Unable to read original WAVE_FUNCTION_0 register value&#39;)

                #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
                s = self.API.regwrite(0x0E1C, 0x0200)
                s = self.API.regwrite(0x0E1E, 0x0008)
                s = self.API.regwrite(0x0E20, 0x0200)
                s = self.API.regwrite(0x0E22, 0x0008)
                s = self.API.regwrite(0x0E24, 0x0200)
                s = self.API.regwrite(0x0E26, 0x0008)
                s = self.API.regwrite(0x0E28, 0x0200)
                s = self.API.regwrite(0x0E2A, 0x0008)
                s = self.API.regwrite(0x0E2C, 0x0200)
                s = self.API.regwrite(0x0E2E, 0x0008)
                s = self.API.regwrite(0x0234, 0xFDFF)


                s = self.API.regrmw(0x0E18, 0x0000 , 0x7C20) # &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;     

                self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)

                activeDeSignals = [&#39;amp_clk0&#39;, &#39;amp_clk1&#39;, &#39;cmfb_clk&#39;, &#39;adc_in0&#39;, &#39;adc_in1&#39;,
                                                        &#39;adc_capsel&#39;, &#39;adc_rampdir&#39;, &#39;adc_ramppause&#39;, &#39;adc_data_valid&#39;]

                DE_StructOrig = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)
                f = open(os.path.join(self.folderName, &#39;DE_StructOrig.pkl&#39;),&#39;wb&#39;)
                pickle.dump(DE_StructOrig, f)
                f.close()

                DE_Struct = self.API.DumpTimingTransformation(DE_StructOrig, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_2x&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_2x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest0_dacAmpTest1&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_4x&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_4x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_Struct)

                # self.API.legacy_ADC_calib_dump_timings() # alternate matlab implementation

                DE_StartEnd = np.zeros([2,2], dtype=np.uint16)
                success, DE_StartEnd[:,0] = self.API.regreadburst(0x0E36, 2,&#39;increment&#39;)
                #DE_StartEnd[:,0] = tmp[0] # returned as a 2d array
                self.API.error_assert(success, &#39;Failed to read native DE values&#39;)
                success, DE_StartEnd[:,1]= self.API.regreadburst(0x0E3C, 2,&#39;increment&#39;)
                #DE_StartEnd[:,1] = tmp[0]
                self.API.error_assert(success, &#39;Failed to read 2x subsampled DE values&#39;)

                h = self.API.height
                w = self.API.width

                img = np.zeros([h ,w ,nFrames, 2],dtype=np.double)
                delta_img = np.zeros([h,w,nFrames,len(iramp)],dtype=np.double)
                mean_delta = np.zeros(len(iramp))

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E30)
                temp = self.API.regread(0x0E30)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E32)
                temp = self.API.regread(0x0E32)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                for y in range(len(iramp)-1, -1,-1): # 3 2 1 0
                #for y in range(4): # 3 2 1 0
                        success = self.API.regwrite(0x0104, int(iramp[y]))
                        self.API.error_assert(success, &#39;Cannot write to reg 0x0104 ADC iramp control&#39;)

                        for x in range(1,-1,-1): # 1,0
                                success = self.API.tregwrite(0x0014, 0x0000)
                                self.API.error_assert(success, &#39;Failed to unclock gate DE&#39;) # blindly unclock gate all digital
                                #arr_tmp = self.API.convert2matlabArray(DE_StartEnd[:,x])
                                success = self.API.regwriteburst(0x0E30, DE_StartEnd[:,x], &#39;increment&#39;) 
                                # overwrite &#34;native_resolution&#34; start and end address with either &#34;sub_sampled_2x&#34; or &#34;sub_sampled_4x&#34;
                                self.API.error_assert(success, &#39;Failed to write native DE values&#39;)
                                status, img_tmp = self.API.GetFramesADCCalib(nFrames)
                                self.API.error_assert(status, &#39;Cannot get frames for ADC iramp calibration&#39;)
                                for i in range(nFrames):
                                        img[:,:,i,x] = np.bitwise_and(np.array(img_tmp[:,:,i], dtype=np.uint16), 1023) # keep lower 10 bits (ADC data)
                                        img[:,:,i,x] = np.double(img[:,:,i,x])
                                        tmp = ~np.isnan(img[:,:,i,x])
                                        tmp[tmp] = img[:,:,i,x][tmp] &lt; 3 # equivalent of tmp = img &lt; 3
                                        img[:,:,i,x][tmp] = np.nan
                                        img[0:2,:,i,x] = np.nan # ignore first 2 rows
                                        
                        delta_img[:,:,:,y] = img[:,:,:,1] - img[:,:,:,0]
                        mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                        # delta_img[:,:,:,y][delta_img[:,:,:,y] &lt; 0.5*mean_delta[y]] = np.nan
                        # mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                        print(&#39;Mean ADC value:&#39;, np.nanmean(delta_img[:,:,:,y]))
                        logging.info(&#39;Mean ADC value:&#39; + str(np.nanmean(delta_img[:,:,:,y])))
                        print(&#39;Maximum ADC value:&#39;, np.nanmax(delta_img[:,:,:,y]))
                        logging.info(&#39;Minimum ADC value:&#39; + str(np.nanmax(delta_img[:,:,:,y])))
                        print(&#39;Minimum ADC value:&#39;, np.nanmin(delta_img[:,:,:,y]))
                        logging.info(&#39;Maximum ADC value:&#39; + str(np.nanmin(delta_img[:,:,:,y])))


                # status, tetetet = self.API.GetFramesADCCalib(nFrames)
                success = self.API.tregwrite(0x0014, 0x0000) # Work around

                b1 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                b2 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0-AMPTEST1&#39;)
                # print(mean_delta)

                # mean_delta = np.array([255.48918137, 231.19768989, 211.06942671, 194.22303369])
                # b1 = 0.475
                # b2 = -0.4735

                Vin_ADC = (b1-b2)*AmpGainMeas
                targetCode = Vin_ADC * (2**(9 + tenBitMode) - 1) / ADC_FS

                if len(iramp) &gt;= 3:
                        p = np.polyfit(mean_delta, iramp, 2) # quadratic fit is preferred if we have multiple samples
                else:
                        p = np.polyfit(mean_delta, iramp, 1) # else linear fit

                calib_iramp = np.round(np.polyval(p, targetCode),4)

                success = ((calib_iramp &gt;= np.min(iramp)) and (calib_iramp &lt;= np.max(iramp)))
                self.API.error_assert(success, &#39;ADCirampRangeExceeded&#39;)

                success = self.API.regwrite(0x0104, int(calib_iramp))
                print(&#39;Calibrated ADC iramp value:&#39;, calib_iramp)
                logging.info(&#39;Calibrated ADC iramp value:&#39; + str(calib_iramp))

                ############################
                ## ADC offset calibration ##
                ############################

                # Set adc_mux to Vcm
                success = self.API.tregwrite(0x0100, 0x0040, 0x0070)
                self.API.error_assert(success, &#39;Cannot Reg RMW adc_ctrl0_s1&#39;)
                success = self.API.tregwrite(0x0192, 0x0000, 0x0380) # bit[9] is inverted on camera C0 compared to B0 (adc_muxn_inb[2])
                self.API.error_assert(success, &#39;Cannot Reg RMW ana_serial_spare_2&#39;)

                # Read the default delays
                adc_delay = self.API.regread(0x0102) # ADC delay
                # self.API.error_assert(s, &#39;Cannot read reg 0x0102 - adc_delay&#39;)
                adc_delay = self.ADC_Delay_LFSR(adc_delay, reverse=True) # convert register LFSR to linear value

                status, VcmImg_pre = self.API.GetFramesADCCalib(nFrames)
                self.API.error_assert(status, &#39;Cannot grab frames for ADC offset calibration&#39;)

                # Extract 10 ADC bits
                VcmImg = VcmImg_pre
                VcmImg = np.array(VcmImg, dtype=np.double) % 1024 # keep lower 10 bits (ADC data)
                VcmImg[VcmImg &lt; 3] = np.nan

                # plt.figure()
                # plt.imshow(VcmImg[800:1024,800:1024])
                # plt.title(&#39;VcmImg[800:1024,800:1024]&#39;)
                # plt.xlabel(&#39;Imager columns&#39;)
                # plt.ylabel(&#39;Imager rows&#39;)
                # plt.colorbar(label=&#39;ADC offset&#39;)
                # plt.show()

                # plt.plot(VcmImg[800:1024,933,:])
                # plt.title(&#39;VcmImg[900:1024,933]&#39;)
                # plt.show()

                # plt.plot(VcmImg[933,800:1024,:])
                # plt.title(&#39;VcmImg[933,900:1024]&#39;)
                # plt.show()


                # Compute new ADC delay value
                targetCenterVal = 2**(8 + tenBitMode) + 1
                targetCenterVal = targetCenterVal + (6 * 2**tenBitMode)

                adc_delay = np.nanmean(VcmImg) + adc_delay - targetCenterVal

                success = (adc_delay &gt;= 3) and (adc_delay &lt;= 511)
                self.API.error_assert(success, &#39;Calibrated linear ADC offset counter value is out of range [3, 511]&#39;)
                print(&#39;Calibrated ADC delay (linear value):&#39;, adc_delay)
                logging.info(&#39;Calibrated ADC delay (linear value):&#39; + str(adc_delay))
                self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = adc_delay


                adc_delay = self.ADC_Delay_LFSR(np.round(adc_delay))

                success = self.API.regwrite(0x0102, int(adc_delay))
                print(&#39;Calibrated ADC up/dn delay control:&#39;, adc_delay)
                logging.info(&#39;Calibrated ADC up/dn delay control:&#39; + str(adc_delay))

                success = success and self.API.regwrite(0x0014, 0x0000)
                if cleanup:
                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_StructOrig)
                        #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, origSettingWaveFunction0)
                        s = self.API.regwrite(0x0E1C, 0x0200)
                        s = self.API.regwrite(0x0E1E, 0x0008)
                        s = self.API.regwrite(0x0E20, 0x0200)
                        s = self.API.regwrite(0x0E22, 0x0008)
                        s = self.API.regwrite(0x0E24, 0x0200)
                        s = self.API.regwrite(0x0E26, 0x0008)
                        s = self.API.regwrite(0x0E28, 0x0200)
                        s = self.API.regwrite(0x0E2A, 0x0008)
                        s = self.API.regwrite(0x0E2C, 0x0200)
                        s = self.API.regwrite(0x0E2E, 0x0008)
                        s = self.API.regwrite(0x0234, 0xFDFF)

                        #self.API.error_assert(success, &#39;Cannot restore WAVE_FUNCTION_0 register&#39;)
                        self.API.WriteOrigSettings()
                        status = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, origDrainStyleVal)
                        self.API.error_assert(status, &#39;Unable to reset drainstyle&#39;)
                        #success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;sensor_mode&#39;][&#39;set&#39;], origSensorMode)
                        self.API.error_assert(success, &#39;Cannot set original sensor mode&#39;)

                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], origDAC_AMPTEST0)
                        success = self.API.dac_amptest0_set(np.uint8(origDAC_AMPTEST0))
                        self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST0&#39;)
                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], origDAC_AMPTEST1)
                        success = self.API.dac_amptest1_set(np.uint8(origDAC_AMPTEST1))
                        self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST1&#39;)
                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], origDAC_CMREF)
                        success = self.API.dac_cmref_set(origDAC_CMREF)
                        self.API.error_assert(success, &#39;Cannot set original DAC_CMREF&#39;)



                return calib_iramp, adc_delay


        def ComparatorDACCal(self, compDict):
                &#39;&#39;&#39;
                Performs Comparator DAC calibration. Requires ADC calibration to be done
                prior. 
                
                Inputs: 
                  compDict              - input dictionary. 
                  
                Outputs: 
                  compDAC               - array of calibrated comparator DAC values. 
                  info                  - dictionary containing information regarding
                                          the calibration 
                
                &#39;&#39;&#39;


                self.API.testBoardADC()
                s = self.API.regwrite(0x0014,0x0000)
                print(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
                logging.info(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
                NFRAMES = compDict[&#39;NFRAMES&#39;]
                doplot = compDict[&#39;doplot&#39;]
                compCalThres = compDict[&#39;compCalThres&#39;]
                compCalSatLimit = compDict[&#39;compCalSatLimit&#39;]
                compCalMargin = compDict[&#39;compCalMargin&#39;]

                #self.API.regwrite(0x012E,0x0406)
                #self.API.regwrite(0x0130,0x1F0D)
                self.API.regwrite(0x012E,0x0404)
                self.API.regwrite(0x0130,0x1F0C)
                #self.API.regwrite(0x012E,0x050A)
                #self.API.regwrite(0x0130, 0x1F0F)
                #self.API.regwrite(0x0130, 0x1F0F)
                # self.API.regwrite(0x012E,0x1F1F) # Work around, having a high value will result in saturation -&gt; 0204

                sensormodeID = 3 # Use PCM 
                ADC_FS = 1 # ADC full scale = +/- 1.00V
                DACSweepFineResolution = [5e-3, 5e-3, 10e-3] # Fine target resolution DAC sweep = 5mV for two higher gains, 10mV for lowest gain
                DACSweepCoarseResolution = [10e-3, 10e-3, 20e-3] # Coarse resolution DAC sweep = 10mV for two higher gains, 20mV for lowest gain
                ampgain = self.API.ReadAmpGainSetting() # estimate for expected amp gains

                print(&#39;ampgain:&#39;, ampgain)
                logging.info(&#39;ampgain:&#39; + str(ampgain))

                val = self.API.regread(0x0D1A) # determine if we are using 9b or 10b data
                #       self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)
                tenBitMode = bool(not self.API.bitget(int(val),3))

                compDacOrig = np.zeros(3, dtype=&#39;int&#39;)

                val = self.API.regread(0x012E)

                #       self.API.error_assert(success, &#39;Failed to read comparator DAC register&#39;)
                compDacOrig[0] = int(val) &amp; int(&#39;0x00FF&#39;, 0)
                compDacOrig[1] = (int(val) &amp; int(&#39;0xFF00&#39;, 0)) &gt;&gt; 8
                val = self.API.regread(0x0130)
                #       self.API.error_assert(success, &#39;Failed to read DAC register&#39;)
                compDacOrig[2] = int(val) &amp; int(&#39;0x00FF&#39;, 0)

                # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
                status = self.API.UpdateUseCaseFrameSetting(sensormodeID, &#39;DRAINSTYLE&#39;, 1)

                self.API.error_assert(status, &#39;Unable to set drain style&#39;)
                s = self.API.regwrite(0x0014, 0x0000)
                # success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
                # self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
                s = self.API.regwrite(0x0E1C, 0x0200)
                s = self.API.regwrite(0x0E1E, 0x0008)
                s = self.API.regwrite(0x0E20, 0x0200)
                s = self.API.regwrite(0x0E22, 0x0008)
                s = self.API.regwrite(0x0E24, 0x0200)
                s = self.API.regwrite(0x0E26, 0x0008)
                s = self.API.regwrite(0x0E28, 0x0200)
                s = self.API.regwrite(0x0E2A, 0x0008)
                s = self.API.regwrite(0x0E2C, 0x0200)
                s = self.API.regwrite(0x0E2E, 0x0008)
                s = self.API.regwrite(0x0234, 0xFDFF)


                success = self.API.regrmw(0x012A, 0x0000, 0x7E00 ) # clear comp_ref_disable[5:0] to enable multigain
                self.API.error_assert(success, &#39;Failed to enable all gain comparators&#39;)

        
                DE_Struct = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)

                DacCal = dict()
                CMwindow = [2.10, 2.15] # Define the Common Mode range of the DACs (post source follower) for both the &#34;reset&#34; and &#34;integrate&#34; samples
                DacSel = [&#39;CMREF-AMPTEST0&#39;,&#39;CMREF-AMPTEST0&#39;,&#39;AMPTEST1-AMPTEST0&#39;] # Define which pair of DACs to use for each of the 3 gain comparators
                # CMREF-AMPTEST0 provides more resolution (since CMREF step size is smaller), while AMPTEST1-AMPTEST0 provides more range
                forceCompDac = [0x2800, 0x2400, 0x1400]

                dacDiffVoltagePost = np.ones([2,3]) * np.nan
                dacDiffVoltagePre = np.ones([2,3]) * np.nan # variable to store pre/post transition voltages. dimensions [positive/negative comparator, gain comparator 0-2]

                # initial guess for comparator voltage is 90% of expected ADC full scale
                # quantized to target sweep resolution
                dacDiffVoltagePost[0,:] = np.round(0.9*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

                # define an upper limit of 120% of expected ADC full scale
                dacDiffVoltageLimit = np.ceil(1.2*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

                GT_pos = np.zeros(3,dtype=object)
                ADC_pos = np.zeros(3,dtype=object)
                SAT_pos = np.zeros(3,dtype=object)
                GT_neg = np.zeros(3,dtype=object)
                ADC_neg = np.zeros(3,dtype=object)
                SAT_neg = np.zeros(3,dtype=object)


                for gainTransition in range(2, -1,-1): # 2,1,0
                        success = self.API.regrmw(0x012A, forceCompDac[gainTransition], 0x7E00)
                        self.API.error_assert(success,&#39;Unable to disable comparators that are not currently under test&#39;)

                        ## Testing positive comparator

                        print(&#39;\n---Gain&#39;, gainTransition, &#39;---&#39;)
                        logging.info(&#39;\n---Gain &#39; + str(gainTransition) + &#39; ---&#39;)
                        print(&#39;\nTesting positive comparator\n&#39;)
                        logging.info(&#39;\nTesting positive comparator\n&#39;)
                        if DacSel[gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                                tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                        elif DacSel[gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:
                                tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                        else:
                                raise Exception(&#34;Incorrect DacSel value&#34;)
                                logging.error(&#39;Incorrect DacSel value&#39;)
                        
                        print(&#34;Setting&#34;, DacSel[gainTransition], &#34;to target: &#34;, str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)
                        logging.info(&#34;Setting &#34; + str(DacSel[gainTransition]) + &#34; to target: &#34; + str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)


                        DacCal, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)


                        # print(DacCal[&#39;RangeCMREF&#39;], DacCal[&#39;RangeAMPTEST0&#39;], DacCal[&#39;RangeAMPTEST1&#39;])
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                        
                        # while any(vec(GT_tmp)&lt;gainTransition)  --&gt; while not all pixels transitioned to the desired gain setting, increase voltage
                        while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):

                                print(&#39;Coarse search l1 any&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1)), &#39;&lt; Thresh&#39;, compCalThres)

                                GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                                ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePost[0, gainTransition]

                                dacDiffVoltagePost[0, gainTransition] = dacDiffVoltagePost[0,gainTransition] + DACSweepCoarseResolution[gainTransition] # increase voltage by DACSweepCoarseResolution
                                dacDiffVoltagePost[0, gainTransition] = (np.round(dacDiffVoltagePost[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                success = np.abs(dacDiffVoltagePost[0,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                                self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                        
                        if np.isnan(dacDiffVoltagePre[0,gainTransition]): # we only found high value, so need to search for an inital low value
                                dacDiffVoltagePre[0,gainTransition] = dacDiffVoltagePost[0,gainTransition]
                                while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):

                                        print(&#39;Coarse search l1 nan all&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)), &#39;&gt;= Thresh&#39;, compCalThres)

                                        dacDiffVoltagePost[0,gainTransition] = dacDiffVoltagePre[0,gainTransition]
                                        dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePre[0,gainTransition] - DACSweepCoarseResolution[gainTransition] # decrease voltage by DACSweepCoarseResolution
                                        dacDiffVoltagePre[0, gainTransition] = (np.round(dacDiffVoltagePre[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3))
                                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3)))
                                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition],CMwindow)
                                        
                                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                        # Binary fine search
                        while(np.round(np.abs(dacDiffVoltagePost[0,gainTransition] - dacDiffVoltagePre[0,gainTransition]) / DACSweepFineResolution[gainTransition]) &gt; 1):
                                # perform fine search (&#39;round&#39; required to prevent rounding errors in subtraction)
                                dacDiffVoltageTest = np.mean([dacDiffVoltagePost[0,gainTransition],dacDiffVoltagePre[0,gainTransition]])
                                dacDiffVoltageTest = np.round(dacDiffVoltageTest / DACSweepFineResolution[gainTransition]) * DACSweepFineResolution[gainTransition]

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltageTest,CMwindow)

                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                if (np.any(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &lt; compCalThres))):
                                        GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                        ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                        SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                        dacDiffVoltagePre[0,gainTransition] = dacDiffVoltageTest
                                else:
                                        dacDiffVoltagePost[0,gainTransition] = dacDiffVoltageTest

                        ## Find transition point for negative comparator
                        print(&#39;\nTesting negative comparator\n&#39;)
                        logging.info(&#39;\nTesting negative comparator\n&#39;)
                        dacDiffVoltagePost[1, gainTransition] = -1* dacDiffVoltagePost[0, gainTransition]
                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                
                        while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):
                                GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                                ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePost[1, gainTransition]

                                dacDiffVoltagePost[1, gainTransition] = dacDiffVoltagePost[1,gainTransition] - DACSweepFineResolution[gainTransition] 
                                # decrease voltage by DACSweepFineResolution (using fine search only since it should be similar to positive DAC)
                                dacDiffVoltagePost[1, gainTransition] = (np.round(dacDiffVoltagePost[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        if (np.isnan(dacDiffVoltagePre[1,gainTransition])):
                                dacDiffVoltagePre[1,gainTransition] = dacDiffVoltagePost[1,gainTransition] + DACSweepFineResolution[gainTransition] 
                                # increase voltage by DACSweepFineResolution
                                success = np.abs(dacDiffVoltagePost[1,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                                self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)
                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                ainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):
                                        dacDiffVoltagePost[1,gainTransition] = dacDiffVoltagePre[1,gainTransition] # store previous measurement as pre-transition voltage 
                                        dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePre[1,gainTransition] + DACSweepFineResolution[gainTransition] # increase voltage by DACSweepFIneResolution
                                        dacDiffVoltagePre[1, gainTransition] = (np.round(dacDiffVoltagePre[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution
                                        
                                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                                        
                                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                        # print(dacDiffVoltagePre)
                        # print(dacDiffVoltagePost)
                success = self.API.regrmw(0x012A, 0x0000, 0x7E00)
                self.API.error_assert(success, &#39;Unable to enable comparators for normal operation&#39;)

                f = open(os.path.join(self.folderName, &#39;DacCalibration.pkl&#39;),&#39;wb&#39;)
                pickle.dump(DacCal,f)
                f.close()


                maxADCperCol = np.zeros([3, np.shape(ADC_pos[0])[0]])
                minADCperCol = np.zeros([3, np.shape(ADC_neg[0])[0]])
                sum_SAT_pos = np.zeros([3, np.shape(SAT_pos[0])[0]])
                sum_SAT_neg = np.zeros([3, np.shape(SAT_neg[0])[0]])


                for i in range(3):
                        maxADCperCol[i] = np.max(ADC_pos[i], axis = 1)
                        minADCperCol[i] = np.min(ADC_neg[i], axis = 1)
                        sum_SAT_pos[i] = np.sum(SAT_pos[i], axis = 1)
                        sum_SAT_neg[i] = np.sum(SAT_neg[i], axis = 1)

                anySaturationDetected = np.any(np.append(sum_SAT_pos, sum_SAT_neg, axis=1), axis=1)

                if np.any(anySaturationDetected):
                        if doplot:
                                plt.figure()
                                for i in range(3):
                                        plt.plot(range(0,1024), sum_SAT_pos[i] / np.shape(SAT_pos[i])[1], label = &#39;(+) Gain &#39;+ str(i))
                                        plt.plot(range(0,1024), sum_SAT_neg[i] / np.shape(SAT_neg[i])[1], label = &#39;(-) Gain &#39;+ str(i))
                                plt.legend()
                                plt.xlabel(&#39;Pixel col (0-1023)&#39;)
                                plt.savefig(os.path.join(self.folderName, &#39;ComparatorSaturation.png&#39;))

                        mean_divisor = np.shape(SAT_pos[i])[1]
                        perColSaturation = np.max(np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor]), axis = 2)
                        numColsExceedSatLimit = np.sum(perColSaturation &gt; compCalSatLimit, axis = 1)
                        if np.any(numColsExceedSatLimit):
                                plt.savefig(os.path.join(self.folderName, &#39;Saturation.png&#39;))
                                self.API.error_assert(False,&#39;Saturation limit exceeded for comparator DAC calibration&#39;)
                        else:
                                print(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)
                                logging.warning(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)


                MinMaxADCValueperCol = dict()
                MinMaxADCValueperCol[&#39;maxADCperCol&#39;] = maxADCperCol
                MinMaxADCValueperCol[&#39;minADCperCol&#39;] = minADCperCol
                f = open(os.path.join(self.folderName, &#39;MinMaxADCValueperCol.pkl&#39;), &#39;wb&#39;)
                pickle.dump(MinMaxADCValueperCol, f)
                f.close()

                measADCmargin = np.array([np.min(minADCperCol,1) - 3, 2**(9+tenBitMode)-1 - np.max(maxADCperCol,1)]) / (2**(8+tenBitMode))
                measADCmargin = np.min(measADCmargin, axis = 0)
                measADCmargin[anySaturationDetected] = 0

                print(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1)))
                logging.info(str(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1))))
                print(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1)))
                logging.info(str(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1))))

                # Measure the slope of each comparator DAC.  TODO: Characterize compDac_mVperLSB over a number of units and
                # replace with a hardcoded value instead of measuring each camera chip individually
                # self.API.testBoardADC()
                dacLow = 0
                dacHigh = 63
                numVoltageSamples = 1

                v = np.zeros(2)
                compDac_mVperLSB = np.zeros(3)

                success = self.API.regrmw(0x012E, dacLow, 0x00FF)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = 10
                while((abs(v[0]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                        time.sleep(1)
                        v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                        count = count -1
                success = success and self.API.regrmw(0x012E, dacHigh , 0x00FF)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = 10
                while((abs(v[1]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                        time.sleep(1)
                        v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                        count = count -1
                compDac_mVperLSB[0] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

                success = success and self.API.regrmw(0x012E, dacLow*256, 0xFF00)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
                success = success and self.API.regrmw(0x012E, dacHigh*256, 0xFF00)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
                compDac_mVperLSB[1] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

                success = success and self.API.regrmw(0x0130, dacLow, 0x00FF)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
                success = success and self.API.regrmw(0x0130, dacHigh, 0x00FF)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
                compDac_mVperLSB[2] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3               # Measured mV/DAC code
                self.API.error_assert(success, &#39;Failed to measure comparator DAC voltages&#39;)

                estimatedADCperCompDACLSB = compDac_mVperLSB * 1e-3 * ampgain[0:3] / ADC_FS # estimate (normalized) ADC change per LSB of comparator DAC change

                compDacAdjusted = compDacOrig + np.floor((measADCmargin - np.array(compCalMargin)) / estimatedADCperCompDACLSB)

                compDac = np.clip(compDacAdjusted,0,63)

                if np.any(compDac != compDacAdjusted):
                        print(&#39;WARNING: Comparator DAC clamped!&#39;)

                success = self.API.regwrite(0x012E, np.uint16(compDac[1]*256+compDac[0]))
                success = success and self.API.regrmw(0x0130, int(compDac[2]) , 0x003F)
                self.API.error_assert(success, &#39;Failed to write comparator DAC settings to chip&#39;)

                print(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0]))
                logging.info(str(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0])))
                print(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1]))
                logging.info(str(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1])))
                print(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2]))
                logging.info(str(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2])))

                info = dict()
                info[&#39;compDacOrig&#39;] = compDacOrig
                info[&#39;compCalSaturationDetected&#39;] = anySaturationDetected
                info[&#39;DacClamped&#39;] = compDac != compDacAdjusted
                info[&#39;dacDiffVoltageTargetPre&#39;] = dacDiffVoltagePre
                info[&#39;DE_Struct&#39;] = DE_Struct
                info[&#39;DacCal&#39;] = DacCal
                info[&#39;DacSel&#39;] = DacSel
                info[&#39;CMwindow&#39;] = CMwindow
                info[&#39;compMinADC&#39;] = np.min(minADCperCol,axis=1)
                info[&#39;compMaxADC&#39;] = np.max(maxADCperCol,axis=1)

                info[&#39;voltage_comp_vref1&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;) * 1000 #in mV
                info[&#39;voltage_comp_vref2&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;) * 1000 #in mV
                info[&#39;voltage_comp_vref3&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;) * 1000 #in mV
                mean_divisor = float(np.shape(SAT_pos[i])[1])
                info[&#39;compCalSatPerGainPerColPerPosNeg&#39;] = np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor], (1,2,0))
                # number of saturated pixels. Dimensions: [gain transition, column, positive/negative comparator]

                return compDac, info

        def ADC_Delay_LFSR(self, inputVal, reverse=False):
                &#39;&#39;&#39;
                Translate ADC delay decimal value to 9-bit LFSR seed value based on LFSR polynomial: x9 + x5 + 1
                Also supports reverse lookup (to convert LFSR to decimal) 
                
                Inputs: 
                  inputVal           - input value 
                  reverse (optional) - if true, reverse lookup. i.e. inputVal is a LFSR value and
                                       outputVal is the corresponding decimal value 
                Outputs: 
                  outputVal             - output value.  
                
                Note: outVal is returned empty if inputVal is invalid. 
                &#39;&#39;&#39;
                # Generate table
                lfsrSeq9 = np.zeros(2**9 - 1, dtype=np.uint16)
                mask = int(&#39;0x01FE&#39;, 0)
                for i in range(2**9 - 2):
                        curVal = lfsrSeq9[i]
                        bit0Val = not((self.API.bitget(curVal, 3))^(self.API.bitget(curVal, 8))) # a ^ b is a XOR b in python
                        newVal = (curVal &lt;&lt; 1) &amp; mask
                        lfsrSeq9[i+1] = ((newVal &gt;&gt; 1) &lt;&lt; 1) + bit0Val # equivalent of bitset(newVal, 1, bit1Val)

                # ADC counter adds an additional 2 cycle offset that is compensated for in
                # the lookup here.  Additionally, a LFSR value of zero is invalid in the
                # design

                if not(reverse):
                        if (inputVal &lt; 3) or (inputVal &gt; 512):
                                raise Exception(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                                logging.error(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                        else:
                                outputVal = lfsrSeq9[int(inputVal - 2)] # ADC counter design has an offset of 2, but python indexes start at 0

                else:
                        if (inputVal == 0):
                                raise Exception(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                                logging.error(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                        else:
                                try:
                                        outputVal = list(lfsrSeq9).index(inputVal) + 2
                                except:
                                        raise Exception(&#39;Invalid 9b adc_delay LFSR value specified:&#39;, inputVal)
                                        logging.error(&#39;Invalid 9b adc_delay LFSR value specified: &#39; + str(inputVal))

                return outputVal</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="GO_functions.GainOffset"><code class="flex name class">
<span>class <span class="ident">GainOffset</span></span>
<span>(</span><span>GO_settings, file, CalibfolderName)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GainOffset:
        def __init__(self, GO_settings, file, CalibfolderName):
                self.GO_settings = GO_settings
                self.cal_dict = dict()
                self.origSetting = dict()
                self.CalibfolderName = CalibfolderName
                self.folderName = os.path.join(CalibfolderName, str(file[&#39;GainOffsetCalibration&#39;][&#39;output_directory&#39;]))
                self.cfg_file = file[&#39;GainOffsetCalibration&#39;][&#39;configuration_file&#39;]
                module_class = file[&#39;module_class&#39;]

                if not os.path.exists(self.folderName):
                        os.mkdir(self.folderName)
                else:
                        now = datetime.now()
                        print(&#39;\nALERT: &#39; + self.folderName + &#39; already exists&#39;)
                        old_folderName = self.folderName + str(now.strftime(&#39;_old_%Y%m%d_%H%M%S&#39;))
                        os.rename(self.folderName, old_folderName)
                        print(&#39;ALERT: RENAMING OLD FOLDER: &#39; + self.folderName + &#39; as &#39;+ old_folderName +&#39;\n&#39;)
                        os.mkdir(self.folderName)

                time.sleep(0.1)
                logging.basicConfig(filename=os.path.join(self.folderName, &#39;GainOffset.log&#39;), 
                                                        filemode=&#39;w&#39;, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;,
                                                        level=logging.INFO)
                print(&#39;Created log file&#39;)

                print(&#34;module_class = &#34; + str(module_class))
                logging.info(&#34;module_class = &#34; + str(module_class))

                print(&#34;configuration file cfg = &#34; + str(self.cfg_file))
                logging.info(&#34;configuration file cfg = &#34; + str(self.cfg_file))

                self.yaml_file = file
                self.ADC_cal_settings = file[&#39;GainOffsetCalibration&#39;][&#39;ADC_calibration&#39;]
                self.Comp_DAC_cal_settings = file[&#39;GainOffsetCalibration&#39;][&#39;Comp_DAC_calibration&#39;]

                self.API = tof.CalibAPI(module_class = module_class)
                self.API.ConnectSensor(Mode=3, cfg = self.cfg_file)


        def const_hex(self, val):
                &#39;&#39;&#39;
                Formats hex values to 0x0000 form 
                
                Inputs: 
                  val                   - hex value to be formatted 
                  
                Outputs: 
                  val                   - formatted hex value 
                
                &#39;&#39;&#39;
                val = np.uint16(val)
                return &#39;0x&#39; + &#39;0&#39;*(max(0,4-len(str(hex(val))[2:]))) + str(hex(val))[2:]


        def ConfigureChip(self):
                &#39;&#39;&#39;
                Configures the camera before per-column-Gain and Offset calibration. 
                Performs ADC calibration and CompDAC calibration. 
                
                Inputs:  
                  None  
                   
                Outputs:  
                  True  
                
                &#39;&#39;&#39;
                val = self.API.regread(274)
                success= val == 22833
                self.API.error_assert(success, &#34;Cannot communicate with chip&#34;)

                # ## TODO confirm chip  info
                # status, cfgver = self.API.N_APIComm(2, self.API.API[&#39;IO&#39;][&#39;config_version&#39;][&#39;get&#39;])
                # self.API.error_assert(status, &#34;Cannot get Config version&#34;)

                val = self.API.regread(0x0528)
                # self.API.error_assert(status, &#34;Cannot determine if multigain settings have already been applied&#34;)

                if (int(val)&amp;6) == 6:
                        print(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
                        logging.info(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
                else:
                        success = self.API.regrmw(0x0528, 0x0FFFF, 0x0006)

                success = success and self.API.regwrite(0x0014, 0x0000) # blindly unclock gate all digital
                success = success and self.API.regwrite(0x0500, 0x1002) # Configure read from LX5 DRAM          
                success = success and self.API.regwrite(0x0502, 0x0006) 
                s, val = self.API.regreadburst(0x0506, 5)
                self.cal_dict[&#39;gainCalConfigVersion&#39;] = int(val[4])

                val = self.API.regread(0x0D1A)
                # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

                self.tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)
                self.cal_dict[&#39;ADC&#39;] = dict()


                ADC_dict = dict(
                                                sensormodeID = self.ADC_cal_settings[&#39;sensormodeID&#39;], # PCM
                                                nFrames = self.ADC_cal_settings[&#39;nFrames&#39;],
                                                DAC_AMPTEST0 = self.ADC_cal_settings[&#39;DAC_AMPTEST0&#39;], # ~1.61V
                                                DAC_AMPTEST1 = self.ADC_cal_settings[&#39;DAC_AMPTEST1&#39;], # ~2.05V
                                                iramp = self.ADC_cal_settings[&#39;iramp&#39;],
                                                ADC_FS = self.ADC_cal_settings[&#39;ADC_FS&#39;], # ADC Full Scale = 2Vpp
                                                Cin = self.ADC_cal_settings[&#39;Cin&#39;], # Ampgain setting of 0.99x
                                                Cfb = self.ADC_cal_settings[&#39;Cfb&#39;],
                                                AmpGainMeas = self.ADC_cal_settings[&#39;AmpGainMeas&#39;], # actual amp gain (measured using two single ended probes)
                                                cleanup = self.ADC_cal_settings[&#39;cleanup&#39;] # cleanup after calibration, i,e restore original settings
                                                )

                #Comp_DAC_cal_settings  =file[&#39;Comp_DAC_calibration&#39;]

                compDict = dict(
                                                NFRAMES = self.Comp_DAC_cal_settings[&#39;NFRAMES&#39;], # number of frames to collect per DAC step
                                                doplot = self.Comp_DAC_cal_settings[&#39;doplot&#39;], # flag to generate plots and intermediate outputs
                                                compCalThres = self.Comp_DAC_cal_settings[&#39;compCalThres&#39;], # Threshold for number of comparator samples per column that must have transitioned to the next gain (default if not specified is 99.5%)
                                                compCalSatLimit = self.Comp_DAC_cal_settings[&#39;compCalSatLimit&#39;], # Fail gain calibration if more than compCalSatLimit pixels are saturated within any column at the original comparator DAC setting (default if not specified is 2 pixels per column)
                                                compCalMargin = self.Comp_DAC_cal_settings[&#39;compCalMargin&#39;] # Required margin from max/min ADC value.  This margin is used when adjusting comparator DAC after finding the existing switching point (default if not specified is 5% of full scale)
                                                )

                # Calibrate ADC ramp and up/dn counters
                self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;] = self.ADCCalib(ADC_dict)
                print(&#39;ADC Calibration values: \nADC iramp: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], &#39;\nADC updnoffset: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])
                logging.info(&#39;ADC Calibration values: \nADC iramp: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;]) + &#39;\nADC updnoffset: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;]))


                # Calibrate gain comparators
                compDac, self.info = self.ComparatorDACCal(compDict)

                self.cal_dict[&#39;gainComparator&#39;] = dict()
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;] = compDac[0]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;] = not np.isnan(compDac[0])
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;] = compDac[1]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;] = not np.isnan(compDac[1])
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;] = compDac[2]
                self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;] = not np.isnan(compDac[2])
                if len(compDac) &gt; 3:
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;] = compDac[2]
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = not np.isnan(compDac[2])
                else:
                        self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = False

                print(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
                logging.info(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
                f = open(os.path.join(self.folderName, &#39;GO_cal_dict_intermediate.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.cal_dict, f)
                f.close()

                f = open(os.path.join(self.folderName, &#39;GO_info_intermediate.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.info, f)
                f.close()

                return True


        def PerColGOCalib(self):
                &#39;&#39;&#39;
                Performs Per column Gain and Offset calibration and generates gain and offset
                table. 
                
                Inputs: 
                  None 
                  
                Outputs: 
                  cal_dict              - Dictionary containing calibrated values 
                  info                  - Dictionary containing calibration info 
                
                &#39;&#39;&#39;

                cal_dict = self.cal_dict
                info = self.info

                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])

                print(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)
                logging.info(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)

                tmp = info[&#39;dacDiffVoltageTargetPre&#39;]
                tmp = np.append(tmp, np.reshape(tmp[:,2],(len(tmp[:,2]),1)), axis=1)
                info[&#39;dacDiffVoltageTargetPre&#39;] = tmp # Use 3rd gain transition voltage to calibrate 4th gain
                info[&#39;DacSel&#39;] = np.append(info[&#39;DacSel&#39;], info[&#39;DacSel&#39;][2])
                info[&#39;normalizedSatPerCol&#39;] = 0

                forceSingleGain = [0x2A00, 0x2C00, 0x3400, 0x5400]
                dumpTimingLastState = &#39;&#39;
                info[&#39;gainCalVoltageDiff&#39;] = np.zeros([4,2])

                NFRAMES = self.GO_settings[&#39;NFRAMES&#39;]
                compCalSatLimit = self.GO_settings[&#39;compCalSatLimit&#39;]
                ADC_FS = self.GO_settings[&#39;ADC_FS&#39;]
                doplot = self.GO_settings[&#39;doplot&#39;]

                ta, tb, SAT_test = self.API.GetFramesPCGO(NFRAMES) #
                ADC_Native = np.zeros(np.append(np.shape(SAT_test), (4,2)))


                s=self.API.regwrite(0x0014,0x0000)


                for gainTransition in range(3,-1,-1):
                        for posNeg in range(1,-1,-1):
                                print(&#39;\n--- Gain&#39;, gainTransition, &#39;---&#39;)
                                logging.info(&#39;\n--- Gain&#39; + str(gainTransition) + &#39;---&#39;)
                                print(&#39;Setting %17s to target: %3.0fmV&#39;
                                        %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %17s to target: %3.0fmV&#39;
                                        %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(info[&#39;DacCal&#39;],info[&#39;DacSel&#39;][gainTransition],
                                                                                                        info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition],info[&#39;CMwindow&#39;])
                                success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                                self.API.error_assert(success, &#39;Failed to force single gain&#39;)

                                if info[&#39;DacSel&#39;][gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                                        
                                        if dumpTimingLastState != &#39;CMREF-AMPTEST0&#39;: # configure DE timing to use DAC inputs for both native and binned modes
                                                tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                                tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                        count = 5
                                        while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                                time.sleep(1)
                                                self.API.testBoardADC()
                                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                                count = count - 1

                                elif info[&#39;DacSel&#39;][gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:

                                        if dumpTimingLastState != &#39;AMPTEST1-AMPTEST0&#39;:
                                                tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                                tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                        while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                                time.sleep(1)
                                                self.API.testBoardADC()
                                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                                count = count - 1

                                else:
                                        raise Exception(&#39;Incorrect DacSel value&#39;)
                                        logging.error(&#39;Incorrect DacSel value&#39;)

                                dumpTimingLastState = info[&#39;DacSel&#39;][gainTransition].upper()
                                print(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000))
                                logging.info(str(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000)))

                                GT, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                                # GT = ta
                                # ADC_tmp = tb 
                                # SAT = SAT_test

                                if np.any(GT != gainTransition):
                                        raise Exception(&#39;Incorrect forced comparator gain setting returned&#39;)
                                        logging.error(&#39;Incorrect forced comparator gain setting returned&#39;)

                                if np.any(SAT):
                                        normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                                        (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                                        print(&#34;Pixels saturated!&#34;, np.max(normalizedSatPerCol), &#34;limit:&#34;,compCalSatLimit)
                                        logging.warning(&#34;Pixels saturated!&#34; + str(np.max(normalizedSatPerCol)) + &#34;limit:&#34;+ str(compCalSatLimit))
                                        if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                                raise Exception(&#39;Saturation occurred for gain&#39;)
                                                logging.error(&#39;Saturation occurred for gain&#39;)
                                        else:
                                                print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                                logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                                ADC_tmp = ADC_tmp.astype(np.float)
                                                ADC_tmp[SAT] = np.nan

                                ADC_Native[:,:,:,:,gainTransition,posNeg] = ADC_tmp


                print(&#39;\nMeasuring per column offsets (native dump)&#39;)
                logging.info(&#39;\nMeasuring per column offsets (native dump)&#39;)

                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])


                status = self.API.UpdateUseCaseFrameSetting(3, &#39;DRAINSTYLE&#39;, 1)
                self.API.error_assert(status, &#39;Unable to set drain style&#39;)
                s = self.API.regwrite(0x0014, 0x0000)

                s = self.API.regwrite(0x0E1C, 0x0000)
                s = self.API.regwrite(0x0E1E, 0x0010)
                s = self.API.regwrite(0x0E20, 0x0000)
                s = self.API.regwrite(0x0E22, 0x0010)
                s = self.API.regwrite(0x0E24, 0x0000)
                s = self.API.regwrite(0x0E26, 0x0010)
                s = self.API.regwrite(0x0E28, 0x0000)
                s = self.API.regwrite(0x0E2A, 0x0010)
                s = self.API.regwrite(0x0E2C, 0x0000)
                s = self.API.regwrite(0x0E2E, 0x0010)
                _, _, SAT_test = self.API.GetFramesPCGO(NFRAMES) 

                self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
                measuredOffsetNative = np.zeros([1024,2,4])

                for gainTransition in range(3,-1,-1):
                        success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                        time.sleep(0.1)
                        # print(&#39;regrmw value&#39;, gainTransition, &#39;--&gt;&#39;, forceSingleGain[gainTransition])
                        self.API.error_assert(success, &#39;Failed to force single gain&#39;)
                        _, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                        print(&#39;Max ADC:&#39;, np.max(ADC_tmp))
                        logging.info(&#39;Max ADC:&#39; + str(np.max(ADC_tmp)))
                        print(&#39;Min ADC:&#39;, np.min(ADC_tmp))
                        logging.info(&#39;Min ADC:&#39; + str(np.min(ADC_tmp)))
                        print(&#39;Mean ADC:&#39;, np.mean(ADC_tmp))
                        logging.info(&#39;Mean ADC:&#39; + str(np.mean(ADC_tmp)))
                        # np.save(&#39;Offsetframe&#39; + str(gainTransition), ADC_tmp)

                        if np.any(SAT):
                                normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                                (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                                if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                        raise Exception(&#39;Saturation occurred for gain&#39;)
                                        logging.error(&#39;Saturation occurred for gain&#39;)
                                else:
                                        print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        ADC_tmp = ADC_tmp.astype(np.float)
                                        ADC_tmp[SAT] = np.nan

                        ADC_tmp = np.squeeze(np.transpose(ADC_tmp, (1,0,2,3)))
                        measuredOffsetNative[:,0,gainTransition] = np.nanmean(ADC_tmp[:, ::2],1) # even rows offset
                        measuredOffsetNative[:,1,gainTransition] = np.nanmean(ADC_tmp[:, 1::2],1) # even rows offset

                del GT, SAT, ADC_tmp

                ADC_Native = np.transpose(ADC_Native, (1,0,4,5,2,3)) # change to order: [column, row, gain,upper/lower value, phase, frame#]

                f = open(os.path.join(self.folderName, &#39;ADC_Native.pkl&#39;), &#39;wb&#39;)
                pickle.dump(ADC_Native,f)
                f.close()

                tmp = np.transpose(ADC_Native[:,:,:,0,:,:], (2,0,1,3,4))
                info[&#39;ADC_Native_max&#39;] = np.max(np.reshape(tmp,(4,-1)), 1)
                info[&#39;ADC_Native_max&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
                info[&#39;ADC_Native_mean_high&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)
                tmp = np.transpose(ADC_Native[:,:,:,1,:,:], (2,0,1,3,4))
                info[&#39;ADC_Native_min&#39;] = np.min(np.reshape(tmp,(4,-1)), 1)
                info[&#39;ADC_Native_min&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
                info[&#39;ADC_Native_mean_low&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)

                print(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;]))
                logging.info(str(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;])))

                print(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;]))
                logging.info(str(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;])))

                print(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;]))
                logging.info(str(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;])))

                print(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;]))
                logging.info(str(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;])))

                ADC_Native = np.nanmean(ADC_Native, axis = 5)  # take mean of dimensions [frame#, phase]
                ADC_Native = np.squeeze(np.nanmean(ADC_Native, axis = 4))

                tmp = list(np.shape(ADC_Native))
                tmp[1] = 2
                ADC_out = np.zeros(tmp) # take mean of every 2nd row (dimensions [col, even/odd row, gain, upper/lower value])

                ADC_out[:,0,:,:] = np.nanmean(ADC_Native[:,::2,:,:], axis=1)
                ADC_out[:,1,:,:] = np.nanmean(ADC_Native[:,1::2,:,:], axis=1)

                tmp_divisor = np.reshape(info[&#39;gainCalVoltageDiff&#39;][:,1] - info[&#39;gainCalVoltageDiff&#39;][:,0],(1,1,4))
                measuredGainNative = (ADC_out[:,:,:,1] - ADC_out[:,:,:,0]) / tmp_divisor

                info[&#39;ampgainMeasuredNative&#39;] = np.squeeze(np.mean(np.median(measuredGainNative,axis=0),axis=0)) / (2**(9+self.tenBitMode)/(ADC_FS*2))
                print(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;]))
                logging.info(str(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;])))
                expectedAmpGain = self.API.ReadAmpGainSetting()

                # perform a gross check that gains are within 20% of expected value
                measuredGainLimit = 0.2
                ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &gt; (1+measuredGainLimit))
                if np.any(ampGainLimit):
                        raise Exception(&#39;Measured gain above limit&#39;)
                        logging.error(&#39;Measured gain above limit&#39;)
                ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &lt; (1-measuredGainLimit))
                if np.any(ampGainLimit):
                        raise Exception(&#39;Measured gain below limit&#39;)
                        logging.error(&#39;Measured gain below limit&#39;)

                f1 = open(os.path.join(self.folderName, &#34;measuredGainNative.pkl&#34;), &#39;wb&#39;)
                measuredGainNative_dict = dict()
                measuredGainNative_dict[&#39;measuredGainNative&#39;] = measuredGainNative
                measuredGainNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
                measuredGainNative_dict[&#39;ADC_FS&#39;] = ADC_FS
                pickle.dump(measuredGainNative_dict, f1)
                f1.close()

                f2 = open(os.path.join(self.folderName, &#34;measuredOffsetNative.pkl&#34;), &#39;wb&#39;)
                measuredOffsetNative_dict = dict()
                measuredOffsetNative_dict[&#39;measuredOffsetNative&#39;] = measuredOffsetNative
                measuredOffsetNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
                measuredOffsetNative_dict[&#39;ADC_FS&#39;] = ADC_FS
                pickle.dump(measuredOffsetNative_dict, f2)
                f2.close()


                # Gain and Offset Correction
                highestGainMeas = np.mean(np.median(measuredGainNative[:,:,0],axis=0))
                nominalGain = np.append(np.array([1]), highestGainMeas/ np.mean(np.median(measuredGainNative[:,:,1:4],axis=0),axis=0))
                targetGainNative = highestGainMeas / measuredGainNative

                inverseGlobalADCGain, perColGainAdj, clampedGain = R2L.GainRaw2Lx5(targetGainNative, nominalGain)
                if np.any(clampedGain) == True:
                        raise Exception(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)
                        logging.error(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)

                success, ramDataGain, perColumnGainAdjustment = R2L.GeneratePerColRam(perColGainAdj)
                # ramDataGain is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
                # perColumnGainAdjustment is a dictionary with data per mode
                # ramDataGain = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]

                if self.tenBitMode:
                        perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-512,&#39;bpp_10&#39;)
                else:
                        perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-256,&#39;bpp_9&#39;)

                if np.any(clampedOffset) == True:
                        raise Exception(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)
                        logging.error(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)

                success, ramDataOffset, perColumnOffsetAdjustment = R2L.GeneratePerColRam(perColOffset)
                # ramDataOffset is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
                # perColumnOffsetAdjustment is a dictionary with data per mode
                # ramDataOffset = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]
                self.cal_dict[&#39;inverseGlobalADCGain&#39;] = inverseGlobalADCGain
                self.cal_dict[&#39;perColumnGainAdjustment&#39;] = perColumnGainAdjustment
                self.cal_dict[&#39;perColumnOffsetAdjustment&#39;] = perColumnOffsetAdjustment
                self.cal_dict[&#39;ramDataGain&#39;] = ramDataGain
                self.cal_dict[&#39;ramDataOffset&#39;] = ramDataOffset

                self.cal_dict[&#39;info&#39;] = dict()
                now = datetime.now()
                self.cal_dict[&#39;info&#39;][&#39;CheckSum&#39;] = 0
                self.cal_dict[&#39;info&#39;][&#39;Year&#39;] = int(now.strftime(&#39;%Y&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Month&#39;] = int(now.strftime(&#39;%m&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Day&#39;] = int(now.strftime(&#39;%d&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Hour&#39;] = int(now.strftime(&#39;%H&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Minute&#39;] = int(now.strftime(&#39;%M&#39;))
                self.cal_dict[&#39;info&#39;][&#39;Second&#39;] = int(now.strftime(&#39;%S&#39;))
                self.cal_dict[&#39;info&#39;][&#39;configuration_file&#39;] = self.cfg_file

                limits_file = self.yaml_file[&#39;limits_file&#39;]
                try:
                        with open(limits_file) as y:
                                limits = yaml.load(y, Loader=yaml.SafeLoader)[&#39;GainOffsetCalibration&#39;]
                except:
                        raise Exception(&#34;\n\nWARNING: Incorrect/non-existing limits file\n\n&#34;)

                self.cal_dict[&#39;gain_offset_pass&#39;] = True #Initialize to True

                adc_delay = np.round(self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;],3)
                if limits[&#39;adc_delay&#39;][0] &lt; adc_delay &lt; limits[&#39;adc_delay&#39;][1]:
                        adc_delay_status = &#34;PASSED&#34;
                else:
                        adc_delay_status = &#34;FAILED&#34;
                        print(&#39;\nADC offset delay FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = [adc_delay, adc_delay_status, limits[&#39;adc_delay&#39;][0], limits[&#39;adc_delay&#39;][1]]

                MeasuredGain0 = np.round(info[&#39;ampgainMeasuredNative&#39;][0],3)
                if MeasuredGain0 &gt; limits[&#39;Gain0_MeasNative&#39;][0]:
                        Gain0_Native_status = &#34;PASSED&#34;
                else:
                        Gain0_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_MeasNative&#39;] = [MeasuredGain0, Gain0_Native_status, limits[&#39;Gain0_MeasNative&#39;][0], limits[&#39;Gain0_MeasNative&#39;][1]]

                MeasuredGain1 = np.round(info[&#39;ampgainMeasuredNative&#39;][1],3)
                if MeasuredGain1 &gt; limits[&#39;Gain1_MeasNative&#39;][0]:
                        Gain1_Native_status = &#34;PASSED&#34;
                else:
                        Gain1_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_MeasNative&#39;] = [MeasuredGain1, Gain1_Native_status, limits[&#39;Gain1_MeasNative&#39;][0], limits[&#39;Gain1_MeasNative&#39;][1]]

                MeasuredGain2 = np.round(info[&#39;ampgainMeasuredNative&#39;][2],3)
                if MeasuredGain2 &gt; limits[&#39;Gain2_MeasNative&#39;][0]:
                        Gain2_Native_status = &#34;PASSED&#34;
                else:
                        Gain2_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_MeasNative&#39;] = [MeasuredGain2, Gain2_Native_status, limits[&#39;Gain2_MeasNative&#39;][0], limits[&#39;Gain2_MeasNative&#39;][1]]

                MeasuredGain3 = np.round(info[&#39;ampgainMeasuredNative&#39;][3],3)
                if MeasuredGain3 &gt; limits[&#39;Gain3_MeasNative&#39;][0]:
                        Gain3_Native_status = &#34;PASSED&#34;
                else:
                        Gain3_Native_status = &#34;FAILED&#34;
                        print(&#39;\nGain3 Measured Native FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain3_MeasNative&#39;] = [MeasuredGain3, Gain3_Native_status, limits[&#39;Gain3_MeasNative&#39;][0], limits[&#39;Gain3_MeasNative&#39;][1]]

                Gain0_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][0],3)
                if limits[&#39;Gain0_ADC_min&#39;][0] &lt; Gain0_ADC_min &lt; limits[&#39;Gain0_ADC_min&#39;][1]:
                        Gain0_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain0_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_ADC_min&#39;] = [Gain0_ADC_min, Gain0_ADC_min_status, limits[&#39;Gain0_ADC_min&#39;][0], limits[&#39;Gain0_ADC_min&#39;][1]]

                Gain0_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][0],3)
                if limits[&#39;Gain0_ADC_max&#39;][0] &lt; Gain0_ADC_max &lt; limits[&#39;Gain0_ADC_max&#39;][1]:
                        Gain0_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain0_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain0 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain0_ADC_max&#39;] = [Gain0_ADC_max, Gain0_ADC_max_status, limits[&#39;Gain0_ADC_max&#39;][0], limits[&#39;Gain0_ADC_max&#39;][1]]

                Gain1_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][1],3)
                if limits[&#39;Gain1_ADC_min&#39;][0] &lt; Gain1_ADC_min &lt; limits[&#39;Gain1_ADC_min&#39;][1]:
                        Gain1_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain1_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_ADC_min&#39;] = [Gain1_ADC_min, Gain1_ADC_min_status, limits[&#39;Gain1_ADC_min&#39;][0], limits[&#39;Gain1_ADC_min&#39;][1]]

                Gain1_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][1],3)
                if limits[&#39;Gain1_ADC_max&#39;][0] &lt; Gain1_ADC_max &lt; limits[&#39;Gain1_ADC_max&#39;][1]:
                        Gain1_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain1_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain1 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain1_ADC_max&#39;] = [Gain1_ADC_max, Gain1_ADC_max_status, limits[&#39;Gain1_ADC_max&#39;][0], limits[&#39;Gain1_ADC_max&#39;][1]]

                Gain2_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][2],3)
                if limits[&#39;Gain2_ADC_min&#39;][0] &lt; Gain2_ADC_min &lt; limits[&#39;Gain2_ADC_min&#39;][1]:
                        Gain2_ADC_min_status = &#34;PASSED&#34;
                else:
                        Gain2_ADC_min_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 ADC min margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_ADC_min&#39;] = [Gain2_ADC_min, Gain2_ADC_min_status, limits[&#39;Gain2_ADC_min&#39;][0], limits[&#39;Gain2_ADC_min&#39;][1]]

                Gain2_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][2],3)
                if limits[&#39;Gain2_ADC_max&#39;][0] &lt; Gain2_ADC_max &lt; limits[&#39;Gain2_ADC_max&#39;][1]:
                        Gain2_ADC_max_status = &#34;PASSED&#34;
                else:
                        Gain2_ADC_max_status = &#34;FAILED&#34;
                        print(&#39;\nGain2 ADC max margin FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;Gain2_ADC_max&#39;] = [Gain2_ADC_max, Gain2_ADC_max_status, limits[&#39;Gain2_ADC_max&#39;][0], limits[&#39;Gain2_ADC_max&#39;][1]]

                comp_vref1 = self.info[&#39;voltage_comp_vref1&#39;]
                if comp_vref1 &gt; limits[&#39;comp_vref1&#39;][0]:
                        comp_vref1_status = &#34;PASSED&#34;
                else:
                        comp_vref1_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref1 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref1&#39;] = [comp_vref1, comp_vref1_status, limits[&#39;comp_vref1&#39;][0], limits[&#39;comp_vref1&#39;][1]]

                comp_vref2 = self.info[&#39;voltage_comp_vref2&#39;]
                if comp_vref2 &gt; limits[&#39;comp_vref2&#39;][0]:
                        comp_vref2_status = &#34;PASSED&#34;
                else:
                        comp_vref2_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref2 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref2&#39;] = [comp_vref2, comp_vref2_status, limits[&#39;comp_vref2&#39;][0], limits[&#39;comp_vref2&#39;][1]]

                comp_vref3 = self.info[&#39;voltage_comp_vref3&#39;]
                if comp_vref3 &gt; limits[&#39;comp_vref3&#39;][0]:
                        comp_vref3_status = &#34;PASSED&#34;
                else:
                        comp_vref3_status = &#34;FAILED&#34;
                        print(&#39;\nCompVref3 voltage FAIL\n&#39;)
                        self.cal_dict[&#39;gain_offset_pass&#39;] = False
                self.cal_dict[&#39;comp_vref3&#39;] = [comp_vref3, comp_vref3_status, limits[&#39;comp_vref3&#39;][0], limits[&#39;comp_vref3&#39;][1]]

                self.cal_dict[&#39;info&#39;][&#39;Pass&#39;] = self.cal_dict[&#39;gain_offset_pass&#39;]

                f1 = open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_pkl&#39;] + &#39;.pkl&#39;), &#39;wb&#39;)
                pickle.dump(self.cal_dict, f1)
                f1.close()

                f2 = open(os.path.join(self.folderName, &#34;GO_info.pkl&#34;), &#39;wb&#39;)
                pickle.dump(self.info, f2)
                f2.close()


                print(&#39;Calibration file with&#39;, self.cal_dict.keys())
                c = csv.writer(open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_csv&#39;] +&#39;.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

                if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
                else:
                        c.writerow([self.const_hex(0x0000)])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

                tmp = self.cal_dict[&#39;ramDataGain&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                tmp = self.cal_dict[&#39;ramDataOffset&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])



                c = csv.writer(open(os.path.join(&#39;_tempCalFiles&#39;, &#39;GO_cal_dict.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

                if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
                else:
                        c.writerow([self.const_hex(0x0000)])

                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
                c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

                tmp = self.cal_dict[&#39;ramDataGain&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                tmp = self.cal_dict[&#39;ramDataOffset&#39;]
                for i in range(len(tmp)):
                        c.writerow([self.const_hex(tmp[i])])

                print(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
                logging.info(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
                
                return self.cal_dict, self.info

        
        def ADCCalib(self, ADC_dict):
                &#39;&#39;&#39;
                Performs ADC calibration 
                
                Inputs: 
                  ADC_dict              - input dictionary. 
                  
                Outputs: 
                  calib_iramp           - ADC ramp. 
                  adc_delay             - ADC delay 
                
                &#39;&#39;&#39;
                self.API.testBoardADC()
                print(&#34;\n-------ADC Calibration-------\n&#34;)
                logging.info(&#34;\n-------ADC Calibration-------\n&#34;)
                self.origSetting[&#39;reg&#39;] = dict()
                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.array([],dtype=np.uint16)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.array([],dtype=np.uint16)

                sensormodeID = ADC_dict[&#39;sensormodeID&#39;] # PCM
                nFrames = ADC_dict[&#39;nFrames&#39;]
                DAC_AMPTEST0 = ADC_dict[&#39;DAC_AMPTEST0&#39;]
                DAC_AMPTEST1 = ADC_dict[&#39;DAC_AMPTEST1&#39;]
                iramp = ADC_dict[&#39;iramp&#39;]
                ADC_FS = ADC_dict[&#39;ADC_FS&#39;]
                Cin = ADC_dict[&#39;Cin&#39;]
                Cfb = ADC_dict[&#39;Cfb&#39;]
                AmpGainMeas = ADC_dict[&#39;AmpGainMeas&#39;]
                cleanup = ADC_dict[&#39;cleanup&#39;]


                val = self.API.regread(0x0D1A)
                # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

                tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)

        #       #######################
        #       ## iramp calibration ##
        #       #######################

        #       # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
                status, origDrainStyleVal = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, 1)
                self.API.error_assert(status, &#34;Unable to set drainstyle&#34;)

                # Initialize outputs
                # pre-setup

                origDAC_AMPTEST0 = self.API.dac_amptest0_get()
                origDAC_AMPTEST1 = self.API.dac_amptest1_get()
                origDAC_CMREF = self.API.dac_cmref_get()

                success = self.API.dac_amptest0_set(ADC_dict[&#39;DAC_AMPTEST0&#39;])
                self.API.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
                success = self.API.dac_amptest1_set(ADC_dict[&#39;DAC_AMPTEST1&#39;])
                self.API.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
                success = self.API.dac_cmref_set(255)
                self.API.error_assert(success, &#34;Cannot set dac_cmref&#34;)

                success = self.API.tregwrite(0x010E, self.API.repmatdec2Hex(ADC_dict[&#39;Cin&#39;], 4)) # &#39;1111&#39;
                self.API.error_assert(success, &#34;Cannot write to reg 0x010E Cin&#34;)
                success = self.API.tregwrite(0x010C, self.API.repmatdec2Hex(ADC_dict[&#39;Cfb&#39;], 4)) # &#39;DDDD&#39;
                self.API.error_assert(success, &#34;Cannot write to reg 0x010C Cfb&#34;)

                success = self.API.tregwrite(0x0160, 0x0012) # ana_test_mux = test_sfp (amp_testn_sf)/test_sfn (amp_testp_sf)
                self.API.error_assert(success, &#34;Cannot set register 0x0160&#34;)
                success = self.API.tregwrite(0x0D1A, 0x0004, 0x0007) # enable overflow, disable saturation encoding
                self.API.error_assert(success, &#34;Cannot set register 0x0D1A&#34;)

                success, amp_mux_sel = self.API.regreadburst(0x0E1C, 10, &#39;increment&#39;) # save amp_mux_sel register values before overwriting with wave WAVE_FUNCTION_0
                self.API.error_assert(success, &#34;Unable to read original AMP mux sel register values&#34;)

                for k in range(len(amp_mux_sel)):
                        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E1C + k*2)
                        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], amp_mux_sel[k])

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0234)
                temp = self.API.regread(0x0234) # Read original REG_LP_CTRL register value
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                success, origSettingWaveFunction0 = self.API.GetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;)
                self.API.error_assert(success, &#39;Unable to read original WAVE_FUNCTION_0 register value&#39;)

                #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
                s = self.API.regwrite(0x0E1C, 0x0200)
                s = self.API.regwrite(0x0E1E, 0x0008)
                s = self.API.regwrite(0x0E20, 0x0200)
                s = self.API.regwrite(0x0E22, 0x0008)
                s = self.API.regwrite(0x0E24, 0x0200)
                s = self.API.regwrite(0x0E26, 0x0008)
                s = self.API.regwrite(0x0E28, 0x0200)
                s = self.API.regwrite(0x0E2A, 0x0008)
                s = self.API.regwrite(0x0E2C, 0x0200)
                s = self.API.regwrite(0x0E2E, 0x0008)
                s = self.API.regwrite(0x0234, 0xFDFF)


                s = self.API.regrmw(0x0E18, 0x0000 , 0x7C20) # &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;     

                self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)

                activeDeSignals = [&#39;amp_clk0&#39;, &#39;amp_clk1&#39;, &#39;cmfb_clk&#39;, &#39;adc_in0&#39;, &#39;adc_in1&#39;,
                                                        &#39;adc_capsel&#39;, &#39;adc_rampdir&#39;, &#39;adc_ramppause&#39;, &#39;adc_data_valid&#39;]

                DE_StructOrig = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)
                f = open(os.path.join(self.folderName, &#39;DE_StructOrig.pkl&#39;),&#39;wb&#39;)
                pickle.dump(DE_StructOrig, f)
                f.close()

                DE_Struct = self.API.DumpTimingTransformation(DE_StructOrig, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_2x&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_2x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest0_dacAmpTest1&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_4x&#39;)
                DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_4x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_Struct)

                # self.API.legacy_ADC_calib_dump_timings() # alternate matlab implementation

                DE_StartEnd = np.zeros([2,2], dtype=np.uint16)
                success, DE_StartEnd[:,0] = self.API.regreadburst(0x0E36, 2,&#39;increment&#39;)
                #DE_StartEnd[:,0] = tmp[0] # returned as a 2d array
                self.API.error_assert(success, &#39;Failed to read native DE values&#39;)
                success, DE_StartEnd[:,1]= self.API.regreadburst(0x0E3C, 2,&#39;increment&#39;)
                #DE_StartEnd[:,1] = tmp[0]
                self.API.error_assert(success, &#39;Failed to read 2x subsampled DE values&#39;)

                h = self.API.height
                w = self.API.width

                img = np.zeros([h ,w ,nFrames, 2],dtype=np.double)
                delta_img = np.zeros([h,w,nFrames,len(iramp)],dtype=np.double)
                mean_delta = np.zeros(len(iramp))

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E30)
                temp = self.API.regread(0x0E30)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E32)
                temp = self.API.regread(0x0E32)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

                for y in range(len(iramp)-1, -1,-1): # 3 2 1 0
                #for y in range(4): # 3 2 1 0
                        success = self.API.regwrite(0x0104, int(iramp[y]))
                        self.API.error_assert(success, &#39;Cannot write to reg 0x0104 ADC iramp control&#39;)

                        for x in range(1,-1,-1): # 1,0
                                success = self.API.tregwrite(0x0014, 0x0000)
                                self.API.error_assert(success, &#39;Failed to unclock gate DE&#39;) # blindly unclock gate all digital
                                #arr_tmp = self.API.convert2matlabArray(DE_StartEnd[:,x])
                                success = self.API.regwriteburst(0x0E30, DE_StartEnd[:,x], &#39;increment&#39;) 
                                # overwrite &#34;native_resolution&#34; start and end address with either &#34;sub_sampled_2x&#34; or &#34;sub_sampled_4x&#34;
                                self.API.error_assert(success, &#39;Failed to write native DE values&#39;)
                                status, img_tmp = self.API.GetFramesADCCalib(nFrames)
                                self.API.error_assert(status, &#39;Cannot get frames for ADC iramp calibration&#39;)
                                for i in range(nFrames):
                                        img[:,:,i,x] = np.bitwise_and(np.array(img_tmp[:,:,i], dtype=np.uint16), 1023) # keep lower 10 bits (ADC data)
                                        img[:,:,i,x] = np.double(img[:,:,i,x])
                                        tmp = ~np.isnan(img[:,:,i,x])
                                        tmp[tmp] = img[:,:,i,x][tmp] &lt; 3 # equivalent of tmp = img &lt; 3
                                        img[:,:,i,x][tmp] = np.nan
                                        img[0:2,:,i,x] = np.nan # ignore first 2 rows
                                        
                        delta_img[:,:,:,y] = img[:,:,:,1] - img[:,:,:,0]
                        mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                        # delta_img[:,:,:,y][delta_img[:,:,:,y] &lt; 0.5*mean_delta[y]] = np.nan
                        # mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                        print(&#39;Mean ADC value:&#39;, np.nanmean(delta_img[:,:,:,y]))
                        logging.info(&#39;Mean ADC value:&#39; + str(np.nanmean(delta_img[:,:,:,y])))
                        print(&#39;Maximum ADC value:&#39;, np.nanmax(delta_img[:,:,:,y]))
                        logging.info(&#39;Minimum ADC value:&#39; + str(np.nanmax(delta_img[:,:,:,y])))
                        print(&#39;Minimum ADC value:&#39;, np.nanmin(delta_img[:,:,:,y]))
                        logging.info(&#39;Maximum ADC value:&#39; + str(np.nanmin(delta_img[:,:,:,y])))


                # status, tetetet = self.API.GetFramesADCCalib(nFrames)
                success = self.API.tregwrite(0x0014, 0x0000) # Work around

                b1 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                b2 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0-AMPTEST1&#39;)
                # print(mean_delta)

                # mean_delta = np.array([255.48918137, 231.19768989, 211.06942671, 194.22303369])
                # b1 = 0.475
                # b2 = -0.4735

                Vin_ADC = (b1-b2)*AmpGainMeas
                targetCode = Vin_ADC * (2**(9 + tenBitMode) - 1) / ADC_FS

                if len(iramp) &gt;= 3:
                        p = np.polyfit(mean_delta, iramp, 2) # quadratic fit is preferred if we have multiple samples
                else:
                        p = np.polyfit(mean_delta, iramp, 1) # else linear fit

                calib_iramp = np.round(np.polyval(p, targetCode),4)

                success = ((calib_iramp &gt;= np.min(iramp)) and (calib_iramp &lt;= np.max(iramp)))
                self.API.error_assert(success, &#39;ADCirampRangeExceeded&#39;)

                success = self.API.regwrite(0x0104, int(calib_iramp))
                print(&#39;Calibrated ADC iramp value:&#39;, calib_iramp)
                logging.info(&#39;Calibrated ADC iramp value:&#39; + str(calib_iramp))

                ############################
                ## ADC offset calibration ##
                ############################

                # Set adc_mux to Vcm
                success = self.API.tregwrite(0x0100, 0x0040, 0x0070)
                self.API.error_assert(success, &#39;Cannot Reg RMW adc_ctrl0_s1&#39;)
                success = self.API.tregwrite(0x0192, 0x0000, 0x0380) # bit[9] is inverted on camera C0 compared to B0 (adc_muxn_inb[2])
                self.API.error_assert(success, &#39;Cannot Reg RMW ana_serial_spare_2&#39;)

                # Read the default delays
                adc_delay = self.API.regread(0x0102) # ADC delay
                # self.API.error_assert(s, &#39;Cannot read reg 0x0102 - adc_delay&#39;)
                adc_delay = self.ADC_Delay_LFSR(adc_delay, reverse=True) # convert register LFSR to linear value

                status, VcmImg_pre = self.API.GetFramesADCCalib(nFrames)
                self.API.error_assert(status, &#39;Cannot grab frames for ADC offset calibration&#39;)

                # Extract 10 ADC bits
                VcmImg = VcmImg_pre
                VcmImg = np.array(VcmImg, dtype=np.double) % 1024 # keep lower 10 bits (ADC data)
                VcmImg[VcmImg &lt; 3] = np.nan

                # plt.figure()
                # plt.imshow(VcmImg[800:1024,800:1024])
                # plt.title(&#39;VcmImg[800:1024,800:1024]&#39;)
                # plt.xlabel(&#39;Imager columns&#39;)
                # plt.ylabel(&#39;Imager rows&#39;)
                # plt.colorbar(label=&#39;ADC offset&#39;)
                # plt.show()

                # plt.plot(VcmImg[800:1024,933,:])
                # plt.title(&#39;VcmImg[900:1024,933]&#39;)
                # plt.show()

                # plt.plot(VcmImg[933,800:1024,:])
                # plt.title(&#39;VcmImg[933,900:1024]&#39;)
                # plt.show()


                # Compute new ADC delay value
                targetCenterVal = 2**(8 + tenBitMode) + 1
                targetCenterVal = targetCenterVal + (6 * 2**tenBitMode)

                adc_delay = np.nanmean(VcmImg) + adc_delay - targetCenterVal

                success = (adc_delay &gt;= 3) and (adc_delay &lt;= 511)
                self.API.error_assert(success, &#39;Calibrated linear ADC offset counter value is out of range [3, 511]&#39;)
                print(&#39;Calibrated ADC delay (linear value):&#39;, adc_delay)
                logging.info(&#39;Calibrated ADC delay (linear value):&#39; + str(adc_delay))
                self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = adc_delay


                adc_delay = self.ADC_Delay_LFSR(np.round(adc_delay))

                success = self.API.regwrite(0x0102, int(adc_delay))
                print(&#39;Calibrated ADC up/dn delay control:&#39;, adc_delay)
                logging.info(&#39;Calibrated ADC up/dn delay control:&#39; + str(adc_delay))

                success = success and self.API.regwrite(0x0014, 0x0000)
                if cleanup:
                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_StructOrig)
                        #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, origSettingWaveFunction0)
                        s = self.API.regwrite(0x0E1C, 0x0200)
                        s = self.API.regwrite(0x0E1E, 0x0008)
                        s = self.API.regwrite(0x0E20, 0x0200)
                        s = self.API.regwrite(0x0E22, 0x0008)
                        s = self.API.regwrite(0x0E24, 0x0200)
                        s = self.API.regwrite(0x0E26, 0x0008)
                        s = self.API.regwrite(0x0E28, 0x0200)
                        s = self.API.regwrite(0x0E2A, 0x0008)
                        s = self.API.regwrite(0x0E2C, 0x0200)
                        s = self.API.regwrite(0x0E2E, 0x0008)
                        s = self.API.regwrite(0x0234, 0xFDFF)

                        #self.API.error_assert(success, &#39;Cannot restore WAVE_FUNCTION_0 register&#39;)
                        self.API.WriteOrigSettings()
                        status = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, origDrainStyleVal)
                        self.API.error_assert(status, &#39;Unable to reset drainstyle&#39;)
                        #success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;sensor_mode&#39;][&#39;set&#39;], origSensorMode)
                        self.API.error_assert(success, &#39;Cannot set original sensor mode&#39;)

                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], origDAC_AMPTEST0)
                        success = self.API.dac_amptest0_set(np.uint8(origDAC_AMPTEST0))
                        self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST0&#39;)
                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], origDAC_AMPTEST1)
                        success = self.API.dac_amptest1_set(np.uint8(origDAC_AMPTEST1))
                        self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST1&#39;)
                        #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], origDAC_CMREF)
                        success = self.API.dac_cmref_set(origDAC_CMREF)
                        self.API.error_assert(success, &#39;Cannot set original DAC_CMREF&#39;)



                return calib_iramp, adc_delay


        def ComparatorDACCal(self, compDict):
                &#39;&#39;&#39;
                Performs Comparator DAC calibration. Requires ADC calibration to be done
                prior. 
                
                Inputs: 
                  compDict              - input dictionary. 
                  
                Outputs: 
                  compDAC               - array of calibrated comparator DAC values. 
                  info                  - dictionary containing information regarding
                                          the calibration 
                
                &#39;&#39;&#39;


                self.API.testBoardADC()
                s = self.API.regwrite(0x0014,0x0000)
                print(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
                logging.info(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
                NFRAMES = compDict[&#39;NFRAMES&#39;]
                doplot = compDict[&#39;doplot&#39;]
                compCalThres = compDict[&#39;compCalThres&#39;]
                compCalSatLimit = compDict[&#39;compCalSatLimit&#39;]
                compCalMargin = compDict[&#39;compCalMargin&#39;]

                #self.API.regwrite(0x012E,0x0406)
                #self.API.regwrite(0x0130,0x1F0D)
                self.API.regwrite(0x012E,0x0404)
                self.API.regwrite(0x0130,0x1F0C)
                #self.API.regwrite(0x012E,0x050A)
                #self.API.regwrite(0x0130, 0x1F0F)
                #self.API.regwrite(0x0130, 0x1F0F)
                # self.API.regwrite(0x012E,0x1F1F) # Work around, having a high value will result in saturation -&gt; 0204

                sensormodeID = 3 # Use PCM 
                ADC_FS = 1 # ADC full scale = +/- 1.00V
                DACSweepFineResolution = [5e-3, 5e-3, 10e-3] # Fine target resolution DAC sweep = 5mV for two higher gains, 10mV for lowest gain
                DACSweepCoarseResolution = [10e-3, 10e-3, 20e-3] # Coarse resolution DAC sweep = 10mV for two higher gains, 20mV for lowest gain
                ampgain = self.API.ReadAmpGainSetting() # estimate for expected amp gains

                print(&#39;ampgain:&#39;, ampgain)
                logging.info(&#39;ampgain:&#39; + str(ampgain))

                val = self.API.regread(0x0D1A) # determine if we are using 9b or 10b data
                #       self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)
                tenBitMode = bool(not self.API.bitget(int(val),3))

                compDacOrig = np.zeros(3, dtype=&#39;int&#39;)

                val = self.API.regread(0x012E)

                #       self.API.error_assert(success, &#39;Failed to read comparator DAC register&#39;)
                compDacOrig[0] = int(val) &amp; int(&#39;0x00FF&#39;, 0)
                compDacOrig[1] = (int(val) &amp; int(&#39;0xFF00&#39;, 0)) &gt;&gt; 8
                val = self.API.regread(0x0130)
                #       self.API.error_assert(success, &#39;Failed to read DAC register&#39;)
                compDacOrig[2] = int(val) &amp; int(&#39;0x00FF&#39;, 0)

                # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
                status = self.API.UpdateUseCaseFrameSetting(sensormodeID, &#39;DRAINSTYLE&#39;, 1)

                self.API.error_assert(status, &#39;Unable to set drain style&#39;)
                s = self.API.regwrite(0x0014, 0x0000)
                # success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
                # self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
                s = self.API.regwrite(0x0E1C, 0x0200)
                s = self.API.regwrite(0x0E1E, 0x0008)
                s = self.API.regwrite(0x0E20, 0x0200)
                s = self.API.regwrite(0x0E22, 0x0008)
                s = self.API.regwrite(0x0E24, 0x0200)
                s = self.API.regwrite(0x0E26, 0x0008)
                s = self.API.regwrite(0x0E28, 0x0200)
                s = self.API.regwrite(0x0E2A, 0x0008)
                s = self.API.regwrite(0x0E2C, 0x0200)
                s = self.API.regwrite(0x0E2E, 0x0008)
                s = self.API.regwrite(0x0234, 0xFDFF)


                success = self.API.regrmw(0x012A, 0x0000, 0x7E00 ) # clear comp_ref_disable[5:0] to enable multigain
                self.API.error_assert(success, &#39;Failed to enable all gain comparators&#39;)

        
                DE_Struct = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)

                DacCal = dict()
                CMwindow = [2.10, 2.15] # Define the Common Mode range of the DACs (post source follower) for both the &#34;reset&#34; and &#34;integrate&#34; samples
                DacSel = [&#39;CMREF-AMPTEST0&#39;,&#39;CMREF-AMPTEST0&#39;,&#39;AMPTEST1-AMPTEST0&#39;] # Define which pair of DACs to use for each of the 3 gain comparators
                # CMREF-AMPTEST0 provides more resolution (since CMREF step size is smaller), while AMPTEST1-AMPTEST0 provides more range
                forceCompDac = [0x2800, 0x2400, 0x1400]

                dacDiffVoltagePost = np.ones([2,3]) * np.nan
                dacDiffVoltagePre = np.ones([2,3]) * np.nan # variable to store pre/post transition voltages. dimensions [positive/negative comparator, gain comparator 0-2]

                # initial guess for comparator voltage is 90% of expected ADC full scale
                # quantized to target sweep resolution
                dacDiffVoltagePost[0,:] = np.round(0.9*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

                # define an upper limit of 120% of expected ADC full scale
                dacDiffVoltageLimit = np.ceil(1.2*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

                GT_pos = np.zeros(3,dtype=object)
                ADC_pos = np.zeros(3,dtype=object)
                SAT_pos = np.zeros(3,dtype=object)
                GT_neg = np.zeros(3,dtype=object)
                ADC_neg = np.zeros(3,dtype=object)
                SAT_neg = np.zeros(3,dtype=object)


                for gainTransition in range(2, -1,-1): # 2,1,0
                        success = self.API.regrmw(0x012A, forceCompDac[gainTransition], 0x7E00)
                        self.API.error_assert(success,&#39;Unable to disable comparators that are not currently under test&#39;)

                        ## Testing positive comparator

                        print(&#39;\n---Gain&#39;, gainTransition, &#39;---&#39;)
                        logging.info(&#39;\n---Gain &#39; + str(gainTransition) + &#39; ---&#39;)
                        print(&#39;\nTesting positive comparator\n&#39;)
                        logging.info(&#39;\nTesting positive comparator\n&#39;)
                        if DacSel[gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                                tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                        elif DacSel[gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:
                                tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                        else:
                                raise Exception(&#34;Incorrect DacSel value&#34;)
                                logging.error(&#39;Incorrect DacSel value&#39;)
                        
                        print(&#34;Setting&#34;, DacSel[gainTransition], &#34;to target: &#34;, str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)
                        logging.info(&#34;Setting &#34; + str(DacSel[gainTransition]) + &#34; to target: &#34; + str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)


                        DacCal, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)


                        # print(DacCal[&#39;RangeCMREF&#39;], DacCal[&#39;RangeAMPTEST0&#39;], DacCal[&#39;RangeAMPTEST1&#39;])
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                        
                        # while any(vec(GT_tmp)&lt;gainTransition)  --&gt; while not all pixels transitioned to the desired gain setting, increase voltage
                        while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):

                                print(&#39;Coarse search l1 any&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1)), &#39;&lt; Thresh&#39;, compCalThres)

                                GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                                ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePost[0, gainTransition]

                                dacDiffVoltagePost[0, gainTransition] = dacDiffVoltagePost[0,gainTransition] + DACSweepCoarseResolution[gainTransition] # increase voltage by DACSweepCoarseResolution
                                dacDiffVoltagePost[0, gainTransition] = (np.round(dacDiffVoltagePost[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                success = np.abs(dacDiffVoltagePost[0,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                                self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                        
                        if np.isnan(dacDiffVoltagePre[0,gainTransition]): # we only found high value, so need to search for an inital low value
                                dacDiffVoltagePre[0,gainTransition] = dacDiffVoltagePost[0,gainTransition]
                                while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):

                                        print(&#39;Coarse search l1 nan all&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)), &#39;&gt;= Thresh&#39;, compCalThres)

                                        dacDiffVoltagePost[0,gainTransition] = dacDiffVoltagePre[0,gainTransition]
                                        dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePre[0,gainTransition] - DACSweepCoarseResolution[gainTransition] # decrease voltage by DACSweepCoarseResolution
                                        dacDiffVoltagePre[0, gainTransition] = (np.round(dacDiffVoltagePre[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3))
                                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3)))
                                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition],CMwindow)
                                        
                                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                        # Binary fine search
                        while(np.round(np.abs(dacDiffVoltagePost[0,gainTransition] - dacDiffVoltagePre[0,gainTransition]) / DACSweepFineResolution[gainTransition]) &gt; 1):
                                # perform fine search (&#39;round&#39; required to prevent rounding errors in subtraction)
                                dacDiffVoltageTest = np.mean([dacDiffVoltagePost[0,gainTransition],dacDiffVoltagePre[0,gainTransition]])
                                dacDiffVoltageTest = np.round(dacDiffVoltageTest / DACSweepFineResolution[gainTransition]) * DACSweepFineResolution[gainTransition]

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltageTest,CMwindow)

                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                if (np.any(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &lt; compCalThres))):
                                        GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                        ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                        SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                        dacDiffVoltagePre[0,gainTransition] = dacDiffVoltageTest
                                else:
                                        dacDiffVoltagePost[0,gainTransition] = dacDiffVoltageTest

                        ## Find transition point for negative comparator
                        print(&#39;\nTesting negative comparator\n&#39;)
                        logging.info(&#39;\nTesting negative comparator\n&#39;)
                        dacDiffVoltagePost[1, gainTransition] = -1* dacDiffVoltagePost[0, gainTransition]
                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                  %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                
                        while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):
                                GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                                ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePost[1, gainTransition]

                                dacDiffVoltagePost[1, gainTransition] = dacDiffVoltagePost[1,gainTransition] - DACSweepFineResolution[gainTransition] 
                                # decrease voltage by DACSweepFineResolution (using fine search only since it should be similar to positive DAC)
                                dacDiffVoltagePost[1, gainTransition] = (np.round(dacDiffVoltagePost[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        if (np.isnan(dacDiffVoltagePre[1,gainTransition])):
                                dacDiffVoltagePre[1,gainTransition] = dacDiffVoltagePost[1,gainTransition] + DACSweepFineResolution[gainTransition] 
                                # increase voltage by DACSweepFineResolution
                                success = np.abs(dacDiffVoltagePost[1,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                                self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)
                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                ainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):
                                        dacDiffVoltagePost[1,gainTransition] = dacDiffVoltagePre[1,gainTransition] # store previous measurement as pre-transition voltage 
                                        dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePre[1,gainTransition] + DACSweepFineResolution[gainTransition] # increase voltage by DACSweepFIneResolution
                                        dacDiffVoltagePre[1, gainTransition] = (np.round(dacDiffVoltagePre[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution
                                        
                                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                                        
                                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                                GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                        # print(dacDiffVoltagePre)
                        # print(dacDiffVoltagePost)
                success = self.API.regrmw(0x012A, 0x0000, 0x7E00)
                self.API.error_assert(success, &#39;Unable to enable comparators for normal operation&#39;)

                f = open(os.path.join(self.folderName, &#39;DacCalibration.pkl&#39;),&#39;wb&#39;)
                pickle.dump(DacCal,f)
                f.close()


                maxADCperCol = np.zeros([3, np.shape(ADC_pos[0])[0]])
                minADCperCol = np.zeros([3, np.shape(ADC_neg[0])[0]])
                sum_SAT_pos = np.zeros([3, np.shape(SAT_pos[0])[0]])
                sum_SAT_neg = np.zeros([3, np.shape(SAT_neg[0])[0]])


                for i in range(3):
                        maxADCperCol[i] = np.max(ADC_pos[i], axis = 1)
                        minADCperCol[i] = np.min(ADC_neg[i], axis = 1)
                        sum_SAT_pos[i] = np.sum(SAT_pos[i], axis = 1)
                        sum_SAT_neg[i] = np.sum(SAT_neg[i], axis = 1)

                anySaturationDetected = np.any(np.append(sum_SAT_pos, sum_SAT_neg, axis=1), axis=1)

                if np.any(anySaturationDetected):
                        if doplot:
                                plt.figure()
                                for i in range(3):
                                        plt.plot(range(0,1024), sum_SAT_pos[i] / np.shape(SAT_pos[i])[1], label = &#39;(+) Gain &#39;+ str(i))
                                        plt.plot(range(0,1024), sum_SAT_neg[i] / np.shape(SAT_neg[i])[1], label = &#39;(-) Gain &#39;+ str(i))
                                plt.legend()
                                plt.xlabel(&#39;Pixel col (0-1023)&#39;)
                                plt.savefig(os.path.join(self.folderName, &#39;ComparatorSaturation.png&#39;))

                        mean_divisor = np.shape(SAT_pos[i])[1]
                        perColSaturation = np.max(np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor]), axis = 2)
                        numColsExceedSatLimit = np.sum(perColSaturation &gt; compCalSatLimit, axis = 1)
                        if np.any(numColsExceedSatLimit):
                                plt.savefig(os.path.join(self.folderName, &#39;Saturation.png&#39;))
                                self.API.error_assert(False,&#39;Saturation limit exceeded for comparator DAC calibration&#39;)
                        else:
                                print(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)
                                logging.warning(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)


                MinMaxADCValueperCol = dict()
                MinMaxADCValueperCol[&#39;maxADCperCol&#39;] = maxADCperCol
                MinMaxADCValueperCol[&#39;minADCperCol&#39;] = minADCperCol
                f = open(os.path.join(self.folderName, &#39;MinMaxADCValueperCol.pkl&#39;), &#39;wb&#39;)
                pickle.dump(MinMaxADCValueperCol, f)
                f.close()

                measADCmargin = np.array([np.min(minADCperCol,1) - 3, 2**(9+tenBitMode)-1 - np.max(maxADCperCol,1)]) / (2**(8+tenBitMode))
                measADCmargin = np.min(measADCmargin, axis = 0)
                measADCmargin[anySaturationDetected] = 0

                print(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1)))
                logging.info(str(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1))))
                print(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1)))
                logging.info(str(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1))))

                # Measure the slope of each comparator DAC.  TODO: Characterize compDac_mVperLSB over a number of units and
                # replace with a hardcoded value instead of measuring each camera chip individually
                # self.API.testBoardADC()
                dacLow = 0
                dacHigh = 63
                numVoltageSamples = 1

                v = np.zeros(2)
                compDac_mVperLSB = np.zeros(3)

                success = self.API.regrmw(0x012E, dacLow, 0x00FF)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = 10
                while((abs(v[0]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                        time.sleep(1)
                        v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                        count = count -1
                success = success and self.API.regrmw(0x012E, dacHigh , 0x00FF)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = 10
                while((abs(v[1]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                        time.sleep(1)
                        v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                        count = count -1
                compDac_mVperLSB[0] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

                success = success and self.API.regrmw(0x012E, dacLow*256, 0xFF00)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
                success = success and self.API.regrmw(0x012E, dacHigh*256, 0xFF00)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
                compDac_mVperLSB[1] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

                success = success and self.API.regrmw(0x0130, dacLow, 0x00FF)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
                success = success and self.API.regrmw(0x0130, dacHigh, 0x00FF)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
                compDac_mVperLSB[2] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3               # Measured mV/DAC code
                self.API.error_assert(success, &#39;Failed to measure comparator DAC voltages&#39;)

                estimatedADCperCompDACLSB = compDac_mVperLSB * 1e-3 * ampgain[0:3] / ADC_FS # estimate (normalized) ADC change per LSB of comparator DAC change

                compDacAdjusted = compDacOrig + np.floor((measADCmargin - np.array(compCalMargin)) / estimatedADCperCompDACLSB)

                compDac = np.clip(compDacAdjusted,0,63)

                if np.any(compDac != compDacAdjusted):
                        print(&#39;WARNING: Comparator DAC clamped!&#39;)

                success = self.API.regwrite(0x012E, np.uint16(compDac[1]*256+compDac[0]))
                success = success and self.API.regrmw(0x0130, int(compDac[2]) , 0x003F)
                self.API.error_assert(success, &#39;Failed to write comparator DAC settings to chip&#39;)

                print(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0]))
                logging.info(str(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0])))
                print(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1]))
                logging.info(str(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1])))
                print(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2]))
                logging.info(str(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2])))

                info = dict()
                info[&#39;compDacOrig&#39;] = compDacOrig
                info[&#39;compCalSaturationDetected&#39;] = anySaturationDetected
                info[&#39;DacClamped&#39;] = compDac != compDacAdjusted
                info[&#39;dacDiffVoltageTargetPre&#39;] = dacDiffVoltagePre
                info[&#39;DE_Struct&#39;] = DE_Struct
                info[&#39;DacCal&#39;] = DacCal
                info[&#39;DacSel&#39;] = DacSel
                info[&#39;CMwindow&#39;] = CMwindow
                info[&#39;compMinADC&#39;] = np.min(minADCperCol,axis=1)
                info[&#39;compMaxADC&#39;] = np.max(maxADCperCol,axis=1)

                info[&#39;voltage_comp_vref1&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;) * 1000 #in mV
                info[&#39;voltage_comp_vref2&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;) * 1000 #in mV
                info[&#39;voltage_comp_vref3&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;) * 1000 #in mV
                mean_divisor = float(np.shape(SAT_pos[i])[1])
                info[&#39;compCalSatPerGainPerColPerPosNeg&#39;] = np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor], (1,2,0))
                # number of saturated pixels. Dimensions: [gain transition, column, positive/negative comparator]

                return compDac, info

        def ADC_Delay_LFSR(self, inputVal, reverse=False):
                &#39;&#39;&#39;
                Translate ADC delay decimal value to 9-bit LFSR seed value based on LFSR polynomial: x9 + x5 + 1
                Also supports reverse lookup (to convert LFSR to decimal) 
                
                Inputs: 
                  inputVal           - input value 
                  reverse (optional) - if true, reverse lookup. i.e. inputVal is a LFSR value and
                                       outputVal is the corresponding decimal value 
                Outputs: 
                  outputVal             - output value.  
                
                Note: outVal is returned empty if inputVal is invalid. 
                &#39;&#39;&#39;
                # Generate table
                lfsrSeq9 = np.zeros(2**9 - 1, dtype=np.uint16)
                mask = int(&#39;0x01FE&#39;, 0)
                for i in range(2**9 - 2):
                        curVal = lfsrSeq9[i]
                        bit0Val = not((self.API.bitget(curVal, 3))^(self.API.bitget(curVal, 8))) # a ^ b is a XOR b in python
                        newVal = (curVal &lt;&lt; 1) &amp; mask
                        lfsrSeq9[i+1] = ((newVal &gt;&gt; 1) &lt;&lt; 1) + bit0Val # equivalent of bitset(newVal, 1, bit1Val)

                # ADC counter adds an additional 2 cycle offset that is compensated for in
                # the lookup here.  Additionally, a LFSR value of zero is invalid in the
                # design

                if not(reverse):
                        if (inputVal &lt; 3) or (inputVal &gt; 512):
                                raise Exception(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                                logging.error(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                        else:
                                outputVal = lfsrSeq9[int(inputVal - 2)] # ADC counter design has an offset of 2, but python indexes start at 0

                else:
                        if (inputVal == 0):
                                raise Exception(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                                logging.error(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                        else:
                                try:
                                        outputVal = list(lfsrSeq9).index(inputVal) + 2
                                except:
                                        raise Exception(&#39;Invalid 9b adc_delay LFSR value specified:&#39;, inputVal)
                                        logging.error(&#39;Invalid 9b adc_delay LFSR value specified: &#39; + str(inputVal))

                return outputVal</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="GO_functions.GainOffset.ADCCalib"><code class="name flex">
<span>def <span class="ident">ADCCalib</span></span>(<span>self, ADC_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs ADC calibration </p>
<p>Inputs:
ADC_dict
- input dictionary. </p>
<p>Outputs:
calib_iramp
- ADC ramp.
adc_delay
- ADC delay</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ADCCalib(self, ADC_dict):
        &#39;&#39;&#39;
        Performs ADC calibration 
        
        Inputs: 
          ADC_dict              - input dictionary. 
          
        Outputs: 
          calib_iramp           - ADC ramp. 
          adc_delay             - ADC delay 
        
        &#39;&#39;&#39;
        self.API.testBoardADC()
        print(&#34;\n-------ADC Calibration-------\n&#34;)
        logging.info(&#34;\n-------ADC Calibration-------\n&#34;)
        self.origSetting[&#39;reg&#39;] = dict()
        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.array([],dtype=np.uint16)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.array([],dtype=np.uint16)

        sensormodeID = ADC_dict[&#39;sensormodeID&#39;] # PCM
        nFrames = ADC_dict[&#39;nFrames&#39;]
        DAC_AMPTEST0 = ADC_dict[&#39;DAC_AMPTEST0&#39;]
        DAC_AMPTEST1 = ADC_dict[&#39;DAC_AMPTEST1&#39;]
        iramp = ADC_dict[&#39;iramp&#39;]
        ADC_FS = ADC_dict[&#39;ADC_FS&#39;]
        Cin = ADC_dict[&#39;Cin&#39;]
        Cfb = ADC_dict[&#39;Cfb&#39;]
        AmpGainMeas = ADC_dict[&#39;AmpGainMeas&#39;]
        cleanup = ADC_dict[&#39;cleanup&#39;]


        val = self.API.regread(0x0D1A)
        # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

        tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)

#       #######################
#       ## iramp calibration ##
#       #######################

#       # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
        status, origDrainStyleVal = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, 1)
        self.API.error_assert(status, &#34;Unable to set drainstyle&#34;)

        # Initialize outputs
        # pre-setup

        origDAC_AMPTEST0 = self.API.dac_amptest0_get()
        origDAC_AMPTEST1 = self.API.dac_amptest1_get()
        origDAC_CMREF = self.API.dac_cmref_get()

        success = self.API.dac_amptest0_set(ADC_dict[&#39;DAC_AMPTEST0&#39;])
        self.API.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
        success = self.API.dac_amptest1_set(ADC_dict[&#39;DAC_AMPTEST1&#39;])
        self.API.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
        success = self.API.dac_cmref_set(255)
        self.API.error_assert(success, &#34;Cannot set dac_cmref&#34;)

        success = self.API.tregwrite(0x010E, self.API.repmatdec2Hex(ADC_dict[&#39;Cin&#39;], 4)) # &#39;1111&#39;
        self.API.error_assert(success, &#34;Cannot write to reg 0x010E Cin&#34;)
        success = self.API.tregwrite(0x010C, self.API.repmatdec2Hex(ADC_dict[&#39;Cfb&#39;], 4)) # &#39;DDDD&#39;
        self.API.error_assert(success, &#34;Cannot write to reg 0x010C Cfb&#34;)

        success = self.API.tregwrite(0x0160, 0x0012) # ana_test_mux = test_sfp (amp_testn_sf)/test_sfn (amp_testp_sf)
        self.API.error_assert(success, &#34;Cannot set register 0x0160&#34;)
        success = self.API.tregwrite(0x0D1A, 0x0004, 0x0007) # enable overflow, disable saturation encoding
        self.API.error_assert(success, &#34;Cannot set register 0x0D1A&#34;)

        success, amp_mux_sel = self.API.regreadburst(0x0E1C, 10, &#39;increment&#39;) # save amp_mux_sel register values before overwriting with wave WAVE_FUNCTION_0
        self.API.error_assert(success, &#34;Unable to read original AMP mux sel register values&#34;)

        for k in range(len(amp_mux_sel)):
                self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E1C + k*2)
                self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], amp_mux_sel[k])

        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0234)
        temp = self.API.regread(0x0234) # Read original REG_LP_CTRL register value
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

        success, origSettingWaveFunction0 = self.API.GetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;)
        self.API.error_assert(success, &#39;Unable to read original WAVE_FUNCTION_0 register value&#39;)

        #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
        s = self.API.regwrite(0x0E1C, 0x0200)
        s = self.API.regwrite(0x0E1E, 0x0008)
        s = self.API.regwrite(0x0E20, 0x0200)
        s = self.API.regwrite(0x0E22, 0x0008)
        s = self.API.regwrite(0x0E24, 0x0200)
        s = self.API.regwrite(0x0E26, 0x0008)
        s = self.API.regwrite(0x0E28, 0x0200)
        s = self.API.regwrite(0x0E2A, 0x0008)
        s = self.API.regwrite(0x0E2C, 0x0200)
        s = self.API.regwrite(0x0E2E, 0x0008)
        s = self.API.regwrite(0x0234, 0xFDFF)


        s = self.API.regrmw(0x0E18, 0x0000 , 0x7C20) # &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;     

        self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)

        activeDeSignals = [&#39;amp_clk0&#39;, &#39;amp_clk1&#39;, &#39;cmfb_clk&#39;, &#39;adc_in0&#39;, &#39;adc_in1&#39;,
                                                &#39;adc_capsel&#39;, &#39;adc_rampdir&#39;, &#39;adc_ramppause&#39;, &#39;adc_data_valid&#39;]

        DE_StructOrig = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)
        f = open(os.path.join(self.folderName, &#39;DE_StructOrig.pkl&#39;),&#39;wb&#39;)
        pickle.dump(DE_StructOrig, f)
        f.close()

        DE_Struct = self.API.DumpTimingTransformation(DE_StructOrig, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_2x&#39;)
        DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_2x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest0_dacAmpTest1&#39;)
        DE_Struct = self.API.DumpTimingTransformation(DE_Struct, &#39;native_resolution&#39;,activeDeSignals,&#39;copyToSub_Sampled_4x&#39;)
        DE_Struct = self.API.DumpTimingTransformation(DE_Struct,&#39;sub_sampled_4x&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_Struct)

        # self.API.legacy_ADC_calib_dump_timings() # alternate matlab implementation

        DE_StartEnd = np.zeros([2,2], dtype=np.uint16)
        success, DE_StartEnd[:,0] = self.API.regreadburst(0x0E36, 2,&#39;increment&#39;)
        #DE_StartEnd[:,0] = tmp[0] # returned as a 2d array
        self.API.error_assert(success, &#39;Failed to read native DE values&#39;)
        success, DE_StartEnd[:,1]= self.API.regreadburst(0x0E3C, 2,&#39;increment&#39;)
        #DE_StartEnd[:,1] = tmp[0]
        self.API.error_assert(success, &#39;Failed to read 2x subsampled DE values&#39;)

        h = self.API.height
        w = self.API.width

        img = np.zeros([h ,w ,nFrames, 2],dtype=np.double)
        delta_img = np.zeros([h,w,nFrames,len(iramp)],dtype=np.double)
        mean_delta = np.zeros(len(iramp))

        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E30)
        temp = self.API.regread(0x0E30)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], 0x0E32)
        temp = self.API.regread(0x0E32)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], temp)

        for y in range(len(iramp)-1, -1,-1): # 3 2 1 0
        #for y in range(4): # 3 2 1 0
                success = self.API.regwrite(0x0104, int(iramp[y]))
                self.API.error_assert(success, &#39;Cannot write to reg 0x0104 ADC iramp control&#39;)

                for x in range(1,-1,-1): # 1,0
                        success = self.API.tregwrite(0x0014, 0x0000)
                        self.API.error_assert(success, &#39;Failed to unclock gate DE&#39;) # blindly unclock gate all digital
                        #arr_tmp = self.API.convert2matlabArray(DE_StartEnd[:,x])
                        success = self.API.regwriteburst(0x0E30, DE_StartEnd[:,x], &#39;increment&#39;) 
                        # overwrite &#34;native_resolution&#34; start and end address with either &#34;sub_sampled_2x&#34; or &#34;sub_sampled_4x&#34;
                        self.API.error_assert(success, &#39;Failed to write native DE values&#39;)
                        status, img_tmp = self.API.GetFramesADCCalib(nFrames)
                        self.API.error_assert(status, &#39;Cannot get frames for ADC iramp calibration&#39;)
                        for i in range(nFrames):
                                img[:,:,i,x] = np.bitwise_and(np.array(img_tmp[:,:,i], dtype=np.uint16), 1023) # keep lower 10 bits (ADC data)
                                img[:,:,i,x] = np.double(img[:,:,i,x])
                                tmp = ~np.isnan(img[:,:,i,x])
                                tmp[tmp] = img[:,:,i,x][tmp] &lt; 3 # equivalent of tmp = img &lt; 3
                                img[:,:,i,x][tmp] = np.nan
                                img[0:2,:,i,x] = np.nan # ignore first 2 rows
                                
                delta_img[:,:,:,y] = img[:,:,:,1] - img[:,:,:,0]
                mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                # delta_img[:,:,:,y][delta_img[:,:,:,y] &lt; 0.5*mean_delta[y]] = np.nan
                # mean_delta[y] = np.nanmean(delta_img[:,:,:,y])
                print(&#39;Mean ADC value:&#39;, np.nanmean(delta_img[:,:,:,y]))
                logging.info(&#39;Mean ADC value:&#39; + str(np.nanmean(delta_img[:,:,:,y])))
                print(&#39;Maximum ADC value:&#39;, np.nanmax(delta_img[:,:,:,y]))
                logging.info(&#39;Minimum ADC value:&#39; + str(np.nanmax(delta_img[:,:,:,y])))
                print(&#39;Minimum ADC value:&#39;, np.nanmin(delta_img[:,:,:,y]))
                logging.info(&#39;Maximum ADC value:&#39; + str(np.nanmin(delta_img[:,:,:,y])))


        # status, tetetet = self.API.GetFramesADCCalib(nFrames)
        success = self.API.tregwrite(0x0014, 0x0000) # Work around

        b1 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
        b2 = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0-AMPTEST1&#39;)
        # print(mean_delta)

        # mean_delta = np.array([255.48918137, 231.19768989, 211.06942671, 194.22303369])
        # b1 = 0.475
        # b2 = -0.4735

        Vin_ADC = (b1-b2)*AmpGainMeas
        targetCode = Vin_ADC * (2**(9 + tenBitMode) - 1) / ADC_FS

        if len(iramp) &gt;= 3:
                p = np.polyfit(mean_delta, iramp, 2) # quadratic fit is preferred if we have multiple samples
        else:
                p = np.polyfit(mean_delta, iramp, 1) # else linear fit

        calib_iramp = np.round(np.polyval(p, targetCode),4)

        success = ((calib_iramp &gt;= np.min(iramp)) and (calib_iramp &lt;= np.max(iramp)))
        self.API.error_assert(success, &#39;ADCirampRangeExceeded&#39;)

        success = self.API.regwrite(0x0104, int(calib_iramp))
        print(&#39;Calibrated ADC iramp value:&#39;, calib_iramp)
        logging.info(&#39;Calibrated ADC iramp value:&#39; + str(calib_iramp))

        ############################
        ## ADC offset calibration ##
        ############################

        # Set adc_mux to Vcm
        success = self.API.tregwrite(0x0100, 0x0040, 0x0070)
        self.API.error_assert(success, &#39;Cannot Reg RMW adc_ctrl0_s1&#39;)
        success = self.API.tregwrite(0x0192, 0x0000, 0x0380) # bit[9] is inverted on camera C0 compared to B0 (adc_muxn_inb[2])
        self.API.error_assert(success, &#39;Cannot Reg RMW ana_serial_spare_2&#39;)

        # Read the default delays
        adc_delay = self.API.regread(0x0102) # ADC delay
        # self.API.error_assert(s, &#39;Cannot read reg 0x0102 - adc_delay&#39;)
        adc_delay = self.ADC_Delay_LFSR(adc_delay, reverse=True) # convert register LFSR to linear value

        status, VcmImg_pre = self.API.GetFramesADCCalib(nFrames)
        self.API.error_assert(status, &#39;Cannot grab frames for ADC offset calibration&#39;)

        # Extract 10 ADC bits
        VcmImg = VcmImg_pre
        VcmImg = np.array(VcmImg, dtype=np.double) % 1024 # keep lower 10 bits (ADC data)
        VcmImg[VcmImg &lt; 3] = np.nan

        # plt.figure()
        # plt.imshow(VcmImg[800:1024,800:1024])
        # plt.title(&#39;VcmImg[800:1024,800:1024]&#39;)
        # plt.xlabel(&#39;Imager columns&#39;)
        # plt.ylabel(&#39;Imager rows&#39;)
        # plt.colorbar(label=&#39;ADC offset&#39;)
        # plt.show()

        # plt.plot(VcmImg[800:1024,933,:])
        # plt.title(&#39;VcmImg[900:1024,933]&#39;)
        # plt.show()

        # plt.plot(VcmImg[933,800:1024,:])
        # plt.title(&#39;VcmImg[933,900:1024]&#39;)
        # plt.show()


        # Compute new ADC delay value
        targetCenterVal = 2**(8 + tenBitMode) + 1
        targetCenterVal = targetCenterVal + (6 * 2**tenBitMode)

        adc_delay = np.nanmean(VcmImg) + adc_delay - targetCenterVal

        success = (adc_delay &gt;= 3) and (adc_delay &lt;= 511)
        self.API.error_assert(success, &#39;Calibrated linear ADC offset counter value is out of range [3, 511]&#39;)
        print(&#39;Calibrated ADC delay (linear value):&#39;, adc_delay)
        logging.info(&#39;Calibrated ADC delay (linear value):&#39; + str(adc_delay))
        self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = adc_delay


        adc_delay = self.ADC_Delay_LFSR(np.round(adc_delay))

        success = self.API.regwrite(0x0102, int(adc_delay))
        print(&#39;Calibrated ADC up/dn delay control:&#39;, adc_delay)
        logging.info(&#39;Calibrated ADC up/dn delay control:&#39; + str(adc_delay))

        success = success and self.API.regwrite(0x0014, 0x0000)
        if cleanup:
                self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, DE_StructOrig)
                #success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, origSettingWaveFunction0)
                s = self.API.regwrite(0x0E1C, 0x0200)
                s = self.API.regwrite(0x0E1E, 0x0008)
                s = self.API.regwrite(0x0E20, 0x0200)
                s = self.API.regwrite(0x0E22, 0x0008)
                s = self.API.regwrite(0x0E24, 0x0200)
                s = self.API.regwrite(0x0E26, 0x0008)
                s = self.API.regwrite(0x0E28, 0x0200)
                s = self.API.regwrite(0x0E2A, 0x0008)
                s = self.API.regwrite(0x0E2C, 0x0200)
                s = self.API.regwrite(0x0E2E, 0x0008)
                s = self.API.regwrite(0x0234, 0xFDFF)

                #self.API.error_assert(success, &#39;Cannot restore WAVE_FUNCTION_0 register&#39;)
                self.API.WriteOrigSettings()
                status = self.API.UpdateUseCaseFrameSetting(ADC_dict[&#39;sensormodeID&#39;], &#39;DRAINSTYLE&#39;, origDrainStyleVal)
                self.API.error_assert(status, &#39;Unable to reset drainstyle&#39;)
                #success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;sensor_mode&#39;][&#39;set&#39;], origSensorMode)
                self.API.error_assert(success, &#39;Cannot set original sensor mode&#39;)

                #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], origDAC_AMPTEST0)
                success = self.API.dac_amptest0_set(np.uint8(origDAC_AMPTEST0))
                self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST0&#39;)
                #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], origDAC_AMPTEST1)
                success = self.API.dac_amptest1_set(np.uint8(origDAC_AMPTEST1))
                self.API.error_assert(success, &#39;Cannot set original DAC_AMPTEST1&#39;)
                #success = success and self.API.N_APIComm(1, self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], origDAC_CMREF)
                success = self.API.dac_cmref_set(origDAC_CMREF)
                self.API.error_assert(success, &#39;Cannot set original DAC_CMREF&#39;)



        return calib_iramp, adc_delay</code></pre>
</details>
</dd>
<dt id="GO_functions.GainOffset.ADC_Delay_LFSR"><code class="name flex">
<span>def <span class="ident">ADC_Delay_LFSR</span></span>(<span>self, inputVal, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate ADC delay decimal value to 9-bit LFSR seed value based on LFSR polynomial: x9 + x5 + 1
Also supports reverse lookup (to convert LFSR to decimal) </p>
<p>Inputs:
inputVal
- input value
reverse (optional) - if true, reverse lookup. i.e. inputVal is a LFSR value and
outputVal is the corresponding decimal value
Outputs:
outputVal
- output value.
</p>
<p>Note: outVal is returned empty if inputVal is invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ADC_Delay_LFSR(self, inputVal, reverse=False):
        &#39;&#39;&#39;
        Translate ADC delay decimal value to 9-bit LFSR seed value based on LFSR polynomial: x9 + x5 + 1
        Also supports reverse lookup (to convert LFSR to decimal) 
        
        Inputs: 
          inputVal           - input value 
          reverse (optional) - if true, reverse lookup. i.e. inputVal is a LFSR value and
                               outputVal is the corresponding decimal value 
        Outputs: 
          outputVal             - output value.  
        
        Note: outVal is returned empty if inputVal is invalid. 
        &#39;&#39;&#39;
        # Generate table
        lfsrSeq9 = np.zeros(2**9 - 1, dtype=np.uint16)
        mask = int(&#39;0x01FE&#39;, 0)
        for i in range(2**9 - 2):
                curVal = lfsrSeq9[i]
                bit0Val = not((self.API.bitget(curVal, 3))^(self.API.bitget(curVal, 8))) # a ^ b is a XOR b in python
                newVal = (curVal &lt;&lt; 1) &amp; mask
                lfsrSeq9[i+1] = ((newVal &gt;&gt; 1) &lt;&lt; 1) + bit0Val # equivalent of bitset(newVal, 1, bit1Val)

        # ADC counter adds an additional 2 cycle offset that is compensated for in
        # the lookup here.  Additionally, a LFSR value of zero is invalid in the
        # design

        if not(reverse):
                if (inputVal &lt; 3) or (inputVal &gt; 512):
                        raise Exception(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                        logging.error(&#39;Linear adc_delay value is outside valid range [3-512]&#39;)
                else:
                        outputVal = lfsrSeq9[int(inputVal - 2)] # ADC counter design has an offset of 2, but python indexes start at 0

        else:
                if (inputVal == 0):
                        raise Exception(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                        logging.error(&#39;An adc_delay LFSR value of 0 is invalid in the chip design&#39;)
                else:
                        try:
                                outputVal = list(lfsrSeq9).index(inputVal) + 2
                        except:
                                raise Exception(&#39;Invalid 9b adc_delay LFSR value specified:&#39;, inputVal)
                                logging.error(&#39;Invalid 9b adc_delay LFSR value specified: &#39; + str(inputVal))

        return outputVal</code></pre>
</details>
</dd>
<dt id="GO_functions.GainOffset.ComparatorDACCal"><code class="name flex">
<span>def <span class="ident">ComparatorDACCal</span></span>(<span>self, compDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs Comparator DAC calibration. Requires ADC calibration to be done
prior. </p>
<p>Inputs:
compDict
- input dictionary. </p>
<p>Outputs:
compDAC
- array of calibrated comparator DAC values.
info
- dictionary containing information regarding
the calibration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ComparatorDACCal(self, compDict):
        &#39;&#39;&#39;
        Performs Comparator DAC calibration. Requires ADC calibration to be done
        prior. 
        
        Inputs: 
          compDict              - input dictionary. 
          
        Outputs: 
          compDAC               - array of calibrated comparator DAC values. 
          info                  - dictionary containing information regarding
                                  the calibration 
        
        &#39;&#39;&#39;


        self.API.testBoardADC()
        s = self.API.regwrite(0x0014,0x0000)
        print(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
        logging.info(&#34;\n-------Comparator DAC Calibration-------\n&#34;)
        NFRAMES = compDict[&#39;NFRAMES&#39;]
        doplot = compDict[&#39;doplot&#39;]
        compCalThres = compDict[&#39;compCalThres&#39;]
        compCalSatLimit = compDict[&#39;compCalSatLimit&#39;]
        compCalMargin = compDict[&#39;compCalMargin&#39;]

        #self.API.regwrite(0x012E,0x0406)
        #self.API.regwrite(0x0130,0x1F0D)
        self.API.regwrite(0x012E,0x0404)
        self.API.regwrite(0x0130,0x1F0C)
        #self.API.regwrite(0x012E,0x050A)
        #self.API.regwrite(0x0130, 0x1F0F)
        #self.API.regwrite(0x0130, 0x1F0F)
        # self.API.regwrite(0x012E,0x1F1F) # Work around, having a high value will result in saturation -&gt; 0204

        sensormodeID = 3 # Use PCM 
        ADC_FS = 1 # ADC full scale = +/- 1.00V
        DACSweepFineResolution = [5e-3, 5e-3, 10e-3] # Fine target resolution DAC sweep = 5mV for two higher gains, 10mV for lowest gain
        DACSweepCoarseResolution = [10e-3, 10e-3, 20e-3] # Coarse resolution DAC sweep = 10mV for two higher gains, 20mV for lowest gain
        ampgain = self.API.ReadAmpGainSetting() # estimate for expected amp gains

        print(&#39;ampgain:&#39;, ampgain)
        logging.info(&#39;ampgain:&#39; + str(ampgain))

        val = self.API.regread(0x0D1A) # determine if we are using 9b or 10b data
        #       self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)
        tenBitMode = bool(not self.API.bitget(int(val),3))

        compDacOrig = np.zeros(3, dtype=&#39;int&#39;)

        val = self.API.regread(0x012E)

        #       self.API.error_assert(success, &#39;Failed to read comparator DAC register&#39;)
        compDacOrig[0] = int(val) &amp; int(&#39;0x00FF&#39;, 0)
        compDacOrig[1] = (int(val) &amp; int(&#39;0xFF00&#39;, 0)) &gt;&gt; 8
        val = self.API.regread(0x0130)
        #       self.API.error_assert(success, &#39;Failed to read DAC register&#39;)
        compDacOrig[2] = int(val) &amp; int(&#39;0x00FF&#39;, 0)

        # 1-&gt;Raw output (Direct copy from frame buffer, linear ADC + GT)
        status = self.API.UpdateUseCaseFrameSetting(sensormodeID, &#39;DRAINSTYLE&#39;, 1)

        self.API.error_assert(status, &#39;Unable to set drain style&#39;)
        s = self.API.regwrite(0x0014, 0x0000)
        # success = self.API.SetIndirectRegister(&#39;WAVE_FUNCTION_0&#39;, 25)
        # self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
        s = self.API.regwrite(0x0E1C, 0x0200)
        s = self.API.regwrite(0x0E1E, 0x0008)
        s = self.API.regwrite(0x0E20, 0x0200)
        s = self.API.regwrite(0x0E22, 0x0008)
        s = self.API.regwrite(0x0E24, 0x0200)
        s = self.API.regwrite(0x0E26, 0x0008)
        s = self.API.regwrite(0x0E28, 0x0200)
        s = self.API.regwrite(0x0E2A, 0x0008)
        s = self.API.regwrite(0x0E2C, 0x0200)
        s = self.API.regwrite(0x0E2E, 0x0008)
        s = self.API.regwrite(0x0234, 0xFDFF)


        success = self.API.regrmw(0x012A, 0x0000, 0x7E00 ) # clear comp_ref_disable[5:0] to enable multigain
        self.API.error_assert(success, &#39;Failed to enable all gain comparators&#39;)


        DE_Struct = self.API.DumpTimingTool(&#39;ReadfromChip&#39;)

        DacCal = dict()
        CMwindow = [2.10, 2.15] # Define the Common Mode range of the DACs (post source follower) for both the &#34;reset&#34; and &#34;integrate&#34; samples
        DacSel = [&#39;CMREF-AMPTEST0&#39;,&#39;CMREF-AMPTEST0&#39;,&#39;AMPTEST1-AMPTEST0&#39;] # Define which pair of DACs to use for each of the 3 gain comparators
        # CMREF-AMPTEST0 provides more resolution (since CMREF step size is smaller), while AMPTEST1-AMPTEST0 provides more range
        forceCompDac = [0x2800, 0x2400, 0x1400]

        dacDiffVoltagePost = np.ones([2,3]) * np.nan
        dacDiffVoltagePre = np.ones([2,3]) * np.nan # variable to store pre/post transition voltages. dimensions [positive/negative comparator, gain comparator 0-2]

        # initial guess for comparator voltage is 90% of expected ADC full scale
        # quantized to target sweep resolution
        dacDiffVoltagePost[0,:] = np.round(0.9*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

        # define an upper limit of 120% of expected ADC full scale
        dacDiffVoltageLimit = np.ceil(1.2*ADC_FS/ampgain[0:3]/DACSweepFineResolution) * DACSweepFineResolution

        GT_pos = np.zeros(3,dtype=object)
        ADC_pos = np.zeros(3,dtype=object)
        SAT_pos = np.zeros(3,dtype=object)
        GT_neg = np.zeros(3,dtype=object)
        ADC_neg = np.zeros(3,dtype=object)
        SAT_neg = np.zeros(3,dtype=object)


        for gainTransition in range(2, -1,-1): # 2,1,0
                success = self.API.regrmw(0x012A, forceCompDac[gainTransition], 0x7E00)
                self.API.error_assert(success,&#39;Unable to disable comparators that are not currently under test&#39;)

                ## Testing positive comparator

                print(&#39;\n---Gain&#39;, gainTransition, &#39;---&#39;)
                logging.info(&#39;\n---Gain &#39; + str(gainTransition) + &#39; ---&#39;)
                print(&#39;\nTesting positive comparator\n&#39;)
                logging.info(&#39;\nTesting positive comparator\n&#39;)
                if DacSel[gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                        tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                elif DacSel[gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:
                        tmp = self.API.DumpTimingTransformation(DE_Struct,&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp)
                else:
                        raise Exception(&#34;Incorrect DacSel value&#34;)
                        logging.error(&#39;Incorrect DacSel value&#39;)
                
                print(&#34;Setting&#34;, DacSel[gainTransition], &#34;to target: &#34;, str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)
                logging.info(&#34;Setting &#34; + str(DacSel[gainTransition]) + &#34; to target: &#34; + str(dacDiffVoltagePost[0,gainTransition]*1e3) + &#34;mV&#34;)


                DacCal, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)


                # print(DacCal[&#39;RangeCMREF&#39;], DacCal[&#39;RangeAMPTEST0&#39;], DacCal[&#39;RangeAMPTEST1&#39;])
                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                          %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                          %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                
                # while any(vec(GT_tmp)&lt;gainTransition)  --&gt; while not all pixels transitioned to the desired gain setting, increase voltage
                while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):

                        print(&#39;Coarse search l1 any&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1)), &#39;&lt; Thresh&#39;, compCalThres)

                        GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                        ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                        SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                        dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePost[0, gainTransition]

                        dacDiffVoltagePost[0, gainTransition] = dacDiffVoltagePost[0,gainTransition] + DACSweepCoarseResolution[gainTransition] # increase voltage by DACSweepCoarseResolution
                        dacDiffVoltagePost[0, gainTransition] = (np.round(dacDiffVoltagePost[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                        success = np.abs(dacDiffVoltagePost[0,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                        self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)

                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[0,gainTransition],CMwindow)
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
                
                if np.isnan(dacDiffVoltagePre[0,gainTransition]): # we only found high value, so need to search for an inital low value
                        dacDiffVoltagePre[0,gainTransition] = dacDiffVoltagePost[0,gainTransition]
                        while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):

                                print(&#39;Coarse search l1 nan all&#39;, np.min(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)), &#39;&gt;= Thresh&#39;, compCalThres)

                                dacDiffVoltagePost[0,gainTransition] = dacDiffVoltagePre[0,gainTransition]
                                dacDiffVoltagePre[0, gainTransition] = dacDiffVoltagePre[0,gainTransition] - DACSweepCoarseResolution[gainTransition] # decrease voltage by DACSweepCoarseResolution
                                dacDiffVoltagePre[0, gainTransition] = (np.round(dacDiffVoltagePre[0, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[0,gainTransition],CMwindow)
                                
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                        ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                        SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                # Binary fine search
                while(np.round(np.abs(dacDiffVoltagePost[0,gainTransition] - dacDiffVoltagePre[0,gainTransition]) / DACSweepFineResolution[gainTransition]) &gt; 1):
                        # perform fine search (&#39;round&#39; required to prevent rounding errors in subtraction)
                        dacDiffVoltageTest = np.mean([dacDiffVoltagePost[0,gainTransition],dacDiffVoltagePre[0,gainTransition]])
                        dacDiffVoltageTest = np.round(dacDiffVoltageTest / DACSweepFineResolution[gainTransition]) * DACSweepFineResolution[gainTransition]

                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltageTest*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltageTest,CMwindow)

                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        if (np.any(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &lt; compCalThres))):
                                GT_pos[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                                ADC_pos[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                                SAT_pos[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                                dacDiffVoltagePre[0,gainTransition] = dacDiffVoltageTest
                        else:
                                dacDiffVoltagePost[0,gainTransition] = dacDiffVoltageTest

                ## Find transition point for negative comparator
                print(&#39;\nTesting negative comparator\n&#39;)
                logging.info(&#39;\nTesting negative comparator\n&#39;)
                dacDiffVoltagePost[1, gainTransition] = -1* dacDiffVoltagePost[0, gainTransition]
                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                          %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                          %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))
        
                while(np.any(np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(ADC_tmp))[1], -1)),1) / (gainTransition+1) &lt; compCalThres)):
                        GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1]) # store previous measurement at pre-transition voltage
                        ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                        SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])
                        dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePost[1, gainTransition]

                        dacDiffVoltagePost[1, gainTransition] = dacDiffVoltagePost[1,gainTransition] - DACSweepFineResolution[gainTransition] 
                        # decrease voltage by DACSweepFineResolution (using fine search only since it should be similar to positive DAC)
                        dacDiffVoltagePost[1, gainTransition] = (np.round(dacDiffVoltagePost[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                        *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution

                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePost[1,gainTransition],CMwindow)
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)

                        gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                if (np.isnan(dacDiffVoltagePre[1,gainTransition])):
                        dacDiffVoltagePre[1,gainTransition] = dacDiffVoltagePost[1,gainTransition] + DACSweepFineResolution[gainTransition] 
                        # increase voltage by DACSweepFineResolution
                        success = np.abs(dacDiffVoltagePost[1,gainTransition]) &lt; dacDiffVoltageLimit[gainTransition]
                        self.API.error_assert(success, &#39;comparator DAC voltage exceeded&#39;)
                        print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                        GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                        ainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                        print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                        logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        while(np.all(((np.mean(np.reshape(GT_tmp.transpose(1,0,2,3), [np.shape(ADC_tmp)[1], -1]),1) / (gainTransition +1)) &gt;= compCalThres))):
                                dacDiffVoltagePost[1,gainTransition] = dacDiffVoltagePre[1,gainTransition] # store previous measurement as pre-transition voltage 
                                dacDiffVoltagePre[1, gainTransition] = dacDiffVoltagePre[1,gainTransition] + DACSweepFineResolution[gainTransition] # increase voltage by DACSweepFIneResolution
                                dacDiffVoltagePre[1, gainTransition] = (np.round(dacDiffVoltagePre[1, gainTransition] / DACSweepFineResolution[gainTransition])
                                                                                                                *DACSweepFineResolution[gainTransition]) # quantize to target sweep resolution
                                
                                print(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3))
                                logging.info(str(&#39;Setting %18s to target: %3.0fmV&#39; %(DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition]*1e3)))
                                _, _, _ = self.API.SetDiffDacSfVoltage(DacCal,DacSel[gainTransition],dacDiffVoltagePre[1,gainTransition],CMwindow)
                                
                                GT_tmp, ADC_tmp, SAT_tmp = self.API.GetFramesCompDACalib(NFRAMES)
                                gainTagTransitionPercentPerCol = np.sum(np.reshape(GT_tmp.transpose(1,0,2,3), (list(np.shape(GT_tmp))[1], -1))==(gainTransition+1),1) / list(np.shape(GT_tmp))[0] * 100
                                print(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol)))
                                logging.info(str(&#39;Gain tag measured over entire sensor: %8.4f (column highest: %6.2f, column lowest: %6.2f)&#39; 
                                        %(np.sum(GT_tmp.flatten() == (gainTransition+1))/np.size(GT_tmp)*100, np.max(gainTagTransitionPercentPerCol), np.min(gainTagTransitionPercentPerCol))))

                        GT_neg[gainTransition] = np.reshape(np.transpose(GT_tmp,[1,0,2,3]),[np.shape(GT_tmp)[1],-1])
                        ADC_neg[gainTransition] = np.reshape(np.transpose(ADC_tmp,[1,0,2,3]),[np.shape(ADC_tmp)[1],-1])
                        SAT_neg[gainTransition] = np.reshape(np.transpose(SAT_tmp,[1,0,2,3]),[np.shape(SAT_tmp,)[1],-1])

                # print(dacDiffVoltagePre)
                # print(dacDiffVoltagePost)
        success = self.API.regrmw(0x012A, 0x0000, 0x7E00)
        self.API.error_assert(success, &#39;Unable to enable comparators for normal operation&#39;)

        f = open(os.path.join(self.folderName, &#39;DacCalibration.pkl&#39;),&#39;wb&#39;)
        pickle.dump(DacCal,f)
        f.close()


        maxADCperCol = np.zeros([3, np.shape(ADC_pos[0])[0]])
        minADCperCol = np.zeros([3, np.shape(ADC_neg[0])[0]])
        sum_SAT_pos = np.zeros([3, np.shape(SAT_pos[0])[0]])
        sum_SAT_neg = np.zeros([3, np.shape(SAT_neg[0])[0]])


        for i in range(3):
                maxADCperCol[i] = np.max(ADC_pos[i], axis = 1)
                minADCperCol[i] = np.min(ADC_neg[i], axis = 1)
                sum_SAT_pos[i] = np.sum(SAT_pos[i], axis = 1)
                sum_SAT_neg[i] = np.sum(SAT_neg[i], axis = 1)

        anySaturationDetected = np.any(np.append(sum_SAT_pos, sum_SAT_neg, axis=1), axis=1)

        if np.any(anySaturationDetected):
                if doplot:
                        plt.figure()
                        for i in range(3):
                                plt.plot(range(0,1024), sum_SAT_pos[i] / np.shape(SAT_pos[i])[1], label = &#39;(+) Gain &#39;+ str(i))
                                plt.plot(range(0,1024), sum_SAT_neg[i] / np.shape(SAT_neg[i])[1], label = &#39;(-) Gain &#39;+ str(i))
                        plt.legend()
                        plt.xlabel(&#39;Pixel col (0-1023)&#39;)
                        plt.savefig(os.path.join(self.folderName, &#39;ComparatorSaturation.png&#39;))

                mean_divisor = np.shape(SAT_pos[i])[1]
                perColSaturation = np.max(np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor]), axis = 2)
                numColsExceedSatLimit = np.sum(perColSaturation &gt; compCalSatLimit, axis = 1)
                if np.any(numColsExceedSatLimit):
                        plt.savefig(os.path.join(self.folderName, &#39;Saturation.png&#39;))
                        self.API.error_assert(False,&#39;Saturation limit exceeded for comparator DAC calibration&#39;)
                else:
                        print(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)
                        logging.warning(&#39;\nWARNING! : Saturation detected but below limt\n&#39;)


        MinMaxADCValueperCol = dict()
        MinMaxADCValueperCol[&#39;maxADCperCol&#39;] = maxADCperCol
        MinMaxADCValueperCol[&#39;minADCperCol&#39;] = minADCperCol
        f = open(os.path.join(self.folderName, &#39;MinMaxADCValueperCol.pkl&#39;), &#39;wb&#39;)
        pickle.dump(MinMaxADCValueperCol, f)
        f.close()

        measADCmargin = np.array([np.min(minADCperCol,1) - 3, 2**(9+tenBitMode)-1 - np.max(maxADCperCol,1)]) / (2**(8+tenBitMode))
        measADCmargin = np.min(measADCmargin, axis = 0)
        measADCmargin[anySaturationDetected] = 0

        print(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1)))
        logging.info(str(&#39;Comp cal: Min ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.min(minADCperCol, axis = 1))))
        print(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1)))
        logging.info(str(&#39;Comp cal: Max ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f&#39; %tuple(np.max(maxADCperCol, axis = 1))))

        # Measure the slope of each comparator DAC.  TODO: Characterize compDac_mVperLSB over a number of units and
        # replace with a hardcoded value instead of measuring each camera chip individually
        # self.API.testBoardADC()
        dacLow = 0
        dacHigh = 63
        numVoltageSamples = 1

        v = np.zeros(2)
        compDac_mVperLSB = np.zeros(3)

        success = self.API.regrmw(0x012E, dacLow, 0x00FF)
        v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
        count = 10
        while((abs(v[0]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                time.sleep(1)
                v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = count -1
        success = success and self.API.regrmw(0x012E, dacHigh , 0x00FF)
        v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
        count = 10
        while((abs(v[1]) &lt; 0.01) and (abs(v[0]) &gt; 3.00) and count &gt; 1):
                time.sleep(1)
                v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;,numVoltageSamples)
                count = count -1
        compDac_mVperLSB[0] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

        success = success and self.API.regrmw(0x012E, dacLow*256, 0xFF00)
        v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
        success = success and self.API.regrmw(0x012E, dacHigh*256, 0xFF00)
        v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;,numVoltageSamples)
        compDac_mVperLSB[1] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3

        success = success and self.API.regrmw(0x0130, dacLow, 0x00FF)
        v[0] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
        success = success and self.API.regrmw(0x0130, dacHigh, 0x00FF)
        v[1] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;,numVoltageSamples)
        compDac_mVperLSB[2] = (v[1]-v[0]) / (dacHigh-dacLow) * 1e3               # Measured mV/DAC code
        self.API.error_assert(success, &#39;Failed to measure comparator DAC voltages&#39;)

        estimatedADCperCompDACLSB = compDac_mVperLSB * 1e-3 * ampgain[0:3] / ADC_FS # estimate (normalized) ADC change per LSB of comparator DAC change

        compDacAdjusted = compDacOrig + np.floor((measADCmargin - np.array(compCalMargin)) / estimatedADCperCompDACLSB)

        compDac = np.clip(compDacAdjusted,0,63)

        if np.any(compDac != compDacAdjusted):
                print(&#39;WARNING: Comparator DAC clamped!&#39;)

        success = self.API.regwrite(0x012E, np.uint16(compDac[1]*256+compDac[0]))
        success = success and self.API.regrmw(0x0130, int(compDac[2]) , 0x003F)
        self.API.error_assert(success, &#39;Failed to write comparator DAC settings to chip&#39;)

        print(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0]))
        logging.info(str(&#39;comp_ref_dac1: %.0f&#39; %(compDac[0])))
        print(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1]))
        logging.info(str(&#39;comp_ref_dac2: %.0f&#39; %(compDac[1])))
        print(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2]))
        logging.info(str(&#39;comp_ref_dac3: %.0f&#39; %(compDac[2])))

        info = dict()
        info[&#39;compDacOrig&#39;] = compDacOrig
        info[&#39;compCalSaturationDetected&#39;] = anySaturationDetected
        info[&#39;DacClamped&#39;] = compDac != compDacAdjusted
        info[&#39;dacDiffVoltageTargetPre&#39;] = dacDiffVoltagePre
        info[&#39;DE_Struct&#39;] = DE_Struct
        info[&#39;DacCal&#39;] = DacCal
        info[&#39;DacSel&#39;] = DacSel
        info[&#39;CMwindow&#39;] = CMwindow
        info[&#39;compMinADC&#39;] = np.min(minADCperCol,axis=1)
        info[&#39;compMaxADC&#39;] = np.max(maxADCperCol,axis=1)

        info[&#39;voltage_comp_vref1&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref0&#39;) * 1000 #in mV
        info[&#39;voltage_comp_vref2&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref1&#39;) * 1000 #in mV
        info[&#39;voltage_comp_vref3&#39;] = self.API.CamMeasureAnaTestVoltage(&#39;comp_vref2&#39;) * 1000 #in mV
        mean_divisor = float(np.shape(SAT_pos[i])[1])
        info[&#39;compCalSatPerGainPerColPerPosNeg&#39;] = np.transpose([sum_SAT_pos/mean_divisor, sum_SAT_neg/mean_divisor], (1,2,0))
        # number of saturated pixels. Dimensions: [gain transition, column, positive/negative comparator]

        return compDac, info</code></pre>
</details>
</dd>
<dt id="GO_functions.GainOffset.ConfigureChip"><code class="name flex">
<span>def <span class="ident">ConfigureChip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the camera before per-column-Gain and Offset calibration.
Performs ADC calibration and CompDAC calibration. </p>
<p>Inputs:<br>
None
</p>
<p>Outputs:<br>
True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConfigureChip(self):
        &#39;&#39;&#39;
        Configures the camera before per-column-Gain and Offset calibration. 
        Performs ADC calibration and CompDAC calibration. 
        
        Inputs:  
          None  
           
        Outputs:  
          True  
        
        &#39;&#39;&#39;
        val = self.API.regread(274)
        success= val == 22833
        self.API.error_assert(success, &#34;Cannot communicate with chip&#34;)

        # ## TODO confirm chip  info
        # status, cfgver = self.API.N_APIComm(2, self.API.API[&#39;IO&#39;][&#39;config_version&#39;][&#39;get&#39;])
        # self.API.error_assert(status, &#34;Cannot get Config version&#34;)

        val = self.API.regread(0x0528)
        # self.API.error_assert(status, &#34;Cannot determine if multigain settings have already been applied&#34;)

        if (int(val)&amp;6) == 6:
                print(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
                logging.info(&#39;\n\nMulti-gain calibration is already applied\n\n&#39;)
        else:
                success = self.API.regrmw(0x0528, 0x0FFFF, 0x0006)

        success = success and self.API.regwrite(0x0014, 0x0000) # blindly unclock gate all digital
        success = success and self.API.regwrite(0x0500, 0x1002) # Configure read from LX5 DRAM          
        success = success and self.API.regwrite(0x0502, 0x0006) 
        s, val = self.API.regreadburst(0x0506, 5)
        self.cal_dict[&#39;gainCalConfigVersion&#39;] = int(val[4])

        val = self.API.regread(0x0D1A)
        # self.API.error_assert(success, &#34;Failed to determine 9b/10b mode&#34;)

        self.tenBitMode = bool(not self.API.bitget(int(val),3)) # get bit in 3rd position from LSB (4 in MATLAB)
        self.cal_dict[&#39;ADC&#39;] = dict()


        ADC_dict = dict(
                                        sensormodeID = self.ADC_cal_settings[&#39;sensormodeID&#39;], # PCM
                                        nFrames = self.ADC_cal_settings[&#39;nFrames&#39;],
                                        DAC_AMPTEST0 = self.ADC_cal_settings[&#39;DAC_AMPTEST0&#39;], # ~1.61V
                                        DAC_AMPTEST1 = self.ADC_cal_settings[&#39;DAC_AMPTEST1&#39;], # ~2.05V
                                        iramp = self.ADC_cal_settings[&#39;iramp&#39;],
                                        ADC_FS = self.ADC_cal_settings[&#39;ADC_FS&#39;], # ADC Full Scale = 2Vpp
                                        Cin = self.ADC_cal_settings[&#39;Cin&#39;], # Ampgain setting of 0.99x
                                        Cfb = self.ADC_cal_settings[&#39;Cfb&#39;],
                                        AmpGainMeas = self.ADC_cal_settings[&#39;AmpGainMeas&#39;], # actual amp gain (measured using two single ended probes)
                                        cleanup = self.ADC_cal_settings[&#39;cleanup&#39;] # cleanup after calibration, i,e restore original settings
                                        )

        #Comp_DAC_cal_settings  =file[&#39;Comp_DAC_calibration&#39;]

        compDict = dict(
                                        NFRAMES = self.Comp_DAC_cal_settings[&#39;NFRAMES&#39;], # number of frames to collect per DAC step
                                        doplot = self.Comp_DAC_cal_settings[&#39;doplot&#39;], # flag to generate plots and intermediate outputs
                                        compCalThres = self.Comp_DAC_cal_settings[&#39;compCalThres&#39;], # Threshold for number of comparator samples per column that must have transitioned to the next gain (default if not specified is 99.5%)
                                        compCalSatLimit = self.Comp_DAC_cal_settings[&#39;compCalSatLimit&#39;], # Fail gain calibration if more than compCalSatLimit pixels are saturated within any column at the original comparator DAC setting (default if not specified is 2 pixels per column)
                                        compCalMargin = self.Comp_DAC_cal_settings[&#39;compCalMargin&#39;] # Required margin from max/min ADC value.  This margin is used when adjusting comparator DAC after finding the existing switching point (default if not specified is 5% of full scale)
                                        )

        # Calibrate ADC ramp and up/dn counters
        self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;] = self.ADCCalib(ADC_dict)
        print(&#39;ADC Calibration values: \nADC iramp: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;], &#39;\nADC updnoffset: &#39;, self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])
        logging.info(&#39;ADC Calibration values: \nADC iramp: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;]) + &#39;\nADC updnoffset: &#39; + str(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;]))


        # Calibrate gain comparators
        compDac, self.info = self.ComparatorDACCal(compDict)

        self.cal_dict[&#39;gainComparator&#39;] = dict()
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;] = compDac[0]
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;] = not np.isnan(compDac[0])
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;] = compDac[1]
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;] = not np.isnan(compDac[1])
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;] = compDac[2]
        self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;] = not np.isnan(compDac[2])
        if len(compDac) &gt; 3:
                self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;] = compDac[2]
                self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = not np.isnan(compDac[2])
        else:
                self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;] = False

        print(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
        logging.info(&#39;\nSAVING INTERMEDIATE FILES...\n&#39;)
        f = open(os.path.join(self.folderName, &#39;GO_cal_dict_intermediate.pkl&#39;), &#39;wb&#39;)
        pickle.dump(self.cal_dict, f)
        f.close()

        f = open(os.path.join(self.folderName, &#39;GO_info_intermediate.pkl&#39;), &#39;wb&#39;)
        pickle.dump(self.info, f)
        f.close()

        return True</code></pre>
</details>
</dd>
<dt id="GO_functions.GainOffset.PerColGOCalib"><code class="name flex">
<span>def <span class="ident">PerColGOCalib</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs Per column Gain and Offset calibration and generates gain and offset
table. </p>
<p>Inputs:
None </p>
<p>Outputs:
cal_dict
- Dictionary containing calibrated values
info
- Dictionary containing calibration info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerColGOCalib(self):
        &#39;&#39;&#39;
        Performs Per column Gain and Offset calibration and generates gain and offset
        table. 
        
        Inputs: 
          None 
          
        Outputs: 
          cal_dict              - Dictionary containing calibrated values 
          info                  - Dictionary containing calibration info 
        
        &#39;&#39;&#39;

        cal_dict = self.cal_dict
        info = self.info

        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])

        print(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)
        logging.info(&#34;\n-------Per-column Gain and Offset Calibration-------&#34;)

        tmp = info[&#39;dacDiffVoltageTargetPre&#39;]
        tmp = np.append(tmp, np.reshape(tmp[:,2],(len(tmp[:,2]),1)), axis=1)
        info[&#39;dacDiffVoltageTargetPre&#39;] = tmp # Use 3rd gain transition voltage to calibrate 4th gain
        info[&#39;DacSel&#39;] = np.append(info[&#39;DacSel&#39;], info[&#39;DacSel&#39;][2])
        info[&#39;normalizedSatPerCol&#39;] = 0

        forceSingleGain = [0x2A00, 0x2C00, 0x3400, 0x5400]
        dumpTimingLastState = &#39;&#39;
        info[&#39;gainCalVoltageDiff&#39;] = np.zeros([4,2])

        NFRAMES = self.GO_settings[&#39;NFRAMES&#39;]
        compCalSatLimit = self.GO_settings[&#39;compCalSatLimit&#39;]
        ADC_FS = self.GO_settings[&#39;ADC_FS&#39;]
        doplot = self.GO_settings[&#39;doplot&#39;]

        ta, tb, SAT_test = self.API.GetFramesPCGO(NFRAMES) #
        ADC_Native = np.zeros(np.append(np.shape(SAT_test), (4,2)))


        s=self.API.regwrite(0x0014,0x0000)


        for gainTransition in range(3,-1,-1):
                for posNeg in range(1,-1,-1):
                        print(&#39;\n--- Gain&#39;, gainTransition, &#39;---&#39;)
                        logging.info(&#39;\n--- Gain&#39; + str(gainTransition) + &#39;---&#39;)
                        print(&#39;Setting %17s to target: %3.0fmV&#39;
                                %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3))
                        logging.info(str(&#39;Setting %17s to target: %3.0fmV&#39;
                                %(info[&#39;DacSel&#39;][gainTransition],info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition]*1e3)))
                        _, _, _ = self.API.SetDiffDacSfVoltage(info[&#39;DacCal&#39;],info[&#39;DacSel&#39;][gainTransition],
                                                                                                info[&#39;dacDiffVoltageTargetPre&#39;][posNeg,gainTransition],info[&#39;CMwindow&#39;])
                        success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                        self.API.error_assert(success, &#39;Failed to force single gain&#39;)

                        if info[&#39;DacSel&#39;][gainTransition].upper() == &#39;CMREF-AMPTEST0&#39;:
                                
                                if dumpTimingLastState != &#39;CMREF-AMPTEST0&#39;: # configure DE timing to use DAC inputs for both native and binned modes
                                        tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                        tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacAmpTest1_dacAmpTest1_dacCMREF_dacAmpTest0&#39;)
                                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                count = 5
                                while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                        time.sleep(1)
                                        self.API.testBoardADC()
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)
                                        count = count - 1

                        elif info[&#39;DacSel&#39;][gainTransition].upper() == &#39;AMPTEST1-AMPTEST0&#39;:

                                if dumpTimingLastState != &#39;AMPTEST1-AMPTEST0&#39;:
                                        tmp = self.API.DumpTimingTransformation(info[&#39;DE_Struct&#39;],&#39;native_resolution&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                        tmp1 = self.API.DumpTimingTransformation(tmp,&#39;binned&#39;,[],&#39;ampTestSel_dacCMREF_dacCMREF_dacAmpTest1_dacAmpTest0&#39;)
                                        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, tmp1)
                                info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                while((abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &lt; 0.01) and (abs(info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg]) &gt; 3.00) and (count &gt; 1)):
                                        time.sleep(1)
                                        self.API.testBoardADC()
                                        info[&#39;gainCalVoltageDiff&#39;][gainTransition][posNeg] = self.API.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
                                        count = count - 1

                        else:
                                raise Exception(&#39;Incorrect DacSel value&#39;)
                                logging.error(&#39;Incorrect DacSel value&#39;)

                        dumpTimingLastState = info[&#39;DacSel&#39;][gainTransition].upper()
                        print(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000))
                        logging.info(str(&#39;Measured voltage: %6.1fmV&#39; %(info[&#39;gainCalVoltageDiff&#39;][gainTransition,posNeg]*1000)))

                        GT, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                        # GT = ta
                        # ADC_tmp = tb 
                        # SAT = SAT_test

                        if np.any(GT != gainTransition):
                                raise Exception(&#39;Incorrect forced comparator gain setting returned&#39;)
                                logging.error(&#39;Incorrect forced comparator gain setting returned&#39;)

                        if np.any(SAT):
                                normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                                (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                                print(&#34;Pixels saturated!&#34;, np.max(normalizedSatPerCol), &#34;limit:&#34;,compCalSatLimit)
                                logging.warning(&#34;Pixels saturated!&#34; + str(np.max(normalizedSatPerCol)) + &#34;limit:&#34;+ str(compCalSatLimit))
                                if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                        raise Exception(&#39;Saturation occurred for gain&#39;)
                                        logging.error(&#39;Saturation occurred for gain&#39;)
                                else:
                                        print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                        ADC_tmp = ADC_tmp.astype(np.float)
                                        ADC_tmp[SAT] = np.nan

                        ADC_Native[:,:,:,:,gainTransition,posNeg] = ADC_tmp


        print(&#39;\nMeasuring per column offsets (native dump)&#39;)
        logging.info(&#39;\nMeasuring per column offsets (native dump)&#39;)

        self.API.DumpTimingTool(&#39;WriteToChip&#39;, 0, info[&#39;DE_Struct&#39;])


        status = self.API.UpdateUseCaseFrameSetting(3, &#39;DRAINSTYLE&#39;, 1)
        self.API.error_assert(status, &#39;Unable to set drain style&#39;)
        s = self.API.regwrite(0x0014, 0x0000)

        s = self.API.regwrite(0x0E1C, 0x0000)
        s = self.API.regwrite(0x0E1E, 0x0010)
        s = self.API.regwrite(0x0E20, 0x0000)
        s = self.API.regwrite(0x0E22, 0x0010)
        s = self.API.regwrite(0x0E24, 0x0000)
        s = self.API.regwrite(0x0E26, 0x0010)
        s = self.API.regwrite(0x0E28, 0x0000)
        s = self.API.regwrite(0x0E2A, 0x0010)
        s = self.API.regwrite(0x0E2C, 0x0000)
        s = self.API.regwrite(0x0E2E, 0x0010)
        _, _, SAT_test = self.API.GetFramesPCGO(NFRAMES) 

        self.API.error_assert(success, &#39;Cannot write amp_mux registers&#39;)
        measuredOffsetNative = np.zeros([1024,2,4])

        for gainTransition in range(3,-1,-1):
                success = self.API.regrmw(0x012A, forceSingleGain[gainTransition], 0x7E00) # set comp_ref_disable[5:0] to force single gain
                time.sleep(0.1)
                # print(&#39;regrmw value&#39;, gainTransition, &#39;--&gt;&#39;, forceSingleGain[gainTransition])
                self.API.error_assert(success, &#39;Failed to force single gain&#39;)
                _, ADC_tmp, SAT = self.API.GetFramesPCGO(NFRAMES)
                print(&#39;Max ADC:&#39;, np.max(ADC_tmp))
                logging.info(&#39;Max ADC:&#39; + str(np.max(ADC_tmp)))
                print(&#39;Min ADC:&#39;, np.min(ADC_tmp))
                logging.info(&#39;Min ADC:&#39; + str(np.min(ADC_tmp)))
                print(&#39;Mean ADC:&#39;, np.mean(ADC_tmp))
                logging.info(&#39;Mean ADC:&#39; + str(np.mean(ADC_tmp)))
                # np.save(&#39;Offsetframe&#39; + str(gainTransition), ADC_tmp)

                if np.any(SAT):
                        normalizedSatPerCol = (np.sum(np.reshape(SAT.transpose(1,0,2,3), (list(np.shape(SAT))[1], -1)),1) / 
                                                                        (np.shape(SAT)[0] * np.shape(SAT)[2]* np.shape(SAT)[3]))

                        if np.max(normalizedSatPerCol) &gt; compCalSatLimit:
                                raise Exception(&#39;Saturation occurred for gain&#39;)
                                logging.error(&#39;Saturation occurred for gain&#39;)
                        else:
                                print(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                logging.warning(&#39;Saturation occurred for gain, but was within allowed limit&#39;)
                                ADC_tmp = ADC_tmp.astype(np.float)
                                ADC_tmp[SAT] = np.nan

                ADC_tmp = np.squeeze(np.transpose(ADC_tmp, (1,0,2,3)))
                measuredOffsetNative[:,0,gainTransition] = np.nanmean(ADC_tmp[:, ::2],1) # even rows offset
                measuredOffsetNative[:,1,gainTransition] = np.nanmean(ADC_tmp[:, 1::2],1) # even rows offset

        del GT, SAT, ADC_tmp

        ADC_Native = np.transpose(ADC_Native, (1,0,4,5,2,3)) # change to order: [column, row, gain,upper/lower value, phase, frame#]

        f = open(os.path.join(self.folderName, &#39;ADC_Native.pkl&#39;), &#39;wb&#39;)
        pickle.dump(ADC_Native,f)
        f.close()

        tmp = np.transpose(ADC_Native[:,:,:,0,:,:], (2,0,1,3,4))
        info[&#39;ADC_Native_max&#39;] = np.max(np.reshape(tmp,(4,-1)), 1)
        info[&#39;ADC_Native_max&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
        info[&#39;ADC_Native_mean_high&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)
        tmp = np.transpose(ADC_Native[:,:,:,1,:,:], (2,0,1,3,4))
        info[&#39;ADC_Native_min&#39;] = np.min(np.reshape(tmp,(4,-1)), 1)
        info[&#39;ADC_Native_min&#39;][np.any(np.isnan(np.reshape(tmp,(4,-1))), axis=1)]
        info[&#39;ADC_Native_mean_low&#39;] = np.nanmean(np.reshape(tmp,(4,-1)), 1)

        print(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;]))
        logging.info(str(&#39;Gain cal: Min ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_min&#39;])))

        print(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;]))
        logging.info(str(&#39;Gain cal: Mean low ADC val per gain (highest gain to lowest gain):  %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_low&#39;])))

        print(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;]))
        logging.info(str(&#39;Gain cal: Mean high ADC val per gain (highest gain to lowest gain): %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_mean_high&#39;])))

        print(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;]))
        logging.info(str(&#39;Gain cal: Max ADC val per gain (highest gain to lowest gain):       %3.0f, %3.0f, %3.0f, %3.0f&#39; % tuple(info[&#39;ADC_Native_max&#39;])))

        ADC_Native = np.nanmean(ADC_Native, axis = 5)  # take mean of dimensions [frame#, phase]
        ADC_Native = np.squeeze(np.nanmean(ADC_Native, axis = 4))

        tmp = list(np.shape(ADC_Native))
        tmp[1] = 2
        ADC_out = np.zeros(tmp) # take mean of every 2nd row (dimensions [col, even/odd row, gain, upper/lower value])

        ADC_out[:,0,:,:] = np.nanmean(ADC_Native[:,::2,:,:], axis=1)
        ADC_out[:,1,:,:] = np.nanmean(ADC_Native[:,1::2,:,:], axis=1)

        tmp_divisor = np.reshape(info[&#39;gainCalVoltageDiff&#39;][:,1] - info[&#39;gainCalVoltageDiff&#39;][:,0],(1,1,4))
        measuredGainNative = (ADC_out[:,:,:,1] - ADC_out[:,:,:,0]) / tmp_divisor

        info[&#39;ampgainMeasuredNative&#39;] = np.squeeze(np.mean(np.median(measuredGainNative,axis=0),axis=0)) / (2**(9+self.tenBitMode)/(ADC_FS*2))
        print(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;]))
        logging.info(str(&#39;Measured ampgains (native dump): %.2fx, %.2fx, %.2fx, %.2fx&#39; %tuple(info[&#39;ampgainMeasuredNative&#39;])))
        expectedAmpGain = self.API.ReadAmpGainSetting()

        # perform a gross check that gains are within 20% of expected value
        measuredGainLimit = 0.2
        ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &gt; (1+measuredGainLimit))
        if np.any(ampGainLimit):
                raise Exception(&#39;Measured gain above limit&#39;)
                logging.error(&#39;Measured gain above limit&#39;)
        ampGainLimit = ((info[&#39;ampgainMeasuredNative&#39;]).flatten() / np.array(expectedAmpGain).flatten() &lt; (1-measuredGainLimit))
        if np.any(ampGainLimit):
                raise Exception(&#39;Measured gain below limit&#39;)
                logging.error(&#39;Measured gain below limit&#39;)

        f1 = open(os.path.join(self.folderName, &#34;measuredGainNative.pkl&#34;), &#39;wb&#39;)
        measuredGainNative_dict = dict()
        measuredGainNative_dict[&#39;measuredGainNative&#39;] = measuredGainNative
        measuredGainNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
        measuredGainNative_dict[&#39;ADC_FS&#39;] = ADC_FS
        pickle.dump(measuredGainNative_dict, f1)
        f1.close()

        f2 = open(os.path.join(self.folderName, &#34;measuredOffsetNative.pkl&#34;), &#39;wb&#39;)
        measuredOffsetNative_dict = dict()
        measuredOffsetNative_dict[&#39;measuredOffsetNative&#39;] = measuredOffsetNative
        measuredOffsetNative_dict[&#39;tenBitMode&#39;] = self.tenBitMode
        measuredOffsetNative_dict[&#39;ADC_FS&#39;] = ADC_FS
        pickle.dump(measuredOffsetNative_dict, f2)
        f2.close()


        # Gain and Offset Correction
        highestGainMeas = np.mean(np.median(measuredGainNative[:,:,0],axis=0))
        nominalGain = np.append(np.array([1]), highestGainMeas/ np.mean(np.median(measuredGainNative[:,:,1:4],axis=0),axis=0))
        targetGainNative = highestGainMeas / measuredGainNative

        inverseGlobalADCGain, perColGainAdj, clampedGain = R2L.GainRaw2Lx5(targetGainNative, nominalGain)
        if np.any(clampedGain) == True:
                raise Exception(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)
                logging.error(&#39;WSF:GainOffset:PerColumnGainClamped&#39;)

        success, ramDataGain, perColumnGainAdjustment = R2L.GeneratePerColRam(perColGainAdj)
        # ramDataGain is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
        # perColumnGainAdjustment is a dictionary with data per mode
        # ramDataGain = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]

        if self.tenBitMode:
                perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-512,&#39;bpp_10&#39;)
        else:
                perColOffset, clampedOffset = R2L.OffsetRaw2Lx5(measuredOffsetNative-256,&#39;bpp_9&#39;)

        if np.any(clampedOffset) == True:
                raise Exception(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)
                logging.error(&#39;WSF:GainOffset:PerColumnOffsetClamped&#39;)

        success, ramDataOffset, perColumnOffsetAdjustment = R2L.GeneratePerColRam(perColOffset)
        # ramDataOffset is in uint16 format and ready to write to RAM -&gt; 12800 x 2bytes
        # perColumnOffsetAdjustment is a dictionary with data per mode
        # ramDataOffset = [A1D1;A1D2;A1D4;A2D1;A2D2;A4D1]
        self.cal_dict[&#39;inverseGlobalADCGain&#39;] = inverseGlobalADCGain
        self.cal_dict[&#39;perColumnGainAdjustment&#39;] = perColumnGainAdjustment
        self.cal_dict[&#39;perColumnOffsetAdjustment&#39;] = perColumnOffsetAdjustment
        self.cal_dict[&#39;ramDataGain&#39;] = ramDataGain
        self.cal_dict[&#39;ramDataOffset&#39;] = ramDataOffset

        self.cal_dict[&#39;info&#39;] = dict()
        now = datetime.now()
        self.cal_dict[&#39;info&#39;][&#39;CheckSum&#39;] = 0
        self.cal_dict[&#39;info&#39;][&#39;Year&#39;] = int(now.strftime(&#39;%Y&#39;))
        self.cal_dict[&#39;info&#39;][&#39;Month&#39;] = int(now.strftime(&#39;%m&#39;))
        self.cal_dict[&#39;info&#39;][&#39;Day&#39;] = int(now.strftime(&#39;%d&#39;))
        self.cal_dict[&#39;info&#39;][&#39;Hour&#39;] = int(now.strftime(&#39;%H&#39;))
        self.cal_dict[&#39;info&#39;][&#39;Minute&#39;] = int(now.strftime(&#39;%M&#39;))
        self.cal_dict[&#39;info&#39;][&#39;Second&#39;] = int(now.strftime(&#39;%S&#39;))
        self.cal_dict[&#39;info&#39;][&#39;configuration_file&#39;] = self.cfg_file

        limits_file = self.yaml_file[&#39;limits_file&#39;]
        try:
                with open(limits_file) as y:
                        limits = yaml.load(y, Loader=yaml.SafeLoader)[&#39;GainOffsetCalibration&#39;]
        except:
                raise Exception(&#34;\n\nWARNING: Incorrect/non-existing limits file\n\n&#34;)

        self.cal_dict[&#39;gain_offset_pass&#39;] = True #Initialize to True

        adc_delay = np.round(self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;],3)
        if limits[&#39;adc_delay&#39;][0] &lt; adc_delay &lt; limits[&#39;adc_delay&#39;][1]:
                adc_delay_status = &#34;PASSED&#34;
        else:
                adc_delay_status = &#34;FAILED&#34;
                print(&#39;\nADC offset delay FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;ADC&#39;][&#39;linear_delay&#39;] = [adc_delay, adc_delay_status, limits[&#39;adc_delay&#39;][0], limits[&#39;adc_delay&#39;][1]]

        MeasuredGain0 = np.round(info[&#39;ampgainMeasuredNative&#39;][0],3)
        if MeasuredGain0 &gt; limits[&#39;Gain0_MeasNative&#39;][0]:
                Gain0_Native_status = &#34;PASSED&#34;
        else:
                Gain0_Native_status = &#34;FAILED&#34;
                print(&#39;\nGain0 Measured Native FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain0_MeasNative&#39;] = [MeasuredGain0, Gain0_Native_status, limits[&#39;Gain0_MeasNative&#39;][0], limits[&#39;Gain0_MeasNative&#39;][1]]

        MeasuredGain1 = np.round(info[&#39;ampgainMeasuredNative&#39;][1],3)
        if MeasuredGain1 &gt; limits[&#39;Gain1_MeasNative&#39;][0]:
                Gain1_Native_status = &#34;PASSED&#34;
        else:
                Gain1_Native_status = &#34;FAILED&#34;
                print(&#39;\nGain1 Measured Native FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain1_MeasNative&#39;] = [MeasuredGain1, Gain1_Native_status, limits[&#39;Gain1_MeasNative&#39;][0], limits[&#39;Gain1_MeasNative&#39;][1]]

        MeasuredGain2 = np.round(info[&#39;ampgainMeasuredNative&#39;][2],3)
        if MeasuredGain2 &gt; limits[&#39;Gain2_MeasNative&#39;][0]:
                Gain2_Native_status = &#34;PASSED&#34;
        else:
                Gain2_Native_status = &#34;FAILED&#34;
                print(&#39;\nGain2 Measured Native FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain2_MeasNative&#39;] = [MeasuredGain2, Gain2_Native_status, limits[&#39;Gain2_MeasNative&#39;][0], limits[&#39;Gain2_MeasNative&#39;][1]]

        MeasuredGain3 = np.round(info[&#39;ampgainMeasuredNative&#39;][3],3)
        if MeasuredGain3 &gt; limits[&#39;Gain3_MeasNative&#39;][0]:
                Gain3_Native_status = &#34;PASSED&#34;
        else:
                Gain3_Native_status = &#34;FAILED&#34;
                print(&#39;\nGain3 Measured Native FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain3_MeasNative&#39;] = [MeasuredGain3, Gain3_Native_status, limits[&#39;Gain3_MeasNative&#39;][0], limits[&#39;Gain3_MeasNative&#39;][1]]

        Gain0_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][0],3)
        if limits[&#39;Gain0_ADC_min&#39;][0] &lt; Gain0_ADC_min &lt; limits[&#39;Gain0_ADC_min&#39;][1]:
                Gain0_ADC_min_status = &#34;PASSED&#34;
        else:
                Gain0_ADC_min_status = &#34;FAILED&#34;
                print(&#39;\nGain0 ADC min margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain0_ADC_min&#39;] = [Gain0_ADC_min, Gain0_ADC_min_status, limits[&#39;Gain0_ADC_min&#39;][0], limits[&#39;Gain0_ADC_min&#39;][1]]

        Gain0_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][0],3)
        if limits[&#39;Gain0_ADC_max&#39;][0] &lt; Gain0_ADC_max &lt; limits[&#39;Gain0_ADC_max&#39;][1]:
                Gain0_ADC_max_status = &#34;PASSED&#34;
        else:
                Gain0_ADC_max_status = &#34;FAILED&#34;
                print(&#39;\nGain0 ADC max margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain0_ADC_max&#39;] = [Gain0_ADC_max, Gain0_ADC_max_status, limits[&#39;Gain0_ADC_max&#39;][0], limits[&#39;Gain0_ADC_max&#39;][1]]

        Gain1_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][1],3)
        if limits[&#39;Gain1_ADC_min&#39;][0] &lt; Gain1_ADC_min &lt; limits[&#39;Gain1_ADC_min&#39;][1]:
                Gain1_ADC_min_status = &#34;PASSED&#34;
        else:
                Gain1_ADC_min_status = &#34;FAILED&#34;
                print(&#39;\nGain1 ADC min margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain1_ADC_min&#39;] = [Gain1_ADC_min, Gain1_ADC_min_status, limits[&#39;Gain1_ADC_min&#39;][0], limits[&#39;Gain1_ADC_min&#39;][1]]

        Gain1_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][1],3)
        if limits[&#39;Gain1_ADC_max&#39;][0] &lt; Gain1_ADC_max &lt; limits[&#39;Gain1_ADC_max&#39;][1]:
                Gain1_ADC_max_status = &#34;PASSED&#34;
        else:
                Gain1_ADC_max_status = &#34;FAILED&#34;
                print(&#39;\nGain1 ADC max margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain1_ADC_max&#39;] = [Gain1_ADC_max, Gain1_ADC_max_status, limits[&#39;Gain1_ADC_max&#39;][0], limits[&#39;Gain1_ADC_max&#39;][1]]

        Gain2_ADC_min = np.round(self.info[&#39;ADC_Native_min&#39;][2],3)
        if limits[&#39;Gain2_ADC_min&#39;][0] &lt; Gain2_ADC_min &lt; limits[&#39;Gain2_ADC_min&#39;][1]:
                Gain2_ADC_min_status = &#34;PASSED&#34;
        else:
                Gain2_ADC_min_status = &#34;FAILED&#34;
                print(&#39;\nGain2 ADC min margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain2_ADC_min&#39;] = [Gain2_ADC_min, Gain2_ADC_min_status, limits[&#39;Gain2_ADC_min&#39;][0], limits[&#39;Gain2_ADC_min&#39;][1]]

        Gain2_ADC_max = np.round(self.info[&#39;ADC_Native_max&#39;][2],3)
        if limits[&#39;Gain2_ADC_max&#39;][0] &lt; Gain2_ADC_max &lt; limits[&#39;Gain2_ADC_max&#39;][1]:
                Gain2_ADC_max_status = &#34;PASSED&#34;
        else:
                Gain2_ADC_max_status = &#34;FAILED&#34;
                print(&#39;\nGain2 ADC max margin FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;Gain2_ADC_max&#39;] = [Gain2_ADC_max, Gain2_ADC_max_status, limits[&#39;Gain2_ADC_max&#39;][0], limits[&#39;Gain2_ADC_max&#39;][1]]

        comp_vref1 = self.info[&#39;voltage_comp_vref1&#39;]
        if comp_vref1 &gt; limits[&#39;comp_vref1&#39;][0]:
                comp_vref1_status = &#34;PASSED&#34;
        else:
                comp_vref1_status = &#34;FAILED&#34;
                print(&#39;\nCompVref1 voltage FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;comp_vref1&#39;] = [comp_vref1, comp_vref1_status, limits[&#39;comp_vref1&#39;][0], limits[&#39;comp_vref1&#39;][1]]

        comp_vref2 = self.info[&#39;voltage_comp_vref2&#39;]
        if comp_vref2 &gt; limits[&#39;comp_vref2&#39;][0]:
                comp_vref2_status = &#34;PASSED&#34;
        else:
                comp_vref2_status = &#34;FAILED&#34;
                print(&#39;\nCompVref2 voltage FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;comp_vref2&#39;] = [comp_vref2, comp_vref2_status, limits[&#39;comp_vref2&#39;][0], limits[&#39;comp_vref2&#39;][1]]

        comp_vref3 = self.info[&#39;voltage_comp_vref3&#39;]
        if comp_vref3 &gt; limits[&#39;comp_vref3&#39;][0]:
                comp_vref3_status = &#34;PASSED&#34;
        else:
                comp_vref3_status = &#34;FAILED&#34;
                print(&#39;\nCompVref3 voltage FAIL\n&#39;)
                self.cal_dict[&#39;gain_offset_pass&#39;] = False
        self.cal_dict[&#39;comp_vref3&#39;] = [comp_vref3, comp_vref3_status, limits[&#39;comp_vref3&#39;][0], limits[&#39;comp_vref3&#39;][1]]

        self.cal_dict[&#39;info&#39;][&#39;Pass&#39;] = self.cal_dict[&#39;gain_offset_pass&#39;]

        f1 = open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_pkl&#39;] + &#39;.pkl&#39;), &#39;wb&#39;)
        pickle.dump(self.cal_dict, f1)
        f1.close()

        f2 = open(os.path.join(self.folderName, &#34;GO_info.pkl&#34;), &#39;wb&#39;)
        pickle.dump(self.info, f2)
        f2.close()


        print(&#39;Calibration file with&#39;, self.cal_dict.keys())
        c = csv.writer(open(os.path.join(self.folderName, self.yaml_file[&#39;GainOffsetCalibration&#39;][&#39;output_file_csv&#39;] +&#39;.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

        c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

        if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
        else:
                c.writerow([self.const_hex(0x0000)])

        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

        tmp = self.cal_dict[&#39;ramDataGain&#39;]
        for i in range(len(tmp)):
                c.writerow([self.const_hex(tmp[i])])

        tmp = self.cal_dict[&#39;ramDataOffset&#39;]
        for i in range(len(tmp)):
                c.writerow([self.const_hex(tmp[i])])



        c = csv.writer(open(os.path.join(&#39;_tempCalFiles&#39;, &#39;GO_cal_dict.csv&#39;), &#39;w&#39;, newline=&#39;&#39;))

        c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;updnoffset&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;ADC&#39;][&#39;iramp&#39;])])

        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref1Set&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref2Set&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3DAC&#39;])])
        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;Vref3Set&#39;])])

        if &#39;VCMDAC&#39; in list(self.cal_dict[&#39;gainComparator&#39;].keys()):
                c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMDAC&#39;])])
        else:
                c.writerow([self.const_hex(0x0000)])

        c.writerow([self.const_hex(self.cal_dict[&#39;gainComparator&#39;][&#39;VCMSet&#39;])])

        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][0])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][1])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][2])])
        c.writerow([self.const_hex(self.cal_dict[&#39;inverseGlobalADCGain&#39;][3])])

        tmp = self.cal_dict[&#39;ramDataGain&#39;]
        for i in range(len(tmp)):
                c.writerow([self.const_hex(tmp[i])])

        tmp = self.cal_dict[&#39;ramDataOffset&#39;]
        for i in range(len(tmp)):
                c.writerow([self.const_hex(tmp[i])])

        print(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
        logging.info(&#34;\nGAIN AND OFFSET CALIBRATION COMPLETED!&#34;)
        
        return self.cal_dict, self.info</code></pre>
</details>
</dd>
<dt id="GO_functions.GainOffset.const_hex"><code class="name flex">
<span>def <span class="ident">const_hex</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats hex values to 0x0000 form </p>
<p>Inputs:
val
- hex value to be formatted </p>
<p>Outputs:
val
- formatted hex value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const_hex(self, val):
        &#39;&#39;&#39;
        Formats hex values to 0x0000 form 
        
        Inputs: 
          val                   - hex value to be formatted 
          
        Outputs: 
          val                   - formatted hex value 
        
        &#39;&#39;&#39;
        val = np.uint16(val)
        return &#39;0x&#39; + &#39;0&#39;*(max(0,4-len(str(hex(val))[2:]))) + str(hex(val))[2:]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="GO_functions.GainOffset" href="#GO_functions.GainOffset">GainOffset</a></code></h4>
<ul class="two-column">
<li><code><a title="GO_functions.GainOffset.ADCCalib" href="#GO_functions.GainOffset.ADCCalib">ADCCalib</a></code></li>
<li><code><a title="GO_functions.GainOffset.ADC_Delay_LFSR" href="#GO_functions.GainOffset.ADC_Delay_LFSR">ADC_Delay_LFSR</a></code></li>
<li><code><a title="GO_functions.GainOffset.ComparatorDACCal" href="#GO_functions.GainOffset.ComparatorDACCal">ComparatorDACCal</a></code></li>
<li><code><a title="GO_functions.GainOffset.ConfigureChip" href="#GO_functions.GainOffset.ConfigureChip">ConfigureChip</a></code></li>
<li><code><a title="GO_functions.GainOffset.PerColGOCalib" href="#GO_functions.GainOffset.PerColGOCalib">PerColGOCalib</a></code></li>
<li><code><a title="GO_functions.GainOffset.const_hex" href="#GO_functions.GainOffset.const_hex">const_hex</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>