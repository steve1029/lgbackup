<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>P0_results API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>P0_results</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
#
# Copyright (c) 2020 Analog Devices, Inc. All Rights Reserved.   
# This software is proprietary to Analog Devices, Inc. and its licensors.  
#

import numpy as np
import pickle
import os
from scipy.constants import c, pi
from scipy import signal as sig
from datetime import datetime
import yaml
import matplotlib.pyplot as plt
import yaml
# from .. import P0_functions as P0


def image2bin(image, fname):
        &#34;&#34;&#34;
        Saves a 2D matrix in bin format 
        Inputs: 
                image:    2D matrix 
                fname:    name of file to be saved 

        Outputs: 
                none 
        &#34;&#34;&#34;

        tmp = np.squeeze(np.array(image, dtype=np.float32))
        (h,w) = np.shape(tmp)
        tmp_flattened = tmp.flatten()
        write_file = open(fname +&#39;--&#39;+str(h)+&#39;x&#39;+str(w) +&#39;.bin&#39;, &#34;wb&#34;)
        tmp_flattened.tofile(write_file, format=&#39;%f&#39;)


def synthesize_waveform_from_fourier_coefficients(nh, cn, f_fund, Fs, t_start,
                                                  t_end):
    &#34;&#34;&#34;
    nh: harmonic indexes 
    cn: Fourier coefficients 
    f_fund: frequency of fundamental 
    Fs: sampling frequency 
    t_start: start time 
    t_end: end time 
    &#34;&#34;&#34;

    # Sampling period
    Ts = 1 / Fs

    # Sample times
    t = np.arange(t_start, t_end, Ts)

    # Harmonic frequencies
    fh = nh * f_fund

    # Inverse Fourier transform
    yt = np.zeros(t.shape, dtype=&#39;complex&#39;)
    for ii in range(len(fh)):
        yt += cn[ii] * np.exp(1j * t * 2 * pi * fh[ii])

    # Return time stamps and waveform
    return ([t, yt])


def sample_correlation(nh, cn, phase):
    &#34;&#34;&#34;
    nh: harmonic indexes 
    cn: Fourier coefficients 
    phase: phase at which to sample correlation (in radian) 
    &#34;&#34;&#34;

    # Inverse Fourier transform
    V = 0
    for ii in range(len(nh)):
        V += cn[ii] * np.exp(1j * phase * nh[ii])

    # Return correlation sample
    return (np.real(V))


def generate_fft_waveform(fft_array):
        &#34;&#34;&#34;
        fft_array : 1D array containing fft 
        Output : FFT with positive and negative components added 
        &#34;&#34;&#34;
        fft_array2 = np.append(fft_array, [0])[::-1][:-1]
        return (fft_array + fft_array2)[:int(len(fft_array)/2)]


def estimate_distance(mean_frames_center, freqs, maxPhaseSteps, ref_dist):
        &#39;&#39;&#39;
        Estimates the distance given mean frames, i,e frames averaged for 
        phase steps   
                Inputs: 
                        mean_frames_center   - 2D array of mean frames  
                        freqs                - Array of frequencies   
                        maxPhaseSteps        - Maximum phase steps  

                Outputs: 
                        estimated_dist_error  
        &#39;&#39;&#39;

        dist_range = np.linspace(0, 5, 1000)
        n_dist = len(dist_range)
        # freqs = [198e6, 189e6, 54e6]
        freqs = np.array(freqs) * 1e6
        n_freqs = len(freqs)

        cn = np.zeros([n_freqs, maxPhaseSteps])
        cn = np.fft.fftshift(np.fft.fft(mean_frames_center) / maxPhaseSteps)

        # Nh = 12
        # nh = np.arange(-12, 12)
        Nh = int(maxPhaseSteps/2)
        nh = np.arange(-int(maxPhaseSteps/2), int(maxPhaseSteps/2))
        # [t,
        #  yt] = synthesize_waveform_from_fourier_coefficients(nh, cn[0, :], freqs[0],
        #                                                      10e9, 0, 3 / freqs[0])

        V0 = np.zeros([n_freqs, n_dist])
        V120 = np.zeros([n_freqs, n_dist])
        V240 = np.zeros([n_freqs, n_dist])

        for ii, f in enumerate(freqs):
                for jj, dist in enumerate(dist_range):
                        # Generate laser waveforms harmonics
                        T_cycle = 1 / f
                        dt = dist * 2 / c / T_cycle * 2 * pi

                        # Sample correlation
                        V0[ii, jj] = sample_correlation(nh, cn[ii, :], +dt)
                        V120[ii, jj] = sample_correlation(nh, cn[ii, :], 2 * pi / 3 + dt)
                        V240[ii, jj] = sample_correlation(nh, cn[ii, :], 4 * pi / 3 + dt)

        re = 2 * V0 - V120 - V240
        im = np.sqrt(3) * (V240 - V120)
        C = re + 1j * im
        # # Calculate estimate distance assuming perfect unwrapping
        # est_dist_0 = c / (4 * pi * freqs[0]) * np.unwrap(np.angle(C[0, :]))
        # est_dist_1 = c / (4 * pi * freqs[1]) * np.unwrap(np.angle(C[1, :]))
        # est_dist_2 = c / (4 * pi * freqs[2]) * np.unwrap(np.angle(C[2, :]))

        # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
        # P0_dist = ref_dist / 1000.00
        # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()
        # est_dist_0 -= est_dist_0[dist_idx_P0] - P0_dist
        # est_dist_1 -= est_dist_1[dist_idx_P0] - P0_dist
        # est_dist_2 -= est_dist_2[dist_idx_P0] - P0_dist

        # # Weighted sum for final distance calculation
        # est_dist = est_dist_0 * freqs[0]**2 / np.sum(
        #     np.array(freqs)**2) + est_dist_1 * freqs[1]**2 / np.sum(
        #         np.array(freqs)**2) + est_dist_2 * freqs[2]**2 / np.sum(
        #             np.array(freqs)**2)

        est_dist_n = np.zeros(n_freqs, dtype=object)
        # Calculate estimate distance assuming perfect unwrapping
        for i in range(n_freqs):
                est_dist_n[i] = c / (4 * pi * freqs[i]) * np.unwrap(np.angle(C[i, :]))

        # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
        P0_dist = ref_dist / 1000.00
        dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()

        for i in range(n_freqs):
                est_dist_n[i] -= est_dist_n[i][dist_idx_P0] - P0_dist

        # Weighted sum for final distance calculation
        est_dist = np.zeros(np.shape(est_dist_n[0]))
        for i in range(n_freqs):
                est_dist = est_dist + est_dist_n[i] * freqs[i]**2 / np.sum(np.array(freqs)**2)

        return est_dist - dist_range



def add_results_P0(CalibfolderName, calibResult, file, result_dir, config_file):
        &#39;&#39;&#39;
                Adds results of P0 calibration 

                Inputs: 
                  CalibfolderName       - Name of calibration output directory 
                  calibResult           - Calibration result dict 
                  file                  - Name of .yaml config file 
                  result_dir            - Name of result directory 
                  
                Outputs: 
                  calibResult           - Updated calibration result dict 
                
        &#39;&#39;&#39;

        try:
                with open(self.config_file) as y:
                        file = yaml.load(y, Loader=yaml.SafeLoader)

                with open(file[&#39;mode_info_file&#39;]) as f:
                        modeInfo = yaml.load(f, Loader=yaml.SafeLoader)
        except:
                with open(&#39;config/CameraModeInfo.yaml&#39;) as y:
                        modeInfo = yaml.load(y, Loader=yaml.SafeLoader)


        print(&#34;Generating results for P0 Calibration...&#34;)

        P0_dir = os.path.join(CalibfolderName, file[&#39;P0Calibration&#39;][&#39;output_directory&#39;])
        P0_uncompressed_output = os.path.join(P0_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;])
        P0_compressed_output = os.path.join(P0_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;])

        # freqs = [198, 189, 54]

        if os.path.exists(P0_dir):
                P0_files = os.listdir(P0_dir)

                P0Table_modes = np.array([], dtype =np.int8)
                for P0_file in P0_files:
                        if P0_file.startswith(file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;]) and P0_file[-4:]==&#39;.pkl&#39;:
                                P0Table_modes = np.append(P0Table_modes, int(P0_file.split(&#39;_&#39;)[-1][:-4]))

                compressed_P0Table_modes = np.array([], dtype =np.int8)
                for P0_file in P0_files:
                        if P0_file.startswith(file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;]) and P0_file[-4:]==&#39;.pkl&#39;:
                                compressed_P0Table_modes = np.append(compressed_P0Table_modes, int(P0_file.split(&#39;_&#39;)[-1][:-4]))

                calibResult[&#39;P0&#39;] = dict()
                
                try:
                        P0_prelim = os.path.join(P0_dir, &#39;preliminaryTestResults.pkl&#39;)
                        f = open(P0_prelim, &#39;rb&#39;)
                        prelim = pickle.load(f)
                        f.close()
                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;] = dict()

                        for key,val in prelim.items():
                                calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;][key] = val

                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;] = True
                except:
                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;] = False

                if len(P0Table_modes) != 0:
                        calibResult[&#39;P0_pass&#39;] = True

                        if calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;]:
                                calibResult[&#39;P0_pass&#39;] = calibResult[&#39;P0_pass&#39;] and calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;][&#39;All_pass&#39;]

                        calibResult[&#39;P0_exists&#39;] = True

                        P0Table_modes = sorted(P0Table_modes)
                else:
                        calibResult[&#39;P0_pass&#39;] = False

                if len(compressed_P0Table_modes) != 0:
                        calibResult[&#39;comp_P0_exists&#39;] = True

                        compressed_P0Table_modes = sorted(compressed_P0Table_modes)


                if calibResult[&#39;P0_exists&#39;]:
                        

                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_0_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_1_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_4_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_5_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_7_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_10_exists&#39;] = False

                        print(&#34;--Generating P0 Table results...&#34;)
                        for m in P0Table_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_&#39; + str(m) + &#39;_exists&#39;] = True
                                f = open(P0_uncompressed_output + str(m) + &#39;.pkl&#39;, &#39;rb&#39;)
                                try:
                                        P0_tab = pickle.load(f)[&#39;P0Table&#39;]
                                except:
                                        P0_tab = pickle.load(f)

                                f.close()

                                freqs = modeInfo[&#39;mode&#39;][int(m)][&#39;freqsMhz&#39;]

                                P0_ax = np.zeros(len(freqs), dtype=object)
                                P0_img = np.zeros(len(freqs), dtype=object)

                                # P0_calib = P0.P0_calibration()

                                figureSize = 2*len(freqs)

                                fig = plt.figure(figsize=(15, figureSize))
                                for i in range(len(freqs)):
                                        P0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                        P0_img[i] = P0_ax[i].imshow(P0_tab[:,:,i])
                                        image2bin(P0_tab[:,:,i], os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;_&#39; + str(i)))
                                        plt.title(&#39;P0 table - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                        fig.colorbar(P0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                        P0_ax[i].autoscale(False)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;.png&#39;)
                                del P0_tab

                verify_modes = np.array([], dtype =np.int8)
                # verify_dists = np.array([], dtype =np.int16)
                verify_AB_files = np.array([], dtype =object)
                verify_dist_files = np.array([], dtype =object)
                mean_frames_files = np.array([], dtype =object)

                for P0_file in P0_files:
                        if (&#39;AB&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                verify_modes = np.append(verify_modes, int(P0_file.split(&#39;_&#39;)[2]))
                                # verify_dists = np.append(verify_dists, int(P0_file.split(&#39;_&#39;)[-1][:-6]))
                                verify_AB_files = np.append(verify_AB_files, P0_file)

                        if (&#39;_freqDist&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                verify_dist_files = np.append(verify_dist_files, P0_file)

                        if (&#39;mean_frames&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                 mean_frames_files = np.append(mean_frames_files, P0_file)

                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_10_exists&#39;] = False

                print(&#34;--Generating P0 verification(depth) results...&#34;)

                if calibResult[&#39;P0_exists&#39;] and len(verify_modes)!= 0:
                        for m in verify_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_&#39; + str(m) +&#39;_exists&#39;] = True

                for dist_file in verify_dist_files:
                        ref_dist = float(dist_file.split(&#39;_&#39;)[-1][:-6])
                        ref_mode = int(dist_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, dist_file), &#39;rb&#39;)
                        dist = np.array(pickle.load(f))
                        f.close()

                        cw = int(np.shape(dist)[0] / 2)
                        ch = int(np.shape(dist)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_dist = np.zeros(len(freqs))
                        min_dist = np.zeros(len(freqs))
                        max_dist = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_dist[i] = np.round(np.nanmean(dist[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)
                                min_dist[i] = meanROI_dist[i] - 0.5*meanROI_dist[i]
                                max_dist[i] = meanROI_dist[i] + 0.5*meanROI_dist[i]
                                dist[:,:,i] = np.clip(dist[:,:,i], min_dist[i], max_dist[i])


                        dist[np.isnan(dist)] = 0

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(dist[:,:,i])
                                image2bin(dist[:,:,i], os.path.join(result_dir, dist_file[:-4] + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth w/P0- &#39; + str(freqs[i]) + &#39;Mhz (&#39; + str(ref_dist) + &#39;mm)&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_dist[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, dist_file[:-4] + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, dist_file[:-4] + &#39;.png&#39;)

                        # Depth error

                        DE_ax = np.zeros(len(freqs), dtype=object)
                        PE_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DE_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PE_img[i] = DE_ax[i].imshow(np.float(ref_dist) - dist[:,:,i])
                                image2bin(np.float(ref_dist) - dist[:,:,i], os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth error - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PE_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DE_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        # Depth error histogram

                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de = np.float(ref_dist) - dist[:,:,i]
                                de_hist = np.hstack(de.flatten())
                                if i&gt;0:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1, sharey=DEH_ax[0])
                                else:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;Depth error histogram - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)

                        plt.savefig(os.path.join(result_dir, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_error_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        del dist


                print(&#34;--Generating P0 verification(AB) results...&#34;)
                for AB_file in verify_AB_files:
                        ref_mode = int(AB_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, AB_file), &#39;rb&#39;)
                        AB = pickle.load(f)
                        f.close()

                        cw = int(np.shape(AB)[0] / 2)
                        ch = int(np.shape(AB)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_AB = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_AB[i] = np.round(np.nanmean(AB[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(AB[:,:,i], vmin=0, vmax=2*meanROI_AB[i], cmap = &#39;gray&#39;)
                                image2bin(AB[:,:,i], os.path.join(result_dir, AB_file[:-4] + &#39;_&#39; + str(i)))
                                plt.title(&#39;AB - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_AB[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, AB_file[:-4] + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_AB_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, AB_file[:-4] + &#39;.png&#39;)



                        # AB histogram


                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de_hist = np.hstack(AB[:,:,i].flatten())
                                DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;AB histogram - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)

                        plt.savefig(os.path.join(result_dir, &#39;AB_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_AB_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;AB_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        del AB


                # COMPRESSED P0

                if calibResult[&#39;P0_exists&#39;] and calibResult[&#39;comp_P0_exists&#39;]:

                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_0_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_1_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_4_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_5_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_7_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_10_exists&#39;] = False

                        print(&#34;--Generating P0 Table compressed results...&#34;)

                        for m in compressed_P0Table_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_&#39; + str(m) + &#39;_exists&#39;] = True
                                f = open(P0_compressed_output + str(m) + &#39;.pkl&#39;, &#39;rb&#39;)
                                P0_RC = pickle.load(f)
                                f.close()

                                keys = list(P0_RC.keys())
                                n_freqs = 0
                                try:
                                        for i in range(len(keys)):
                                                if keys[i].startswith(&#39;freq&#39;):
                                                        n_freqs = n_freqs + 1
                                except:
                                        raise Exception(&#34;Invalid compressed P0 table&#34;)


                                # Row coefficients
                                # freqs = [198, 189, 54]
                                freqs = modeInfo[&#39;mode&#39;][int(m)][&#39;freqsMhz&#39;]
                                row_ax = np.zeros(n_freqs, dtype=object)
                                row_img = np.zeros(n_freqs, dtype=object)

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        row_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        row_img[i] = row_ax[i].plot(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0RowCoefs&#39;])
                                        plt.title(&#39;P0 Row Coeff - &#39; + str(freqs[i]) + &#39;Mhz&#39;)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_row_coeff&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_row_coeff_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_row_coeff&#39; + &#39;.png&#39;)

                                # Column efficients
                                col_ax = np.zeros(n_freqs, dtype=object)
                                col_img = np.zeros(n_freqs, dtype=object)

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        col_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        col_img[i] = col_ax[i].plot(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0ColCoefs&#39;])
                                        plt.title(&#39;P0 Col Coeff - &#39; + str(freqs[i]) + &#39;Mhz&#39;)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_col_coeff&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_col_coeff_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_col_coeff&#39; + &#39;.png&#39;)

                                # Uncompressed-comprssed P0 Tables
                                dirname, base = os.path.split(P0_compressed_output)
                                fname_2D_P0 = os.path.join(dirname, &#39;un&#39;+base + str(m) + &#39;_2D_P0&#39; + &#39;.pkl&#39;)
                                try:    
                                        f = open(fname_2D_P0, &#39;rb&#39;)
                                        P0_2D = pickle.load(f)[&#39;P0Table&#39;]
                                        f.close()
                                except:
                                        if str(m) == &#39;10&#39;:
                                                fname_2D_P0 = os.path.join(dirname, &#39;un&#39;+base + str(5) + &#39;_2D_P0&#39; + &#39;.pkl&#39;)
                                        f = open(fname_2D_P0, &#39;rb&#39;)
                                        P0_2D = pickle.load(f)[&#39;P0Table&#39;]
                                        f.close()

                                cP0_ax = np.zeros(n_freqs, dtype=object)
                                cP0_img = np.zeros(n_freqs, dtype=object)

                                # P0_calib = P0.P0_calibration()

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        cP0_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        # matrix = P0_calib.Uncompress2Matrix(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0RowCoefs&#39;], P0_RC[&#39;freq_&#39; + str(i)][&#39;P0ColCoefs&#39;])
                                        cP0_img[i] = cP0_ax[i].imshow(P0_2D[:,:,i])
                                        image2bin(P0_2D[:,:,i], os.path.join(result_dir, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;_&#39; + str(i)))
                                        plt.title(&#39;P0 compressed table - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                        fig.colorbar(cP0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                        cP0_ax[i].autoscale(False)

                                plt.savefig(os.path.join(result_dir, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_2D_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;.png&#39;)

                                del P0_2D


                print(&#34;--Generating P0 compressed verification(depth) results...&#34;)
                # P0 Compression verification
                comp_verify_modes = np.array([], dtype =np.int8)
                # verify_dists = np.array([], dtype =np.int16)
                comp_verify_dist_files = np.array([], dtype =object)
                residue_rad_files = np.array([], dtype =object)
                residue_mm_files = np.array([], dtype =object)

                for P0_file in P0_files:
                        if (&#39;_compressedfreqDist&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                comp_verify_modes = np.append(comp_verify_modes, int(P0_file.split(&#39;_&#39;)[2]))
                                comp_verify_dist_files = np.append(comp_verify_dist_files, P0_file)

                        if (&#39;residue_rad&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                residue_rad_files = np.append(residue_rad_files, P0_file)

                        if (&#39;residue_mm&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                residue_mm_files = np.append(residue_mm_files, P0_file)

                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_10_exists&#39;] = False

                if calibResult[&#39;P0_exists&#39;] and len(comp_verify_modes)!= 0:
                        for m in comp_verify_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_&#39; + str(m) +&#39;_exists&#39;] = True

                for dist_file in comp_verify_dist_files:
                        ref_dist = float(dist_file.split(&#39;_&#39;)[-1][:-6])
                        ref_mode = int(dist_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, dist_file), &#39;rb&#39;)
                        dist_comp = np.array(pickle.load(f))
                        f.close()

                        cw = int(np.shape(dist_comp)[0] / 2)
                        ch = int(np.shape(dist_comp)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_dist = np.zeros(len(freqs))
                        min_dist = np.zeros(len(freqs))
                        max_dist = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_dist[i] = np.round(np.nanmean(dist_comp[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)
                                min_dist[i] = meanROI_dist[i] - 0.5*meanROI_dist[i]
                                max_dist[i] = meanROI_dist[i] + 0.5*meanROI_dist[i]
                                dist_comp[:,:,i] = np.clip(dist_comp[:,:,i], min_dist[i], max_dist[i])


                        dist_comp[np.isnan(dist_comp)] = 0

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(dist_comp[:,:,i])
                                image2bin(dist_comp[:,:,i], os.path.join(result_dir, dist_file[:-4]+ &#39;_compressed&#39; + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth w/comp_P0- &#39; + str(freqs[i]) + &#39;Mhz (&#39; + str(ref_dist) + &#39;mm)&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_dist[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, dist_file[:-4]+ &#39;_compressed&#39; + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, dist_file[:-4]+ &#39;_compressed&#39; + &#39;.png&#39;)

                        # Depth error


                        DE_ax = np.zeros(len(freqs), dtype=object)
                        PE_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DE_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PE_img[i] = DE_ax[i].imshow(np.float(ref_dist) - dist_comp[:,:,i])
                                image2bin(np.float(ref_dist) - dist_comp[:,:,i], os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth error w/comp - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PE_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DE_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;.png&#39;)

                        # Depth error histogram

                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de = np.float(ref_dist) - dist_comp[:,:,i]
                                de_hist = np.hstack(de.flatten())
                                if i&gt;0:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1,sharey=DEH_ax[0])
                                else:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;Depth error histogram w/comp - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;_compressed.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_error_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;_compressed.png&#39;)

                        del dist_comp


                print(&#34;--Generating P0 residue results...&#34;)
                # Residue Radian
                for residue_rad_file in residue_rad_files:
                        residue_mode = int(residue_rad_file[:-4].split(&#39;_&#39;)[-1])
                        f = open(os.path.join(P0_dir, residue_rad_file), &#39;rb&#39;)
                        residue_rad = np.array(pickle.load(f))
                        f.close()

                        freqs = modeInfo[&#39;mode&#39;][int(residue_mode)][&#39;freqsMhz&#39;]

                        res_ax = np.zeros(len(freqs), dtype=object)
                        res_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                res_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                res_img[i] = res_ax[i].imshow(residue_rad[:,:,i])
                                image2bin(residue_rad[:,:,i], os.path.join(result_dir, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Residue in radian- &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(res_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                res_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_residue_rad_mode_&#39; + str(residue_mode)]= os.path.join(&#39;Results&#39;, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;.png&#39;)

                # Residue mm
                for residue_mm_file in residue_mm_files:
                        residue_mode = int(residue_mm_file[:-4].split(&#39;_&#39;)[-1])
                        f = open(os.path.join(P0_dir, residue_mm_file), &#39;rb&#39;)
                        residue_mm = np.array(pickle.load(f))
                        f.close()

                        freqs = modeInfo[&#39;mode&#39;][int(residue_mode)][&#39;freqsMhz&#39;]

                        res_ax = np.zeros(len(freqs), dtype=object)
                        res_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                res_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                res_img[i] = res_ax[i].imshow(residue_mm[:,:,i])
                                image2bin(residue_mm[:,:,i], os.path.join(result_dir, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Residue in mm- &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(res_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                res_ax[i].autoscale(False)



                        plt.savefig(os.path.join(result_dir, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_residue_mm_mode_&#39; + str(residue_mode)]= os.path.join(&#39;Results&#39;, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;.png&#39;)


                # Mean frames

                print(&#34;--Generating P0 mean frames results...&#34;)
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_10_exists&#39;] = False

                if calibResult[&#39;P0_exists&#39;] and len(mean_frames_files)!= 0:
                        for mean_file in mean_frames_files:
                                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_&#39; + str(mean_file.split(&#39;_&#39;)[3][:-4]) +&#39;_exists&#39;] = True
                                # print(&#39;P0Table_mean_frames_mode_&#39; + str(mean_file.split(&#39;_&#39;)[3][:-4]) +&#39;_exists&#39;)

                for mean_frames_file in mean_frames_files:
                        ref_mode = int(mean_frames_file.split(&#39;_&#39;)[3][:-4])
                        f = open(os.path.join(P0_dir, mean_frames_file), &#39;rb&#39;)
                        mean_frames = pickle.load(f)
                        f.close()

                        cw = int(np.shape(mean_frames)[0] / 2)
                        ch = int(np.shape(mean_frames)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]

                        maxPhaseSteps = int(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;maxPhaseSteps&#39;])

                        mean_frames_center = np.zeros([len(freqs),maxPhaseSteps])
                        for i in range(len(freqs)):
                                mean_frames_center[i,:] = np.mean(mean_frames[cw, ch, i*3 : (i+1)*3, :], axis = 0)

                        del mean_frames

                        plt.figure()
                        for i in range(len(freqs)):
                                plt.plot(mean_frames_center[i,:], label=str(freqs[i])+&#34;Mhz&#34;)
                        # plt.plot(mean_frames_center[0,:], label=&#34;198Mhz&#34;)
                        # plt.plot(mean_frames_center[1,:], label=&#34;189Mhz&#34;)
                        # plt.plot(mean_frames_center[2,:], label=&#34;54Mhz&#34;)
                        plt.legend()
                        plt.xlabel(&#39;Phase&#39;)
                        plt.ylabel(&#39;Amplitude&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;Correlated_waveform_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        fft_mean_frames_center = np.zeros([len(freqs), int(maxPhaseSteps/2)])

                        for i in range(len(freqs)):
                                fft_mean_frames_center[i, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[i,:]))) / maxPhaseSteps
                        # fft_mean_frames_center[0, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[0,:]))) / 24
                        # fft_mean_frames_center[1, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[1,:]))) / 24
                        # fft_mean_frames_center[2, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[2,:]))) / 24

                        plt.figure()
                        for i in range(len(freqs)):
                                plt.plot(fft_mean_frames_center[i,:], label=str(freqs[i])+&#34;Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[0, :], label=&#34;198Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[1, :], label=&#34;189Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[2, :], label=&#34;54Mhz&#34;)
                        plt.legend()
                        plt.yscale(&#39;log&#39;)
                        plt.xlabel(&#39;Phase&#39;)
                        plt.ylabel(&#39;Amplitude&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;)
                        plt.close()

                        for i in range(len(freqs)):
                                calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_&#39;+str(int(freqs[i]))+&#39;Mhz&#39;] = (fft_mean_frames_center[i, 1] / fft_mean_frames_center[i, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_198Mhz&#39;] = (fft_mean_frames_center[0, 1] / fft_mean_frames_center[0, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_189Mhz&#39;] = (fft_mean_frames_center[1, 1] / fft_mean_frames_center[1, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_54Mhz&#39;] = (fft_mean_frames_center[2, 1] / fft_mean_frames_center[2, 0]) / (4/np.pi) * 100


                        # dist_range = np.linspace(0, 5, 1000)
                        # n_dist = len(dist_range)
                        # # freqs = [198e6, 189e6, 54e6]
                        # freqs = np.array(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]) * 1e6
                        # n_freqs = len(freqs)

                        # cn = np.zeros([n_freqs, maxPhaseSteps])
                        # cn = np.fft.fftshift(np.fft.fft(mean_frames_center) / maxPhaseSteps)

                        # # Nh = 12
                        # # nh = np.arange(-12, 12)
                        # Nh = int(maxPhaseSteps/2)
                        # nh = np.arange(-int(maxPhaseSteps/2), int(maxPhaseSteps/2))
                        # # [t,
                        # #  yt] = synthesize_waveform_from_fourier_coefficients(nh, cn[0, :], freqs[0],
                        # #                                                      10e9, 0, 3 / freqs[0])

                        # V0 = np.zeros([n_freqs, n_dist])
                        # V120 = np.zeros([n_freqs, n_dist])
                        # V240 = np.zeros([n_freqs, n_dist])

                        # for ii, f in enumerate(freqs):

                        #     for jj, dist in enumerate(dist_range):
                        #         # Generate laser waveforms harmonics
                        #         T_cycle = 1 / f
                        #         dt = dist * 2 / c / T_cycle * 2 * pi

                        #         # Sample correlation
                        #         V0[ii, jj] = sample_correlation(nh, cn[ii, :], +dt)
                        #         V120[ii, jj] = sample_correlation(nh, cn[ii, :], 2 * pi / 3 + dt)
                        #         V240[ii, jj] = sample_correlation(nh, cn[ii, :], 4 * pi / 3 + dt)

                        # re = 2 * V0 - V120 - V240
                        # im = np.sqrt(3) * (V240 - V120)
                        # C = re + 1j * im
                        # # # Calculate estimate distance assuming perfect unwrapping
                        # # est_dist_0 = c / (4 * pi * freqs[0]) * np.unwrap(np.angle(C[0, :]))
                        # # est_dist_1 = c / (4 * pi * freqs[1]) * np.unwrap(np.angle(C[1, :]))
                        # # est_dist_2 = c / (4 * pi * freqs[2]) * np.unwrap(np.angle(C[2, :]))

                        # # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
                        # # P0_dist = ref_dist / 1000.00
                        # # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()
                        # # est_dist_0 -= est_dist_0[dist_idx_P0] - P0_dist
                        # # est_dist_1 -= est_dist_1[dist_idx_P0] - P0_dist
                        # # est_dist_2 -= est_dist_2[dist_idx_P0] - P0_dist

                        # # # Weighted sum for final distance calculation
                        # # est_dist = est_dist_0 * freqs[0]**2 / np.sum(
                        # #     np.array(freqs)**2) + est_dist_1 * freqs[1]**2 / np.sum(
                        # #         np.array(freqs)**2) + est_dist_2 * freqs[2]**2 / np.sum(
                        # #             np.array(freqs)**2)

                        # est_dist_n = np.zeros(n_freqs, dtype=object)
                        # # Calculate estimate distance assuming perfect unwrapping
                        # for i in range(n_freqs):
                        #       est_dist_n[i] = c / (4 * pi * freqs[i]) * np.unwrap(np.angle(C[i, :]))

                        # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
                        # P0_dist = ref_dist / 1000.00
                        # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()

                        # for i in range(n_freqs):
                        #       est_dist_n[i] -= est_dist_n[i][dist_idx_P0] - P0_dist

                        # # Weighted sum for final distance calculation
                        # est_dist = np.zeros(np.shape(est_dist_n[0]))
                        # for i in range(n_freqs):
                        #       est_dist = est_dist + est_dist_n[i] * freqs[i]**2 / np.sum(np.array(freqs)**2)

                        freqMhzArray = np.array(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;])

                        est_dist_err = estimate_distance(mean_frames_center, freqMhzArray, maxPhaseSteps, ref_dist)
                        dist_range = np.linspace(0, 5, 1000)

                        plt.figure()
                        plt.plot(dist_range, est_dist_err * 1000)
                        plt.xlabel(&#39;Distance [m]&#39;)
                        plt.ylabel(&#39;Depth estimation error [mm]&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;Estimated_depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;Estimated_depth_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;Estimated_depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

        return calibResult</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="P0_results.add_results_P0"><code class="name flex">
<span>def <span class="ident">add_results_P0</span></span>(<span>CalibfolderName, calibResult, file, result_dir, config_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds results of P0 calibration </p>
<p>Inputs:
CalibfolderName
- Name of calibration output directory
calibResult
- Calibration result dict
file
- Name of .yaml config file
result_dir
- Name of result directory </p>
<p>Outputs:
calibResult
- Updated calibration result dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_results_P0(CalibfolderName, calibResult, file, result_dir, config_file):
        &#39;&#39;&#39;
                Adds results of P0 calibration 

                Inputs: 
                  CalibfolderName       - Name of calibration output directory 
                  calibResult           - Calibration result dict 
                  file                  - Name of .yaml config file 
                  result_dir            - Name of result directory 
                  
                Outputs: 
                  calibResult           - Updated calibration result dict 
                
        &#39;&#39;&#39;

        try:
                with open(self.config_file) as y:
                        file = yaml.load(y, Loader=yaml.SafeLoader)

                with open(file[&#39;mode_info_file&#39;]) as f:
                        modeInfo = yaml.load(f, Loader=yaml.SafeLoader)
        except:
                with open(&#39;config/CameraModeInfo.yaml&#39;) as y:
                        modeInfo = yaml.load(y, Loader=yaml.SafeLoader)


        print(&#34;Generating results for P0 Calibration...&#34;)

        P0_dir = os.path.join(CalibfolderName, file[&#39;P0Calibration&#39;][&#39;output_directory&#39;])
        P0_uncompressed_output = os.path.join(P0_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;])
        P0_compressed_output = os.path.join(P0_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;])

        # freqs = [198, 189, 54]

        if os.path.exists(P0_dir):
                P0_files = os.listdir(P0_dir)

                P0Table_modes = np.array([], dtype =np.int8)
                for P0_file in P0_files:
                        if P0_file.startswith(file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;]) and P0_file[-4:]==&#39;.pkl&#39;:
                                P0Table_modes = np.append(P0Table_modes, int(P0_file.split(&#39;_&#39;)[-1][:-4]))

                compressed_P0Table_modes = np.array([], dtype =np.int8)
                for P0_file in P0_files:
                        if P0_file.startswith(file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;]) and P0_file[-4:]==&#39;.pkl&#39;:
                                compressed_P0Table_modes = np.append(compressed_P0Table_modes, int(P0_file.split(&#39;_&#39;)[-1][:-4]))

                calibResult[&#39;P0&#39;] = dict()
                
                try:
                        P0_prelim = os.path.join(P0_dir, &#39;preliminaryTestResults.pkl&#39;)
                        f = open(P0_prelim, &#39;rb&#39;)
                        prelim = pickle.load(f)
                        f.close()
                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;] = dict()

                        for key,val in prelim.items():
                                calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;][key] = val

                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;] = True
                except:
                        calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;] = False

                if len(P0Table_modes) != 0:
                        calibResult[&#39;P0_pass&#39;] = True

                        if calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults_exists&#39;]:
                                calibResult[&#39;P0_pass&#39;] = calibResult[&#39;P0_pass&#39;] and calibResult[&#39;P0&#39;][&#39;PreliminaryTestResults&#39;][&#39;All_pass&#39;]

                        calibResult[&#39;P0_exists&#39;] = True

                        P0Table_modes = sorted(P0Table_modes)
                else:
                        calibResult[&#39;P0_pass&#39;] = False

                if len(compressed_P0Table_modes) != 0:
                        calibResult[&#39;comp_P0_exists&#39;] = True

                        compressed_P0Table_modes = sorted(compressed_P0Table_modes)


                if calibResult[&#39;P0_exists&#39;]:
                        

                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_0_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_1_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_4_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_5_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_7_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_10_exists&#39;] = False

                        print(&#34;--Generating P0 Table results...&#34;)
                        for m in P0Table_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_&#39; + str(m) + &#39;_exists&#39;] = True
                                f = open(P0_uncompressed_output + str(m) + &#39;.pkl&#39;, &#39;rb&#39;)
                                try:
                                        P0_tab = pickle.load(f)[&#39;P0Table&#39;]
                                except:
                                        P0_tab = pickle.load(f)

                                f.close()

                                freqs = modeInfo[&#39;mode&#39;][int(m)][&#39;freqsMhz&#39;]

                                P0_ax = np.zeros(len(freqs), dtype=object)
                                P0_img = np.zeros(len(freqs), dtype=object)

                                # P0_calib = P0.P0_calibration()

                                figureSize = 2*len(freqs)

                                fig = plt.figure(figsize=(15, figureSize))
                                for i in range(len(freqs)):
                                        P0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                        P0_img[i] = P0_ax[i].imshow(P0_tab[:,:,i])
                                        image2bin(P0_tab[:,:,i], os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;_&#39; + str(i)))
                                        plt.title(&#39;P0 table - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                        fig.colorbar(P0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                        P0_ax[i].autoscale(False)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0Table_uncompressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_uncompressed_pkl&#39;] + str(m) + &#39;.png&#39;)
                                del P0_tab

                verify_modes = np.array([], dtype =np.int8)
                # verify_dists = np.array([], dtype =np.int16)
                verify_AB_files = np.array([], dtype =object)
                verify_dist_files = np.array([], dtype =object)
                mean_frames_files = np.array([], dtype =object)

                for P0_file in P0_files:
                        if (&#39;AB&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                verify_modes = np.append(verify_modes, int(P0_file.split(&#39;_&#39;)[2]))
                                # verify_dists = np.append(verify_dists, int(P0_file.split(&#39;_&#39;)[-1][:-6]))
                                verify_AB_files = np.append(verify_AB_files, P0_file)

                        if (&#39;_freqDist&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                verify_dist_files = np.append(verify_dist_files, P0_file)

                        if (&#39;mean_frames&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                 mean_frames_files = np.append(mean_frames_files, P0_file)

                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_10_exists&#39;] = False

                print(&#34;--Generating P0 verification(depth) results...&#34;)

                if calibResult[&#39;P0_exists&#39;] and len(verify_modes)!= 0:
                        for m in verify_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_verify_mode_&#39; + str(m) +&#39;_exists&#39;] = True

                for dist_file in verify_dist_files:
                        ref_dist = float(dist_file.split(&#39;_&#39;)[-1][:-6])
                        ref_mode = int(dist_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, dist_file), &#39;rb&#39;)
                        dist = np.array(pickle.load(f))
                        f.close()

                        cw = int(np.shape(dist)[0] / 2)
                        ch = int(np.shape(dist)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_dist = np.zeros(len(freqs))
                        min_dist = np.zeros(len(freqs))
                        max_dist = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_dist[i] = np.round(np.nanmean(dist[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)
                                min_dist[i] = meanROI_dist[i] - 0.5*meanROI_dist[i]
                                max_dist[i] = meanROI_dist[i] + 0.5*meanROI_dist[i]
                                dist[:,:,i] = np.clip(dist[:,:,i], min_dist[i], max_dist[i])


                        dist[np.isnan(dist)] = 0

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(dist[:,:,i])
                                image2bin(dist[:,:,i], os.path.join(result_dir, dist_file[:-4] + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth w/P0- &#39; + str(freqs[i]) + &#39;Mhz (&#39; + str(ref_dist) + &#39;mm)&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_dist[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, dist_file[:-4] + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, dist_file[:-4] + &#39;.png&#39;)

                        # Depth error

                        DE_ax = np.zeros(len(freqs), dtype=object)
                        PE_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DE_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PE_img[i] = DE_ax[i].imshow(np.float(ref_dist) - dist[:,:,i])
                                image2bin(np.float(ref_dist) - dist[:,:,i], os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth error - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PE_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DE_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        # Depth error histogram

                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de = np.float(ref_dist) - dist[:,:,i]
                                de_hist = np.hstack(de.flatten())
                                if i&gt;0:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1, sharey=DEH_ax[0])
                                else:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;Depth error histogram - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)

                        plt.savefig(os.path.join(result_dir, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_dist_error_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        del dist


                print(&#34;--Generating P0 verification(AB) results...&#34;)
                for AB_file in verify_AB_files:
                        ref_mode = int(AB_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, AB_file), &#39;rb&#39;)
                        AB = pickle.load(f)
                        f.close()

                        cw = int(np.shape(AB)[0] / 2)
                        ch = int(np.shape(AB)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_AB = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_AB[i] = np.round(np.nanmean(AB[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(AB[:,:,i], vmin=0, vmax=2*meanROI_AB[i], cmap = &#39;gray&#39;)
                                image2bin(AB[:,:,i], os.path.join(result_dir, AB_file[:-4] + &#39;_&#39; + str(i)))
                                plt.title(&#39;AB - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_AB[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, AB_file[:-4] + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_AB_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, AB_file[:-4] + &#39;.png&#39;)



                        # AB histogram


                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de_hist = np.hstack(AB[:,:,i].flatten())
                                DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;AB histogram - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)

                        plt.savefig(os.path.join(result_dir, &#39;AB_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_verify_AB_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;AB_hist_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        del AB


                # COMPRESSED P0

                if calibResult[&#39;P0_exists&#39;] and calibResult[&#39;comp_P0_exists&#39;]:

                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_0_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_1_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_4_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_5_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_7_exists&#39;] = False
                        calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_10_exists&#39;] = False

                        print(&#34;--Generating P0 Table compressed results...&#34;)

                        for m in compressed_P0Table_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_compressed_mode_&#39; + str(m) + &#39;_exists&#39;] = True
                                f = open(P0_compressed_output + str(m) + &#39;.pkl&#39;, &#39;rb&#39;)
                                P0_RC = pickle.load(f)
                                f.close()

                                keys = list(P0_RC.keys())
                                n_freqs = 0
                                try:
                                        for i in range(len(keys)):
                                                if keys[i].startswith(&#39;freq&#39;):
                                                        n_freqs = n_freqs + 1
                                except:
                                        raise Exception(&#34;Invalid compressed P0 table&#34;)


                                # Row coefficients
                                # freqs = [198, 189, 54]
                                freqs = modeInfo[&#39;mode&#39;][int(m)][&#39;freqsMhz&#39;]
                                row_ax = np.zeros(n_freqs, dtype=object)
                                row_img = np.zeros(n_freqs, dtype=object)

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        row_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        row_img[i] = row_ax[i].plot(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0RowCoefs&#39;])
                                        plt.title(&#39;P0 Row Coeff - &#39; + str(freqs[i]) + &#39;Mhz&#39;)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_row_coeff&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_row_coeff_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_row_coeff&#39; + &#39;.png&#39;)

                                # Column efficients
                                col_ax = np.zeros(n_freqs, dtype=object)
                                col_img = np.zeros(n_freqs, dtype=object)

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        col_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        col_img[i] = col_ax[i].plot(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0ColCoefs&#39;])
                                        plt.title(&#39;P0 Col Coeff - &#39; + str(freqs[i]) + &#39;Mhz&#39;)

                                plt.savefig(os.path.join(result_dir, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_col_coeff&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_col_coeff_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_col_coeff&#39; + &#39;.png&#39;)

                                # Uncompressed-comprssed P0 Tables
                                dirname, base = os.path.split(P0_compressed_output)
                                fname_2D_P0 = os.path.join(dirname, &#39;un&#39;+base + str(m) + &#39;_2D_P0&#39; + &#39;.pkl&#39;)
                                try:    
                                        f = open(fname_2D_P0, &#39;rb&#39;)
                                        P0_2D = pickle.load(f)[&#39;P0Table&#39;]
                                        f.close()
                                except:
                                        if str(m) == &#39;10&#39;:
                                                fname_2D_P0 = os.path.join(dirname, &#39;un&#39;+base + str(5) + &#39;_2D_P0&#39; + &#39;.pkl&#39;)
                                        f = open(fname_2D_P0, &#39;rb&#39;)
                                        P0_2D = pickle.load(f)[&#39;P0Table&#39;]
                                        f.close()

                                cP0_ax = np.zeros(n_freqs, dtype=object)
                                cP0_img = np.zeros(n_freqs, dtype=object)

                                # P0_calib = P0.P0_calibration()

                                fig = plt.figure(figsize=(15, 6))
                                for i in range(n_freqs):
                                        cP0_ax[i] = fig.add_subplot(1, n_freqs, i+1)
                                        # matrix = P0_calib.Uncompress2Matrix(P0_RC[&#39;freq_&#39; + str(i)][&#39;P0RowCoefs&#39;], P0_RC[&#39;freq_&#39; + str(i)][&#39;P0ColCoefs&#39;])
                                        cP0_img[i] = cP0_ax[i].imshow(P0_2D[:,:,i])
                                        image2bin(P0_2D[:,:,i], os.path.join(result_dir, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;_&#39; + str(i)))
                                        plt.title(&#39;P0 compressed table - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                        fig.colorbar(cP0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                        cP0_ax[i].autoscale(False)

                                plt.savefig(os.path.join(result_dir, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;.png&#39;))
                                plt.close()
                                calibResult[&#39;P0&#39;][&#39;P0_2D_compressed_mode_&#39; + str(m)] = os.path.join(&#39;Results&#39;, &#39;un&#39;+file[&#39;P0Calibration&#39;][&#39;output_file_compressed_pkl&#39;] + str(m) + &#39;_2D_P0&#39; + &#39;.png&#39;)

                                del P0_2D


                print(&#34;--Generating P0 compressed verification(depth) results...&#34;)
                # P0 Compression verification
                comp_verify_modes = np.array([], dtype =np.int8)
                # verify_dists = np.array([], dtype =np.int16)
                comp_verify_dist_files = np.array([], dtype =object)
                residue_rad_files = np.array([], dtype =object)
                residue_mm_files = np.array([], dtype =object)

                for P0_file in P0_files:
                        if (&#39;_compressedfreqDist&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                comp_verify_modes = np.append(comp_verify_modes, int(P0_file.split(&#39;_&#39;)[2]))
                                comp_verify_dist_files = np.append(comp_verify_dist_files, P0_file)

                        if (&#39;residue_rad&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                residue_rad_files = np.append(residue_rad_files, P0_file)

                        if (&#39;residue_mm&#39; in P0_file) and P0_file[-4:]==&#39;.pkl&#39;:
                                residue_mm_files = np.append(residue_mm_files, P0_file)

                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_10_exists&#39;] = False

                if calibResult[&#39;P0_exists&#39;] and len(comp_verify_modes)!= 0:
                        for m in comp_verify_modes:
                                calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_mode_&#39; + str(m) +&#39;_exists&#39;] = True

                for dist_file in comp_verify_dist_files:
                        ref_dist = float(dist_file.split(&#39;_&#39;)[-1][:-6])
                        ref_mode = int(dist_file.split(&#39;_&#39;)[2])
                        f = open(os.path.join(P0_dir, dist_file), &#39;rb&#39;)
                        dist_comp = np.array(pickle.load(f))
                        f.close()

                        cw = int(np.shape(dist_comp)[0] / 2)
                        ch = int(np.shape(dist_comp)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]
                        
                        meanROI_dist = np.zeros(len(freqs))
                        min_dist = np.zeros(len(freqs))
                        max_dist = np.zeros(len(freqs))

                        for i in range(len(freqs)):
                                meanROI_dist[i] = np.round(np.nanmean(dist_comp[:,:,i][cw-5:cw+5,ch-5:ch+5]),4)
                                min_dist[i] = meanROI_dist[i] - 0.5*meanROI_dist[i]
                                max_dist[i] = meanROI_dist[i] + 0.5*meanROI_dist[i]
                                dist_comp[:,:,i] = np.clip(dist_comp[:,:,i], min_dist[i], max_dist[i])


                        dist_comp[np.isnan(dist_comp)] = 0

                        DWP0_ax = np.zeros(len(freqs), dtype=object)
                        PDW0_img = np.zeros(len(freqs), dtype=object)


                        figureSize = 2*len(freqs)+1

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DWP0_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PDW0_img[i] = DWP0_ax[i].imshow(dist_comp[:,:,i])
                                image2bin(dist_comp[:,:,i], os.path.join(result_dir, dist_file[:-4]+ &#39;_compressed&#39; + &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth w/comp_P0- &#39; + str(freqs[i]) + &#39;Mhz (&#39; + str(ref_dist) + &#39;mm)&#39;)
                                fig.colorbar(PDW0_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DWP0_ax[i].text(0.5,-0.4, &#34;Mean 10x10 ROI = &#34; + str(meanROI_dist[i]), size=8, ha=&#34;center&#34;, transform=DWP0_ax[i].transAxes)
                                DWP0_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, dist_file[:-4]+ &#39;_compressed&#39; + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, dist_file[:-4]+ &#39;_compressed&#39; + &#39;.png&#39;)

                        # Depth error


                        DE_ax = np.zeros(len(freqs), dtype=object)
                        PE_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                DE_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PE_img[i] = DE_ax[i].imshow(np.float(ref_dist) - dist_comp[:,:,i])
                                image2bin(np.float(ref_dist) - dist_comp[:,:,i], os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;_&#39; + str(i)))
                                plt.title(&#39;Depth error w/comp - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(PE_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                DE_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_mode_&#39; + str(ref_mode) + &#39;_compressed&#39;+ &#39;.png&#39;)

                        # Depth error histogram

                        DEH_ax = np.zeros(len(freqs), dtype=object)
                        PEH_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                de = np.float(ref_dist) - dist_comp[:,:,i]
                                de_hist = np.hstack(de.flatten())
                                if i&gt;0:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1,sharey=DEH_ax[0])
                                else:
                                        DEH_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                PEH_img[i] = DEH_ax[i].hist(de_hist, bins = &#39;auto&#39;)
                                plt.title(&#39;Depth error histogram w/comp - &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                DEH_ax[i].autoscale(True)


                        plt.savefig(os.path.join(result_dir, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;_compressed.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_comp_verify_dist_error_hist_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;depth_error_hist_mode_&#39; + str(ref_mode) + &#39;_compressed.png&#39;)

                        del dist_comp


                print(&#34;--Generating P0 residue results...&#34;)
                # Residue Radian
                for residue_rad_file in residue_rad_files:
                        residue_mode = int(residue_rad_file[:-4].split(&#39;_&#39;)[-1])
                        f = open(os.path.join(P0_dir, residue_rad_file), &#39;rb&#39;)
                        residue_rad = np.array(pickle.load(f))
                        f.close()

                        freqs = modeInfo[&#39;mode&#39;][int(residue_mode)][&#39;freqsMhz&#39;]

                        res_ax = np.zeros(len(freqs), dtype=object)
                        res_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                res_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                res_img[i] = res_ax[i].imshow(residue_rad[:,:,i])
                                image2bin(residue_rad[:,:,i], os.path.join(result_dir, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Residue in radian- &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(res_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                res_ax[i].autoscale(False)


                        plt.savefig(os.path.join(result_dir, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_residue_rad_mode_&#39; + str(residue_mode)]= os.path.join(&#39;Results&#39;, &#39;residue_rad_mode_&#39; + str(residue_mode) + &#39;.png&#39;)

                # Residue mm
                for residue_mm_file in residue_mm_files:
                        residue_mode = int(residue_mm_file[:-4].split(&#39;_&#39;)[-1])
                        f = open(os.path.join(P0_dir, residue_mm_file), &#39;rb&#39;)
                        residue_mm = np.array(pickle.load(f))
                        f.close()

                        freqs = modeInfo[&#39;mode&#39;][int(residue_mode)][&#39;freqsMhz&#39;]

                        res_ax = np.zeros(len(freqs), dtype=object)
                        res_img = np.zeros(len(freqs), dtype=object)

                        figureSize = 2*len(freqs)

                        fig = plt.figure(figsize=(15, figureSize))
                        for i in range(len(freqs)):
                                res_ax[i] = fig.add_subplot(1, len(freqs), i+1)
                                res_img[i] = res_ax[i].imshow(residue_mm[:,:,i])
                                image2bin(residue_mm[:,:,i], os.path.join(result_dir, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;_&#39; + str(i)))
                                plt.title(&#39;Residue in mm- &#39; + str(freqs[i]) + &#39;Mhz&#39;)
                                fig.colorbar(res_img[i], fraction=0.046, pad=0.08,  orientation=&#34;horizontal&#34;)
                                res_ax[i].autoscale(False)



                        plt.savefig(os.path.join(result_dir, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;.png&#39;))
                        plt.close()
                        calibResult[&#39;P0&#39;][&#39;P0Table_residue_mm_mode_&#39; + str(residue_mode)]= os.path.join(&#39;Results&#39;, &#39;residue_mm_mode_&#39; + str(residue_mode) + &#39;.png&#39;)


                # Mean frames

                print(&#34;--Generating P0 mean frames results...&#34;)
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_0_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_1_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_4_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_5_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_7_exists&#39;] = False
                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_10_exists&#39;] = False

                if calibResult[&#39;P0_exists&#39;] and len(mean_frames_files)!= 0:
                        for mean_file in mean_frames_files:
                                calibResult[&#39;P0&#39;][&#39;P0Table_mean_frames_mode_&#39; + str(mean_file.split(&#39;_&#39;)[3][:-4]) +&#39;_exists&#39;] = True
                                # print(&#39;P0Table_mean_frames_mode_&#39; + str(mean_file.split(&#39;_&#39;)[3][:-4]) +&#39;_exists&#39;)

                for mean_frames_file in mean_frames_files:
                        ref_mode = int(mean_frames_file.split(&#39;_&#39;)[3][:-4])
                        f = open(os.path.join(P0_dir, mean_frames_file), &#39;rb&#39;)
                        mean_frames = pickle.load(f)
                        f.close()

                        cw = int(np.shape(mean_frames)[0] / 2)
                        ch = int(np.shape(mean_frames)[1] / 2)

                        freqs = modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]

                        maxPhaseSteps = int(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;maxPhaseSteps&#39;])

                        mean_frames_center = np.zeros([len(freqs),maxPhaseSteps])
                        for i in range(len(freqs)):
                                mean_frames_center[i,:] = np.mean(mean_frames[cw, ch, i*3 : (i+1)*3, :], axis = 0)

                        del mean_frames

                        plt.figure()
                        for i in range(len(freqs)):
                                plt.plot(mean_frames_center[i,:], label=str(freqs[i])+&#34;Mhz&#34;)
                        # plt.plot(mean_frames_center[0,:], label=&#34;198Mhz&#34;)
                        # plt.plot(mean_frames_center[1,:], label=&#34;189Mhz&#34;)
                        # plt.plot(mean_frames_center[2,:], label=&#34;54Mhz&#34;)
                        plt.legend()
                        plt.xlabel(&#39;Phase&#39;)
                        plt.ylabel(&#39;Amplitude&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;Correlated_waveform_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

                        fft_mean_frames_center = np.zeros([len(freqs), int(maxPhaseSteps/2)])

                        for i in range(len(freqs)):
                                fft_mean_frames_center[i, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[i,:]))) / maxPhaseSteps
                        # fft_mean_frames_center[0, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[0,:]))) / 24
                        # fft_mean_frames_center[1, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[1,:]))) / 24
                        # fft_mean_frames_center[2, :] = generate_fft_waveform(np.abs(np.fft.fft(mean_frames_center[2,:]))) / 24

                        plt.figure()
                        for i in range(len(freqs)):
                                plt.plot(fft_mean_frames_center[i,:], label=str(freqs[i])+&#34;Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[0, :], label=&#34;198Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[1, :], label=&#34;189Mhz&#34;)
                        # plt.plot(fft_mean_frames_center[2, :], label=&#34;54Mhz&#34;)
                        plt.legend()
                        plt.yscale(&#39;log&#39;)
                        plt.xlabel(&#39;Phase&#39;)
                        plt.ylabel(&#39;Amplitude&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;fft_Correlated_waveform_mode_&#39; + str(ref_mode) + &#39;.png&#39;)
                        plt.close()

                        for i in range(len(freqs)):
                                calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_&#39;+str(int(freqs[i]))+&#39;Mhz&#39;] = (fft_mean_frames_center[i, 1] / fft_mean_frames_center[i, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_198Mhz&#39;] = (fft_mean_frames_center[0, 1] / fft_mean_frames_center[0, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_189Mhz&#39;] = (fft_mean_frames_center[1, 1] / fft_mean_frames_center[1, 0]) / (4/np.pi) * 100
                        # calibResult[&#39;P0&#39;][&#39;Modulation_efficiency_mode_&#39; + str(ref_mode) + &#39;_54Mhz&#39;] = (fft_mean_frames_center[2, 1] / fft_mean_frames_center[2, 0]) / (4/np.pi) * 100


                        # dist_range = np.linspace(0, 5, 1000)
                        # n_dist = len(dist_range)
                        # # freqs = [198e6, 189e6, 54e6]
                        # freqs = np.array(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;]) * 1e6
                        # n_freqs = len(freqs)

                        # cn = np.zeros([n_freqs, maxPhaseSteps])
                        # cn = np.fft.fftshift(np.fft.fft(mean_frames_center) / maxPhaseSteps)

                        # # Nh = 12
                        # # nh = np.arange(-12, 12)
                        # Nh = int(maxPhaseSteps/2)
                        # nh = np.arange(-int(maxPhaseSteps/2), int(maxPhaseSteps/2))
                        # # [t,
                        # #  yt] = synthesize_waveform_from_fourier_coefficients(nh, cn[0, :], freqs[0],
                        # #                                                      10e9, 0, 3 / freqs[0])

                        # V0 = np.zeros([n_freqs, n_dist])
                        # V120 = np.zeros([n_freqs, n_dist])
                        # V240 = np.zeros([n_freqs, n_dist])

                        # for ii, f in enumerate(freqs):

                        #     for jj, dist in enumerate(dist_range):
                        #         # Generate laser waveforms harmonics
                        #         T_cycle = 1 / f
                        #         dt = dist * 2 / c / T_cycle * 2 * pi

                        #         # Sample correlation
                        #         V0[ii, jj] = sample_correlation(nh, cn[ii, :], +dt)
                        #         V120[ii, jj] = sample_correlation(nh, cn[ii, :], 2 * pi / 3 + dt)
                        #         V240[ii, jj] = sample_correlation(nh, cn[ii, :], 4 * pi / 3 + dt)

                        # re = 2 * V0 - V120 - V240
                        # im = np.sqrt(3) * (V240 - V120)
                        # C = re + 1j * im
                        # # # Calculate estimate distance assuming perfect unwrapping
                        # # est_dist_0 = c / (4 * pi * freqs[0]) * np.unwrap(np.angle(C[0, :]))
                        # # est_dist_1 = c / (4 * pi * freqs[1]) * np.unwrap(np.angle(C[1, :]))
                        # # est_dist_2 = c / (4 * pi * freqs[2]) * np.unwrap(np.angle(C[2, :]))

                        # # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
                        # # P0_dist = ref_dist / 1000.00
                        # # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()
                        # # est_dist_0 -= est_dist_0[dist_idx_P0] - P0_dist
                        # # est_dist_1 -= est_dist_1[dist_idx_P0] - P0_dist
                        # # est_dist_2 -= est_dist_2[dist_idx_P0] - P0_dist

                        # # # Weighted sum for final distance calculation
                        # # est_dist = est_dist_0 * freqs[0]**2 / np.sum(
                        # #     np.array(freqs)**2) + est_dist_1 * freqs[1]**2 / np.sum(
                        # #         np.array(freqs)**2) + est_dist_2 * freqs[2]**2 / np.sum(
                        # #             np.array(freqs)**2)

                        # est_dist_n = np.zeros(n_freqs, dtype=object)
                        # # Calculate estimate distance assuming perfect unwrapping
                        # for i in range(n_freqs):
                        #       est_dist_n[i] = c / (4 * pi * freqs[i]) * np.unwrap(np.angle(C[i, :]))

                        # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
                        # P0_dist = ref_dist / 1000.00
                        # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()

                        # for i in range(n_freqs):
                        #       est_dist_n[i] -= est_dist_n[i][dist_idx_P0] - P0_dist

                        # # Weighted sum for final distance calculation
                        # est_dist = np.zeros(np.shape(est_dist_n[0]))
                        # for i in range(n_freqs):
                        #       est_dist = est_dist + est_dist_n[i] * freqs[i]**2 / np.sum(np.array(freqs)**2)

                        freqMhzArray = np.array(modeInfo[&#39;mode&#39;][int(ref_mode)][&#39;freqsMhz&#39;])

                        est_dist_err = estimate_distance(mean_frames_center, freqMhzArray, maxPhaseSteps, ref_dist)
                        dist_range = np.linspace(0, 5, 1000)

                        plt.figure()
                        plt.plot(dist_range, est_dist_err * 1000)
                        plt.xlabel(&#39;Distance [m]&#39;)
                        plt.ylabel(&#39;Depth estimation error [mm]&#39;)
                        plt.grid()
                        plt.savefig(os.path.join(result_dir, &#39;Estimated_depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;))
                        calibResult[&#39;P0&#39;][&#39;Estimated_depth_error_mode_&#39; + str(ref_mode)]= os.path.join(&#39;Results&#39;, &#39;Estimated_depth_error_mode_&#39; + str(ref_mode) + &#39;.png&#39;)

        return calibResult</code></pre>
</details>
</dd>
<dt id="P0_results.estimate_distance"><code class="name flex">
<span>def <span class="ident">estimate_distance</span></span>(<span>mean_frames_center, freqs, maxPhaseSteps, ref_dist)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the distance given mean frames, i,e frames averaged for
phase steps <br>
Inputs:
mean_frames_center
- 2D array of mean frames<br>
freqs
- Array of frequencies <br>
maxPhaseSteps
- Maximum phase steps
</p>
<pre><code>    Outputs: 
            estimated_dist_error
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_distance(mean_frames_center, freqs, maxPhaseSteps, ref_dist):
        &#39;&#39;&#39;
        Estimates the distance given mean frames, i,e frames averaged for 
        phase steps   
                Inputs: 
                        mean_frames_center   - 2D array of mean frames  
                        freqs                - Array of frequencies   
                        maxPhaseSteps        - Maximum phase steps  

                Outputs: 
                        estimated_dist_error  
        &#39;&#39;&#39;

        dist_range = np.linspace(0, 5, 1000)
        n_dist = len(dist_range)
        # freqs = [198e6, 189e6, 54e6]
        freqs = np.array(freqs) * 1e6
        n_freqs = len(freqs)

        cn = np.zeros([n_freqs, maxPhaseSteps])
        cn = np.fft.fftshift(np.fft.fft(mean_frames_center) / maxPhaseSteps)

        # Nh = 12
        # nh = np.arange(-12, 12)
        Nh = int(maxPhaseSteps/2)
        nh = np.arange(-int(maxPhaseSteps/2), int(maxPhaseSteps/2))
        # [t,
        #  yt] = synthesize_waveform_from_fourier_coefficients(nh, cn[0, :], freqs[0],
        #                                                      10e9, 0, 3 / freqs[0])

        V0 = np.zeros([n_freqs, n_dist])
        V120 = np.zeros([n_freqs, n_dist])
        V240 = np.zeros([n_freqs, n_dist])

        for ii, f in enumerate(freqs):
                for jj, dist in enumerate(dist_range):
                        # Generate laser waveforms harmonics
                        T_cycle = 1 / f
                        dt = dist * 2 / c / T_cycle * 2 * pi

                        # Sample correlation
                        V0[ii, jj] = sample_correlation(nh, cn[ii, :], +dt)
                        V120[ii, jj] = sample_correlation(nh, cn[ii, :], 2 * pi / 3 + dt)
                        V240[ii, jj] = sample_correlation(nh, cn[ii, :], 4 * pi / 3 + dt)

        re = 2 * V0 - V120 - V240
        im = np.sqrt(3) * (V240 - V120)
        C = re + 1j * im
        # # Calculate estimate distance assuming perfect unwrapping
        # est_dist_0 = c / (4 * pi * freqs[0]) * np.unwrap(np.angle(C[0, :]))
        # est_dist_1 = c / (4 * pi * freqs[1]) * np.unwrap(np.angle(C[1, :]))
        # est_dist_2 = c / (4 * pi * freqs[2]) * np.unwrap(np.angle(C[2, :]))

        # # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
        # P0_dist = ref_dist / 1000.00
        # dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()
        # est_dist_0 -= est_dist_0[dist_idx_P0] - P0_dist
        # est_dist_1 -= est_dist_1[dist_idx_P0] - P0_dist
        # est_dist_2 -= est_dist_2[dist_idx_P0] - P0_dist

        # # Weighted sum for final distance calculation
        # est_dist = est_dist_0 * freqs[0]**2 / np.sum(
        #     np.array(freqs)**2) + est_dist_1 * freqs[1]**2 / np.sum(
        #         np.array(freqs)**2) + est_dist_2 * freqs[2]**2 / np.sum(
        #             np.array(freqs)**2)

        est_dist_n = np.zeros(n_freqs, dtype=object)
        # Calculate estimate distance assuming perfect unwrapping
        for i in range(n_freqs):
                est_dist_n[i] = c / (4 * pi * freqs[i]) * np.unwrap(np.angle(C[i, :]))

        # Apply &#34;P0 calibration&#34; the distance measurement of each frequency
        P0_dist = ref_dist / 1000.00
        dist_idx_P0 = (np.abs(dist_range - P0_dist)).argmin()

        for i in range(n_freqs):
                est_dist_n[i] -= est_dist_n[i][dist_idx_P0] - P0_dist

        # Weighted sum for final distance calculation
        est_dist = np.zeros(np.shape(est_dist_n[0]))
        for i in range(n_freqs):
                est_dist = est_dist + est_dist_n[i] * freqs[i]**2 / np.sum(np.array(freqs)**2)

        return est_dist - dist_range</code></pre>
</details>
</dd>
<dt id="P0_results.generate_fft_waveform"><code class="name flex">
<span>def <span class="ident">generate_fft_waveform</span></span>(<span>fft_array)</span>
</code></dt>
<dd>
<div class="desc"><p>fft_array : 1D array containing fft
Output : FFT with positive and negative components added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_fft_waveform(fft_array):
        &#34;&#34;&#34;
        fft_array : 1D array containing fft 
        Output : FFT with positive and negative components added 
        &#34;&#34;&#34;
        fft_array2 = np.append(fft_array, [0])[::-1][:-1]
        return (fft_array + fft_array2)[:int(len(fft_array)/2)]</code></pre>
</details>
</dd>
<dt id="P0_results.image2bin"><code class="name flex">
<span>def <span class="ident">image2bin</span></span>(<span>image, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a 2D matrix in bin format
Inputs:
image:
2D matrix
fname:
name of file to be saved </p>
<p>Outputs:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image2bin(image, fname):
        &#34;&#34;&#34;
        Saves a 2D matrix in bin format 
        Inputs: 
                image:    2D matrix 
                fname:    name of file to be saved 

        Outputs: 
                none 
        &#34;&#34;&#34;

        tmp = np.squeeze(np.array(image, dtype=np.float32))
        (h,w) = np.shape(tmp)
        tmp_flattened = tmp.flatten()
        write_file = open(fname +&#39;--&#39;+str(h)+&#39;x&#39;+str(w) +&#39;.bin&#39;, &#34;wb&#34;)
        tmp_flattened.tofile(write_file, format=&#39;%f&#39;)</code></pre>
</details>
</dd>
<dt id="P0_results.sample_correlation"><code class="name flex">
<span>def <span class="ident">sample_correlation</span></span>(<span>nh, cn, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>nh: harmonic indexes
cn: Fourier coefficients
phase: phase at which to sample correlation (in radian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_correlation(nh, cn, phase):
    &#34;&#34;&#34;
    nh: harmonic indexes 
    cn: Fourier coefficients 
    phase: phase at which to sample correlation (in radian) 
    &#34;&#34;&#34;

    # Inverse Fourier transform
    V = 0
    for ii in range(len(nh)):
        V += cn[ii] * np.exp(1j * phase * nh[ii])

    # Return correlation sample
    return (np.real(V))</code></pre>
</details>
</dd>
<dt id="P0_results.synthesize_waveform_from_fourier_coefficients"><code class="name flex">
<span>def <span class="ident">synthesize_waveform_from_fourier_coefficients</span></span>(<span>nh, cn, f_fund, Fs, t_start, t_end)</span>
</code></dt>
<dd>
<div class="desc"><p>nh: harmonic indexes
cn: Fourier coefficients
f_fund: frequency of fundamental
Fs: sampling frequency
t_start: start time
t_end: end time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synthesize_waveform_from_fourier_coefficients(nh, cn, f_fund, Fs, t_start,
                                                  t_end):
    &#34;&#34;&#34;
    nh: harmonic indexes 
    cn: Fourier coefficients 
    f_fund: frequency of fundamental 
    Fs: sampling frequency 
    t_start: start time 
    t_end: end time 
    &#34;&#34;&#34;

    # Sampling period
    Ts = 1 / Fs

    # Sample times
    t = np.arange(t_start, t_end, Ts)

    # Harmonic frequencies
    fh = nh * f_fund

    # Inverse Fourier transform
    yt = np.zeros(t.shape, dtype=&#39;complex&#39;)
    for ii in range(len(fh)):
        yt += cn[ii] * np.exp(1j * t * 2 * pi * fh[ii])

    # Return time stamps and waveform
    return ([t, yt])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="P0_results.add_results_P0" href="#P0_results.add_results_P0">add_results_P0</a></code></li>
<li><code><a title="P0_results.estimate_distance" href="#P0_results.estimate_distance">estimate_distance</a></code></li>
<li><code><a title="P0_results.generate_fft_waveform" href="#P0_results.generate_fft_waveform">generate_fft_waveform</a></code></li>
<li><code><a title="P0_results.image2bin" href="#P0_results.image2bin">image2bin</a></code></li>
<li><code><a title="P0_results.sample_correlation" href="#P0_results.sample_correlation">sample_correlation</a></code></li>
<li><code><a title="P0_results.synthesize_waveform_from_fourier_coefficients" href="#P0_results.synthesize_waveform_from_fourier_coefficients">synthesize_waveform_from_fourier_coefficients</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>