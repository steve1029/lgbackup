<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>CalibAPI API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CalibAPI</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
#
# Copyright (c) 2020 Analog Devices, Inc. All Rights Reserved.   
# This software is proprietary to Analog Devices, Inc. and its licensors.  
#

import cv2
import numpy as np
import csv
import time
import sys
import matplotlib.pyplot as plt
from datetime import datetime
import pickle
import os
import yaml
try:
    from . import GenerateLSDACBlock as LSDAC
except:
    import GenerateLSDACBlock as LSDAC
import logging
from datetime import datetime
from scipy import ndimage

#DEBUG - add delay after reading frame
debug_delay = 0.01

# sys.path.append(&#34;./ADI_FG/TOFI-93/ardacho_fpga/test/device_python_wrapper/src/&#34;)
sys.path.append(&#34;./aditofdevicepython/&#34;) 

# import ArdachoIOLib.ArdachoIOLib as ArdachoIOLib
import aditofdevicepython as tofdevice
from struct import *

# GPIO definitions
CAM_RESET_N = 79
MPSOC_SYNC_DIR = 77
MPSOC_SYNC_DIR1 = 169
GPIO_CAM_FSYNC = 170
MPSOC_SYNC_SEL0 = 75
MPSOC_SYNC_SEL1 = 76

LMZ_EN = 83
PS_V5VVPS3 = 69
PP_DEPTH = 85
PS_VAUXVPS1 = 67
PS_VAUXVPS2 = 68
DEPTH_VAUX_RUN = 84
CAM_SHUTDOWN_N =64

I2C_MALKA = 0       
I2C_MODULE = 1      # Mainly used for the temp sensor and Archer driver

#AD5593R ID and DAC Selection

AD5593R_ID = 0x11
AD5593R_DAC_SET = 0x10
VAUX_ADJ = 0x01


# Power Monitor Ids
VSYS_DEV_ID = 0x44
VMAIN_DEV_ID = 0x42
VAUX_DEV_ID = 0x41
VDEPTH_DEV_ID = 0x40
TEMP_SENSE_ID = 0x48
TEMP_REG = 0

s1 = np.array([ 0x0100,
                0x0102,
                0x0104,
                0x0106,
                0x0108,
                0x010a,
                0x010c,
                0x010e,
                0x0110,
                0x0116,
                0x011a,
                0x011c,
                0x0122,
                0x012a,
                0x012c,
                0x012e,
                0x0130,
                0x0134,
                0x0136,
                0x0138,
                0x014c,
                0x014e,
                0x0154,
                0x0156,
                0x0158,
                0x015a,
                0x015c,
                0x015e,
                0x0160,
                0x0184,
                0x0192], dtype=np.uint16)

s2 = np.array([ 0x0162,
                0x016a,
                0x016c,
                0x016e,
                0x0170,
                0x0172], dtype=np.uint16)

# ADSD3000 - Laser Driver Definitions
ADSD3000_ID = 0x64

adsd3000_config = np.array([[0x0404, 0x0001],
                            [0x0002, 0x0025],
                            [0x0404, 0x0001],
                            [0x0003, 0x2478],
                            [0x0002, 0x0022],
                            [0x0404, 0x0001],
                            [0x000D, 0x00E0],
                            [0x000E, 0x07C0],
                            [0x0004, 0x9701],
                            [0x0060, 0xA808],
                            [0x0005, 0x00F4],
                            [0x0006, 0x0000],
                            [0x0013, 0x0008],
                            [0x0002, 0x002C]],dtype=np.uint16)

# Addr      Data
# 0404       0001
# 0002       0025
# 0404       0001
# 0003       2400
# 0002       0022
# 0404       0001
# 000E       07CB
# 0004       972F
# 0060       A808 (readback value is 8808)
# 0002       002C (enable internal SYNC, external SYNC use 0024)




def ICQtest(measurement, test_min, test_max):
    &#34;&#34;&#34;
    Computes whether a test has passed or failed
    Inputs:
        measurement: measured value  
        test_min: minimum limit  
        test_max: maximum limit  

    Outputs:
        ret: status of test in string  
        tests_failed: status of test in boolean  

    &#34;&#34;&#34;
    if(measurement&gt;test_min and measurement&lt;test_max):
        ret = &#34;PASSED&#34;
        tests_failed = 0
    else:
        ret = &#34;FAILED&#34;
        tests_failed = 1
    return ret, tests_failed


class CalibAPI:

    def __init__( self, module_class = &#34;Legacy&#34;, n_modes_cfg = 10, debug = False):
        &#34;&#34;&#34;Class constructor
        
        :returns: None  
        :rtype: None  
        &#34;&#34;&#34;
        print(&#34;module class = &#34; + str(module_class))
        self.bProgrammed = False
        self.Mode = 3
        self.width = 1024
        self.height =1024
        self.subFrames = 1
        self._debug = debug
        self.fps = 30
        self.module_class = module_class
        self.rawImage = np.zeros( (self.height, self.width, self.subFrames), dtype = np.int16)
        self.pRAW = np.zeros( (self.height, self.width * self.subFrames), dtype = np.int16)
        self.rawN = np.zeros( [100, (self.height* self.width * self.subFrames)], dtype = np.int16)
        self.unwrappedDepth = np.zeros( (self.height, self.width), dtype = np.double)
        self.nPhases = 0
        self.nFreq = 0
        self.freqs = []
        # self.dev = ArdachoIOLib.ArdachoIOLib() #IOLib.tof_device() $$
        self.dev = tofdevice.tof_device()
        self.dac_amptest0 = 255
        self.dac_amptest1 = 182
        self.dac_cmref = 255
        self.firstStart = True
        self.flag = 0
        self.prevVoltage = 0
        self.origSetting = dict()
        self.origSetting[&#39;reg&#39;] = dict()
        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.array([],dtype=np.uint16)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.array([],dtype=np.uint16)
        self.n_modes_cfg = n_modes_cfg


    def __del__(self):
        &#34;&#34;&#34;Class destructor, deinitializes the camera.
        
        :returns: None  
        :rtype: None  
        &#34;&#34;&#34;
        self.Stop()

        ret = self.sensorPowerDown()
        if( ret &lt; 0):
            print(&#34;Error during sensor power down. Please restart your system&#34;)       

    def error_assert(self, var, message):
        &#34;&#34;&#34;
        Raises error if the test has failed with a message
        Inputs:
            var: status of test  
            message: error message to display  
        Outputs:
            none  

        &#34;&#34;&#34;
        if var == False:
            raise Exception(message)
            try:
                logging.error(message)
            except:
                pass


    def Start( self):
        &#34;&#34;&#34;
        Command to start the camera. First checks if the microsequencer
        has started.
        Inputs:
            none  

        Outputs:
            none  

        &#34;&#34;&#34;
        self.dev.writeSPISingle( 0x000C, 0x00C5)
        time.sleep(0.1) #Delay required for useq
        
        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))
            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                time.sleep(0.5)
                data = self.dev.readSPISingle( 0x0256,1 )
                data = data[0]
                print(&#34;data retry = &#34; + hex(data))
                if( data == 0x02):
                    print(&#34;uSeq running&#34;)
                    break
                else:
                    errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                    print( &#34;Error = &#34; + hex(errorCode))
                
        if( errorCode != 0x0 or data == 0x00):
            sys.exit()
        
        self.dev.startSensor()
      
        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)


    def Stop(self):
        &#34;&#34;&#34;
        Command to stop the camera
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;
        i = 0
        
        # self.dev.setGpio( MPSOC_SYNC_SEL0, 0)
        # self.dev.setGpio( MPSOC_SYNC_SEL1, 0)
        # self.dev.setGpio( MPSOC_SYNC_DIR, 0)
        # self.dev.setGpio( 171, 0) # external (0) / internal (1) sync source

        # self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # Gpio manual control
        # self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
        

        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.1)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stoping camera&#34;)
        print(&#34;CAMERA STOPPED&#34;)




    def Init( self, Mode=3, fps=30, cfg = &#34;&#34;):
        &#34;&#34;&#34;
        Initializes the image sensor.
        
        Inputs:
            Mode: sensor mode (0-10) 
            fps: maximum fps of the image stream 
            cfg: path to .cfg file 

        Outputs:
            0 if successful
        &#34;&#34;&#34;
        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        
        &#39;&#39;
        # 
        # self.dev.setGpio( MPSOC_SYNC_SEL0, 1)
        # self.dev.setGpio( MPSOC_SYNC_SEL1, 1)
        
        # SyncMaster = 1
        # SyncSlave = 0
        # syncSel = SyncMaster
        # self.dev.setGpio( 171, syncSel) # mux2 sel signal : external (0) / internal (1) sync source
        # self.dev.setGpio( MPSOC_SYNC_DIR, syncSel) # snl74 direction signal: external (0) / internal (1) sync source

        # #self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # timer (0) / GPIO (1) internal sync
        # #self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
        # 
        self.dev.setSyncMode( 0, 0) # external , external sync 1v8

        #self.dev.setSyncMode( 0, 0)

        ret = self.sensorPowerUp()
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()


        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate( self.fps)

        print(cfg)
        time.sleep(1)
        self.dev.programCfg(cfg)

        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)

        self.Start()

        return 0


    def ConnectSensor(self, Mode=3, fps=10, cfg = &#34;&#34;):
        &#34;&#34;&#34;
        Command to connect to sensor - powerup the device, set mode, set fps,
        and program cfg file
        Inputs:
            mode: camera mode 
            fps: frames per second 
            cfg: location of .cfg file 

        Outputs:
            none

        &#34;&#34;&#34;
        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        
        ret = self.sensorPowerUp()
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()


        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate( self.fps)

        # print(&#34;Config_1000.00_3p6A_66p_Ofilm.cfg&#34;)
        # time.sleep(3)

        
        print(cfg)
        logging.info(&#39;Loading cfg file: &#39; + cfg)
        time.sleep(0.5)
        self.dev.programCfg(cfg)
        # self.programCSV(&#34;process_data_Legacy_p.csv&#34;)

        if (self.module_class == &#39;Walden_R1&#39;):         # MZ: If Walden module then invert the LSMOD control register in ADSD3100
            self.InvertLSMOD()

        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)


    def testtestwrite(self,addr,val):
        &#34;&#34;&#34;
        Test a register write
        Inputs:
            addr: address in hex or decimal 
            val: value in hex or decimal 

        Outputs:
            none

        &#34;&#34;&#34;
        self.dev.writeSPISingle(addr, val)


    def DisconnectSensor(self):
        &#34;&#34;&#34;
        Command to disconnect sensor. Stop camera and powerdown.
        Inputs:
            none  

        Outputs:
            none  

        &#34;&#34;&#34;
        i = 0
        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.1)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stoping camera&#34;)
        print(&#34;CAMERA STOPPED&#34;)
        ret = self.sensorPowerDown()
        if( ret &lt; 0):
            print(&#34;Error during sensor power down. Please restart your system&#34;)



    def StartSensor(self):
        &#34;&#34;&#34;
        Command to start sensor. Needs ConnectSensor() to be run before.
        Starts capturing of raw data.
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;

        # Send start command to camera
        self.dev.writeSPISingle( 0x000C, 0x00C5)

        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))
            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                print( &#34;Error = &#34; + hex(errorCode))

        if( errorCode != 0x0 or data == 0x00):
            sys.exit()

        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)
        self.dev.startSensor()

        return 0

    def QuickStartSensor(self):
        &#34;&#34;&#34;
        Command to start sensor without checks
        Inputs:
            none 
        Outputs:
            none 

        &#34;&#34;&#34;
        self.dev.startSensor()
        if self.firstStart == True:
            self.dev.writeSPISingle( 0x000C, 0x00C5)
            self.firstStart = False
        else:
            self.dev.writeSPISingle( 0x000C, 0x0001)
        val = 1
        i = 0
        while (val != 0 and i &lt; 10):
            time.sleep(0.01)
            val = self.dev.readSPISingle(0x000C, 1)
            i = i + 1
        
        self.bProgrammed = True



    def StopSensor(self):
        &#34;&#34;&#34;
        Command to stop sensor.
        Inputs:
            none

        Outputs:
            none

        &#34;&#34;&#34;
        i = 0
        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.01)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stopping camera&#34;)

    def QuickStopSensor(self):
        &#34;&#34;&#34;
        Command to stop sensor without checks 
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;
        # self.dev.stopSensor()
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        i=0
            
        while( regData[0] != 0x0 and i&lt;20):
            time.sleep(0.01)
            regData = self.dev.readSPISingle( 0x000C, 1)
            i = i + 1
        if( i == 20):
            print(&#34;Error stopping camera&#34;)

        self.dev.stopSensor()



    def regread(self, addr, length=1):
        &#34;&#34;&#34;
        Read a register. If address lies between 0x0E00 and 0x0EFE,
        writes 0x0000 to 0x0014 beforehand.
        Inputs:
            addr: register address in hex or decimal 
            length: number of registers to read 

        Outputs:
            register value 

        &#34;&#34;&#34;
        if addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
            self.dev.writeSPISingle(0x0014, 0x0000)
            # print(&#39;did 0014&lt;-0000&#39;)

        if length == 1 or length == &#39;&#39;:
            return self.dev.readSPISingle(addr, 1)[0]
        else:
            return self.dev.readSPISingle(addr, length)

    def regwrite(self, addr, val, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Write to a register. If address lies between 0x0E00 and 0x0EFE,
        writes 0x0000 to 0x0014 beforehand.
        Inputs:
            addr: register address in hex or decimal 
            val: register value in hex or decimal 

        Outputs:
            status of write 

        &#34;&#34;&#34;
        #print(val , &#39;writing to&#39;, addr)
        if mode == &#39;&#39;:
            if isinstance(val, np.uint16) or isinstance(val, int):
                #print(&#39;stage1&#39;)
                if (addr in s1) or (addr in s2): # Analog registers
                    status = 0xFFFF
                    i = 10
                    while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                        status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                        #print(&#39;status1--&gt;&#39;,status)
                        i = i - 1
                    self.dev.writeSPISingle(addr, val)
                    if addr in s1:
                        self.dev.writeSPISingle(0x0150, 0x0105)
                        #print(&#39;sdsdsdf&#39;)
                    else:
                        self.dev.writeSPISingle(0x0150, 0x0501)
                    status = 0xFFFF
                    i = 10
                    while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                        status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                        #print(&#39;status2--&gt;&#39;,status)
                        i = i - 1
                
                elif addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
                    self.dev.writeSPISingle(0x0014, 0x0000)
                    #print(&#39;did 0014&lt;-0000&#39;)
                    self.dev.writeSPISingle(addr, val)

                else:
                    self.dev.writeSPISingle(addr, val)
                # ret_val = self.dev.readSPISingle(addr, 1)[0]
                return True
            else:
                self.dev.writeSPISingle(addr, val)
                return True

        elif mode == &#39;ignore&#39;:
            self.dev.writeSPISingle(addr, val)
            return True

        else:
            return False

    def testBoardADC(self):
        &#34;&#34;&#34;
        Function to check if the onboard ADC is functioning correctly
        Inputs:
            none 

        Outputs:
            status: staus of the test 

        &#34;&#34;&#34;
        print(&#39;Testing Board ADC...&#39;)
        try:
            logging.info(&#39;Testing Board ADC...&#39;)
        except:
            pass

        success = self.dac_amptest0_set(158)
        self.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
        success = self.dac_amptest1_set(205)
        self.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
        success = self.dac_cmref_set(255)
        self.error_assert(success, &#34;Cannot set dac_cmref&#34;)
        loop = 1
        status = False
        while(not(status) and loop &lt;= 10):
            b1 = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
            print(&#34;Attempt&#34;, loop)
            print(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
            try:
                logging.info(&#34;Attempt &#34; + str(loop))
                logginh.info(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
            except:
                pass

            if b1 &gt; 0.35 and b1 &lt; 0.6:
                status = True
            loop = loop + 1

        if status:
            print(&#39;Board ADC working correctly&#39;)
            try:
                logging.info(&#39;Board ADC working correctly&#39;)
            except:
                pass

        if status == False:
            raise Exception(&#34;ERROR: Either DACwithSF_AMPTEST1-AMPTEST0 or onboard ADC is incorrect&#34;)

        return status


    def ICQSensorPowerUp(self, tests_failed, limits = None, ICQ_dict=None):
        &#34;&#34;&#34;
        Implements ICQ + sensor initialization sequence enabling the power regulators 
            and making functional checks.
        Inputs:
            tests_failed: number of tests failed before the startup 
            limits: minimum and maximum thresholds 
            ICQ_dist: results of the tests done prior 

        Outputs:
            0
            ICQ_dict: result of the powerup 
            tests_failed: number of tests failed 

        &#34;&#34;&#34;
        global Vmain_pre_test
        global Vmain_static_test
        global Vmain_on_test
        global Vsys_pre_test
        global Vsys_static_test
        global Vsys_on_test
        global Vdepth_pre_test
        global Vdepth_static_test
        global Vdepth_on_test
        global Vaux_pre_test
        global Vaux_static_test
        global Vaux_on_test
        global Imain_pre_test
        global Imain_static_test
        global Imain_on_test
        global Isys_pre_test
        global Isys_static_test
        global Isys_on_test
        global Idepth_pre_test
        global Idepth_static_test
        global Idepth_on_test
        global Iaux_pre_test
        global Iaux_static_test
        global Iaux_on_test

        Vmain_pre_min = limits[&#39;Vmain_pre&#39;][0] #Vmain can&#39;t be disabled currently
        Vmain_pre_max = limits[&#39;Vmain_pre&#39;][1]
        Imain_pre_min = limits[&#39;Imain_pre&#39;][0]
        Imain_pre_max = limits[&#39;Imain_pre&#39;][1]
        Vsys_pre_min = limits[&#39;Vsys_pre&#39;][0]
        Vsys_pre_max = limits[&#39;Vsys_pre&#39;][1]
        Isys_pre_min = limits[&#39;Isys_pre&#39;][0]
        Isys_pre_max = limits[&#39;Isys_pre&#39;][1]
        Vdepth_pre_min = limits[&#39;Vdepth_pre&#39;][0]
        Vdepth_pre_max = limits[&#39;Vdepth_pre&#39;][1]
        Idepth_pre_min = limits[&#39;Idepth_pre&#39;][0]
        Idepth_pre_max = limits[&#39;Idepth_pre&#39;][1]
        Vaux_pre_min = limits[&#39;Vaux_pre&#39;][0]
        Vaux_pre_max = limits[&#39;Vaux_pre&#39;][1]
        Iaux_pre_min = limits[&#39;Iaux_pre&#39;][0]
        Iaux_pre_max = limits[&#39;Iaux_pre&#39;][1]

        Vmain_static_min = limits[&#39;Vmain_static&#39;][0]
        Vmain_static_max = limits[&#39;Vmain_static&#39;][1]
        Imain_static_min = limits[&#39;Imain_static&#39;][0]
        Imain_static_max = limits[&#39;Imain_static&#39;][1]
        Vsys_static_min = limits[&#39;Vsys_static&#39;][0]
        Vsys_static_max = limits[&#39;Vsys_static&#39;][1]
        Isys_static_min = limits[&#39;Isys_static&#39;][0]
        Isys_static_max = limits[&#39;Isys_static&#39;][1]
        Vdepth_static_min = limits[&#39;Vdepth_static&#39;][0]
        Vdepth_static_max = limits[&#39;Vdepth_static&#39;][1]
        Idepth_static_min = limits[&#39;Idepth_static&#39;][0]
        Idepth_static_max = limits[&#39;Idepth_static&#39;][1]
        Vaux_static_min = limits[&#39;Vaux_static&#39;][0]
        Vaux_static_max = limits[&#39;Vaux_static&#39;][1]
        Iaux_static_min = limits[&#39;Iaux_static&#39;][0]
        Iaux_static_max = limits[&#39;Iaux_static&#39;][1]

        self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 0) # disable Vmain
        time.sleep(0.004) # wait 4 ms
        [ Vmain_pre, Imain_pre, Pmain_pre] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain before enabled
        Imain_pre = Imain_pre * 1000 #Convert to mA

        Vmain_pre_pass, fail = ICQtest(Vmain_pre, Vmain_pre_min, Vmain_pre_max)
        tests_failed = tests_failed + fail
        Imain_pre_pass, fail = ICQtest(Imain_pre, Imain_pre_min, Imain_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain_pre = &#34; + str(Vmain_pre), Vmain_pre_pass)
        print(&#34; Imain_pre = &#34; + str(Imain_pre), Imain_pre_pass)

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 1) # enable Vmain
        time.sleep(0.01) # wait 10 ms
        [ Vmain_static, Imain_static, Pmain_static] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        Imain_static = Imain_static * 1000 #Convert to mA

        Vmain_static_pass, fail = ICQtest(Vmain_static, Vmain_static_min, Vmain_static_max)
        tests_failed = tests_failed + fail
        Imain_static_pass, fail = ICQtest(Imain_static, Imain_static_min, Imain_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain_static = &#34; + str(Vmain_static), Vmain_static_pass)
        print(&#34; Imain_static = &#34; + str(Imain_static), Imain_static_pass)
        #print(&#34; Pmain_static = &#34; + str(Pmain_static))

        time.sleep(0.1) # wait 100 ms
        [ Vdepth_pre, Idepth_pre, Pdepth_pre] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth before enabled
        Idepth_pre = Idepth_pre * 1000 #Convert to mA

        Vdepth_pre_pass, fail = ICQtest(Vdepth_pre, Vdepth_pre_min, Vdepth_pre_max)
        tests_failed = tests_failed + fail
        Idepth_pre_pass, fail = ICQtest(Idepth_pre, Idepth_pre_min, Idepth_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth_pre = &#34; + str(Vdepth_pre), Vdepth_pre_pass)
        print(&#34; Idepth_pre = &#34; + str(Idepth_pre), Idepth_pre_pass)

        self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
        [ Vdepth_static, Idepth_static, Pdepth_static] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
        Idepth_static = Idepth_static * 1000 #Convert to mA

        Vdepth_static_pass, fail = ICQtest(Vdepth_static, Vdepth_static_min, Vdepth_static_max)
        tests_failed = tests_failed + fail
        Idepth_static_pass, fail = ICQtest(Idepth_static, Idepth_static_min, Idepth_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth_static = &#34; + str(Vdepth_static), Vdepth_static_pass)
        print(&#34; Idepth_static = &#34; + str(Idepth_static), Idepth_static_pass)
        #print(&#34; Pdepth_static = &#34; + str(Pdepth_static))

        self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth

        time.sleep(0.1) # wait 100 ms
        [ Vsys_pre, Isys_pre, Psys_pre] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_pre = Isys_pre * 1000 #Convert to mA

        Vsys_pre_pass, fail = ICQtest(Vsys_pre, Vsys_pre_min, Vsys_pre_max)
        tests_failed = tests_failed + fail
        Isys_pre_pass, fail = ICQtest(Isys_pre, Isys_pre_min, Isys_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys_pre = &#34; + str(Vsys_pre), Vsys_pre_pass)
        print(&#34; Isys_pre = &#34; + str(Isys_pre), Isys_pre_pass)

        self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
        self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
        time.sleep( 0.004) # wait 4 ms
        [ Vsys_static, Isys_static, Psys_static] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_static = Isys_static * 1000 #Convert to mA

        Vsys_static_pass, fail = ICQtest(Vsys_static, Vsys_static_min, Vsys_static_max)
        tests_failed = tests_failed + fail
        Isys_static_pass, fail = ICQtest(Isys_static, Isys_static_min, Isys_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys_static = &#34; + str(Vsys_static), Vsys_static_pass)
        print(&#34; Isys_static = &#34; + str(Isys_static), Isys_static_pass)
        #print(&#34; Psys_static = &#34; + str(Psys_static))
        time.sleep(0.01) # wait 10 ms

        self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        self.dev.setGpio( PS_VAUXVPS1, 0)
        time.sleep(0.1) # wait 100 ms
        [ Vaux_pre, Iaux_pre, Paux_pre] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_pre = Iaux_pre * 1000 #Convert to mA

        Vaux_pre_pass, fail = ICQtest(Vaux_pre, Vaux_pre_min, Vaux_pre_max)
        tests_failed = tests_failed + fail
        Iaux_pre_pass, fail = ICQtest(Iaux_pre, Iaux_pre_min, Iaux_pre_max)
        tests_failed = tests_failed + fail
        
        print(&#34; Vaux_pre = &#34; + str( Vaux_pre), Vaux_pre_pass)
        print(&#34; Iaux_pre = &#34; + str( Iaux_pre), Iaux_pre_pass)

        self.dev.setGpio( PS_VAUXVPS1, 1)
        self.dev.setGpio( DEPTH_VAUX_RUN, 1)
        time.sleep(0.0001) # wait 100 us
        [ Vaux_static, Iaux_static, Paux_static] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_static = Iaux_static * 1000 #Convert to mA

        Vaux_static_pass, fail = ICQtest(Vaux_static, Vaux_static_min, Vaux_static_max)
        tests_failed = tests_failed + fail
        Iaux_static_pass, fail = ICQtest(Iaux_static, Iaux_static_min, Iaux_static_max)  
        tests_failed = tests_failed + fail

        print(&#34; Vaux_static = &#34; + str( Vaux_static), Vaux_static_pass)
        print(&#34; Iaux_static = &#34; + str( Iaux_static), Iaux_static_pass)
        #print(&#34; Paux = &#34; + str( Paux))      

        Vmain_pre_test = [&#39;Vmain_pre_V&#39;, Vmain_pre, str(Vmain_pre_pass), Vmain_pre_min, Vmain_pre_max]
        ICQ_dict[&#39;Vmain_pre_V&#39;] = Vmain_pre_test[1:]
        Imain_pre_test = [&#39;Imain_pre_mA&#39;, Imain_pre, str(Imain_pre_pass), Imain_pre_min, Imain_pre_max]
        ICQ_dict[&#39;Imain_pre_mA&#39;] = Imain_pre_test[1:]
        Vsys_pre_test = [&#39;Vsys_pre_V&#39;, Vsys_pre, str(Vsys_pre_pass), Vsys_pre_min, Vsys_pre_max]
        ICQ_dict[&#39;Vsys_pre_V&#39;] = Vsys_pre_test[1:]
        Isys_pre_test = [&#39;Isys_pre_mA&#39;, Isys_pre, str(Isys_pre_pass), Isys_pre_min, Isys_pre_max]
        ICQ_dict[&#39;Isys_pre_mA&#39;] = Isys_pre_test[1:]
        Vdepth_pre_test = [&#39;Vdepth_pre_V&#39;, Vdepth_pre, str(Vdepth_pre_pass), Vdepth_pre_min, Vdepth_pre_max]
        ICQ_dict[&#39;Vdepth_pre_V&#39;] = Vdepth_pre_test[1:]
        Idepth_pre_test = [&#39;Idepth_pre_mA&#39;, Idepth_pre, str(Idepth_pre_pass), Idepth_pre_min, Idepth_pre_max]
        ICQ_dict[&#39;Idepth_pre_mA&#39;] = Idepth_pre_test[1:]
        Vaux_pre_test = [&#39;Vaux_pre_V&#39;, Vaux_pre, str(Vaux_pre_pass), Vaux_pre_min, Vaux_pre_max]
        ICQ_dict[&#39;Vaux_pre_V&#39;] = Vaux_pre_test[1:]
        Iaux_pre_test = [&#39;Iaux_pre_mA&#39;, Iaux_pre, str(Iaux_pre_pass), Iaux_pre_min, Iaux_pre_max]
        ICQ_dict[&#39;Iaux_pre_mA&#39;] = Iaux_pre_test[1:]
        
        Vmain_static_test = [&#39;Vmain_static_V&#39;, Vmain_static, str(Vmain_static_pass), Vmain_static_min, Vmain_static_max]
        ICQ_dict[&#39;Vmain_static_V&#39;] = Vmain_static_test[1:]
        Imain_static_test = [&#39;Imain_static_mA&#39;, Imain_static, str(Imain_static_pass), Imain_static_min, Imain_static_max]
        ICQ_dict[&#39;Imain_static_mA&#39;] = Imain_static_test[1:]
        Vsys_static_test = [&#39;Vsys_static_V&#39;, Vsys_static, str(Vsys_static_pass), Vsys_static_min, Vsys_static_max]
        ICQ_dict[&#39;Vsys_static_V&#39;] = Vsys_static_test[1:]
        Isys_static_test = [&#39;Isys_static_mA&#39;, Isys_static, str(Isys_static_pass), Isys_static_min, Isys_static_max]
        ICQ_dict[&#39;Isys_static_mA&#39;] = Isys_static_test[1:]
        Vdepth_static_test = [&#39;Vdepth_static_V&#39;, Vdepth_static, str(Vdepth_static_pass), Vdepth_static_min, Vdepth_static_max]
        ICQ_dict[&#39;Vdepth_static_V&#39;] = Vdepth_static_test[1:]
        Idepth_static_test = [&#39;Idepth_static_mA&#39;, Idepth_static, str(Idepth_static_pass), Idepth_static_min, Idepth_static_max]
        ICQ_dict[&#39;Idepth_static_mA&#39;] = Idepth_static_test[1:]
        Vaux_static_test = [&#39;Vaux_static_V&#39;, Vaux_static, str(Vaux_static_pass), Vaux_static_min, Vaux_static_max]
        ICQ_dict[&#39;Vaux_static_V&#39;] = Vaux_static_test[1:]
        Iaux_static_test = [&#39;Iaux_static_mA&#39;, Iaux_static, str(Iaux_static_pass), Iaux_static_min, Iaux_static_max]
        ICQ_dict[&#39;Iaux_static_mA&#39;] = Iaux_static_test[1:]

        if(tests_failed == 0):
            print(&#34;Static Malka Supplies PASSED&#34;)
            ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 1 
        else:
            print(&#34;Static Malka Supplies FAILED&#34;)
            ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 0 

        # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            if( cam_shutdown == 1):
                break
            else:
                retries = retries - 1

        # if( retries == 0):
        #     print( &#34;Error during camera initialization&#34;)
        #     self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        #     self.dev.setGpio( PS_VAUXVPS2, 0)
        #     self.dev.setGpio( PS_VAUXVPS1, 0)
        #     self.dev.setGpio( PS_V5VVPS3, 0)
        #     self.dev.setGpio( LMZ_EN, 0)
        #     return -1

        # wait 2 ms
        time.sleep( 0.002)
        self.dev.setGpio( CAM_RESET_N, 1)       

        return [0, ICQ_dict, tests_failed]

    def ICQSensorStart(self, Mode=3, fps=10, cfg = &#34;&#34;, file_name = &#34;&#34;, 
                        limits = None, ICQ_dict=None, ICQ_mode = &#39;no_laser&#39;):
        &#34;&#34;&#34;
        Starts the sensor, performs ICQ and saves it to csv file
        Inputs:
            mode: camera mode 
            fps: frequency per second 
            cfg: name of cfg file 
            file_name: name of csv file to store the results 
            limits: minimum and maximum thresholds 
            ICQ_dict: dictionary containing the results of prior tests 
            ICQ_mode: whether to enable laser or not 

        Outputs:
            0 
            ICQ_dict: result in a dictionary 

        &#34;&#34;&#34;

        tests_failed = 0
        global Vmain_on_test
        global Vsys_on_test
        global Vdepth_on_test
        global Vaux_on_test
        global Imain_on_test
        global Isys_on_test
        global Idepth_on_test
        global Iaux_on_test

        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x98, 0xBB]) # MZ1: Added VAUX DAC set for 25V
        # self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xCE]) # DAC set for 27V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x4B]) # DAC set for 28V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x09]) # DAC set for 28.5V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0x13]) # DAC set for ~13.8V

        [ret, ICQ_dict, tests_failed] = self.ICQSensorPowerUp(tests_failed, limits = limits, ICQ_dict=ICQ_dict)
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()
        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate(fps)

        self.dev.programCfg(cfg)
        #self.programCSV(&#34;process_data_Legacy.csv&#34;)

        
        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)
        
        self.dev.startSensor()
        print(&#34; Camera running... &#34;)

        # Send start command to camera
        self.dev.writeSPISingle( 0x000C, 0x00C5)

        Vmain_on_min = limits[&#39;Vmain_on&#39;][0]
        Vmain_on_max = limits[&#39;Vmain_on&#39;][1]
        Imain_on_min = limits[&#39;Imain_on&#39;][0]
        Imain_on_max = limits[&#39;Imain_on&#39;][1]
        Vsys_on_min = limits[&#39;Vsys_on&#39;][0]
        Vsys_on_max = limits[&#39;Vsys_on&#39;][1]
        Isys_on_min = limits[&#39;Isys_on&#39;][0]
        Isys_on_max = limits[&#39;Isys_on&#39;][1]
        Vdepth_on_min = limits[&#39;Vdepth_on&#39;][0]
        Vdepth_on_max = limits[&#39;Vdepth_on&#39;][1]
        Idepth_on_min = limits[&#39;Idepth_on&#39;][0]
        Idepth_on_max = limits[&#39;Idepth_on&#39;][1]
        Vaux_on_min = limits[&#39;Vaux_on&#39;][0]
        Vaux_on_max = limits[&#39;Vaux_on&#39;][1]
        Iaux_on_min = limits[&#39;Iaux_on&#39;][0]
        Iaux_on_max = limits[&#39;Iaux_on&#39;][1]

        #Measure supply rails after enabling camera
        [ Vmain_on, Imain_on, Pmain_on] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        Imain_on = Imain_on * 1000 #Convert to mA
        
        Vmain_on_pass, fail = ICQtest(Vmain_on, Vmain_on_min, Vmain_on_max)
        tests_failed = tests_failed + fail
        Imain_on_pass, fail = ICQtest(Imain_on, Imain_on_min, Imain_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain-on = &#34; + str(Vmain_on), Vmain_on_pass)
        print(&#34; Imain-on = &#34; + str(Imain_on), Imain_on_pass)
        #print(&#34; Pmain_on = &#34; + str(Pmain_on))

        [ Vdepth_on, Idepth_on, Pdepth_on] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
        Idepth_on = Idepth_on * 1000 #Convert to mA

        Vdepth_on_pass, fail = ICQtest(Vdepth_on, Vdepth_on_min, Vdepth_on_max)
        tests_failed = tests_failed + fail
        Idepth_on_pass, fail = ICQtest(Idepth_on, Idepth_on_min, Idepth_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth-on = &#34; + str(Vdepth_on), Vdepth_on_pass)
        print(&#34; Idepth-on = &#34; + str(Idepth_on), Idepth_on_pass)
        #print(&#34; Pdepth_on = &#34; + str(Pdepth_on))

        [ Vsys_on, Isys_on, Psys_on] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_on = Isys_on * 1000 #Convert to mA

        Vsys_on_pass, fail = ICQtest(Vsys_on, Vsys_on_min, Vsys_on_max)
        tests_failed = tests_failed + fail
        Isys_on_pass, fail = ICQtest(Isys_on, Isys_on_min, Isys_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys-on = &#34; + str(Vsys_on), Vsys_on_pass)
        print(&#34; Isys-on = &#34; + str(Isys_on), Isys_on_pass)
        #print(&#34; Psys_on = &#34; + str(Psys_on))
        time.sleep( 0.004) # wait 4 ms

        [ Vaux_on, Iaux_on, Paux_on] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_on = Iaux_on * 1000 #Convert to mA

        Vaux_on_pass, fail = ICQtest(Vaux_on, Vaux_on_min, Vaux_on_max)
        tests_failed = tests_failed + fail
        Iaux_on_pass, fail = ICQtest(Iaux_on, Iaux_on_min, Iaux_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vaux-on = &#34; + str( Vaux_on), Vaux_on_pass)
        print(&#34; Iaux-on = &#34; + str( Iaux_on), Iaux_on_pass)
        #print(&#34; Paux_on = &#34; + str( Paux_on))
   
        
        Vmain_on_test = [&#39;Vmain-on_V&#39;, Vmain_on, str(Vmain_on_pass), Vmain_on_min, Vmain_on_max]
        ICQ_dict[&#39;Vmain-on_V&#39;] = Vmain_on_test[1:]
        Imain_on_test = [&#39;Imain-on_mA&#39;, Imain_on, str(Imain_on_pass), Imain_on_min, Imain_on_max]
        ICQ_dict[&#39;Imain-on_mA&#39;] = Imain_on_test[1:]
        Vsys_on_test = [&#39;Vsys-on_V&#39;, Vsys_on, str(Vsys_on_pass), Vsys_on_min, Vsys_on_max]
        ICQ_dict[&#39;Vsys-on_V&#39;] = Vsys_on_test[1:]
        Isys_on_test = [&#39;Isys-on_mA&#39;, Isys_on, str(Isys_on_pass), Isys_on_min, Isys_on_max]
        ICQ_dict[&#39;Isys-on_mA&#39;] = Isys_on_test[1:]
        Vdepth_on_test = [&#39;Vdepth-on_V&#39;, Vdepth_on, str(Vdepth_on_pass), Vdepth_on_min, Vdepth_on_max]
        ICQ_dict[&#39;Vdepth-on_V&#39;] = Vdepth_on_test[1:]
        Idepth_on_test = [&#39;Idepth-on_mA&#39;, Idepth_on, str(Idepth_on_pass), Idepth_on_min, Idepth_on_max]
        ICQ_dict[&#39;Idepth-on_mA&#39;] = Idepth_on_test[1:]
        Vaux_on_test = [&#39;Vaux-on_V&#39;, Vaux_on, str(Vaux_on_pass), Vaux_on_min, Vaux_on_max]
        ICQ_dict[&#39;Vaux-on_V&#39;] = Vaux_on_test[1:]
        Iaux_on_test = [&#39;Iaux-on_mA&#39;, Iaux_on, str(Iaux_on_pass), Iaux_on_min, Iaux_on_max]
        ICQ_dict[&#39;Iaux-on_mA&#39;] = Iaux_on_test[1:]

        
        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))

            ADC_LSB = 0.000125
            ADC_REF = 2.5 #Vref
            ADC_BITS = 2**12 #12 bit ADC

            VDDA1_min = limits[&#39;VDDA1&#39;][0]
            VDDA1_max = limits[&#39;VDDA1&#39;][1]
            VHIGH_min = limits[&#39;VHIGH&#39;][0]
            VHIGH_max = limits[&#39;VHIGH&#39;][1]
            VLOW_min = limits[&#39;VLOW&#39;][0]
            VLOW_max = limits[&#39;VLOW&#39;][1]
            VLD_min = limits[&#39;VLD&#39;][0]
            VLD_max = limits[&#39;VLD&#39;][1]

            time.sleep(0.1)
            self.dev.writeSPISingle( 0x0160, 0x0007) #Diff V1p2
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(0)
            ADC_code = self.dev.getADCvalue(0)
            VDDA1 = ADC_code * ADC_LSB
            VDDA1_pass, fail = ICQtest(VDDA1, VDDA1_min, VDDA1_max)
            tests_failed = tests_failed + fail
            print(&#34; VDDA1 = &#34; + str(VDDA1), VDDA1_pass)

            self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vhigh
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(4)
            VHIGH = ADC_code * ADC_LSB
            VHIGH_pass, fail = ICQtest(VHIGH, VHIGH_min, VHIGH_max)
            tests_failed = tests_failed + fail
            print(&#34; VHIGH = &#34; + str(VHIGH), VHIGH_pass)

            self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vlow
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(5)
            VLOW = ADC_code * ADC_LSB
            VLOW_pass, fail = ICQtest(VLOW, VLOW_min, VLOW_max)
            tests_failed = tests_failed + fail
            print(&#34; VLOW = &#34; + str(VLOW), VLOW_pass)

            VDDA1_test = [&#39;VDDA1_V&#39;, VDDA1, str(VDDA1_pass), VDDA1_min, VDDA1_max]
            ICQ_dict[&#39;VDDA1_V&#39;] = VDDA1_test[1:]
            VHIGH_test = [&#39;VHIGH_V&#39;, VHIGH, str(VHIGH_pass), VHIGH_min, VHIGH_max]
            ICQ_dict[&#39;VHIGH_V&#39;] = VHIGH_test[1:]
            VLOW_test = [&#39;VLOW_V&#39;, VLOW, str(VLOW_pass), VLOW_min, VLOW_max]
            ICQ_dict[&#39;VLOW_V&#39;] = VLOW_test[1:]

            if ICQ_mode == &#39;laser&#39;:
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x04, 0x00, 0x10])
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x02, 0x00, 0x10])
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x40])
                VLD = self.dev.readI2C(I2C_MALKA, AD5593R_ID, 2)
                VLD[0] = VLD[0] &amp; 0x0F #ADC conversion is 12 LSBs (bits 13-15 = ADC channel info) 
                VLD = VLD[0] *256 + VLD[1] #unpack bytes
                VLD = VLD * (ADC_REF / ADC_BITS) #convert ADC code to voltage
                VLD = VLD * 5 #Resistor divider schematic - needs to be corrected
                VLD_pass, fail = ICQtest(VLD, VLD_min, VLD_max)
                tests_failed = tests_failed + fail
                print(&#34; VLD = &#34; + str(VLD), VLD_pass)
                VLD_test = [&#39;VLD_V&#39;, VLD, str(VLD_pass), VLD_min, VLD_max]
                ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

            elif ICQ_mode == &#39;no_laser&#39;:
                VLD_test = [&#39;VLD_V&#39;, 0, &#39;NA&#39;, -0.1, 0.1]
                ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

            else:
                raise Exception(&#34;\n\nERROR: Invalid ICQ mode\n\n&#34;)
                  

            if(tests_failed == 0):
                print(&#34;Device PASSED&#34;)
                device_passed = &#34;PASSED&#34;
                ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 1
            else:
                print(&#34;Device FAILED&#34;)
                device_passed = &#34;FAILED&#34;
                print(&#34;Number of tests failed = &#34;, tests_failed)
                ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 0


            Device_test = [&#39;Pass/Fail&#39;, tests_failed, str(device_passed), 0, 0]

            # #data directory path
            # DATA_PATH = &#39;./datalogs&#39;
            # #data file name
            # DATA_NAME = &#39;IQC_log&#39;
            # #todays date
            

            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                print( &#34;Error = &#34; + hex(errorCode))
                
        if( errorCode != 0x0 or data == 0x00):
            sys.exit()
            
        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)

        self.QuickStopSensor()

        now = datetime.now()
        date_string = now.date().strftime(&#34;%Y_%m_%d&#34;)
        time_string = now.time().strftime(&#34;_%H_%M_%S&#34;)

        #create total file path (with date)
        # file_name = DATA_PATH + &#39;/&#39; + date_string + time_string + &#39;_&#39; + DATA_NAME + &#34;.csv&#34;      
        file_name = file_name + &#39;.csv&#39;          

        if not os.path.isfile(file_name):
            csv_headers = [&#39;Test&#39;, &#39;Value&#39;, &#39;Result&#39;, &#39;Min Limit&#39;, &#39;Max Limit&#39;]

        with open(file_name, &#39;w&#39;, newline=&#39;&#39;) as new_data_file:
            datawriter = csv.writer(new_data_file)
            datawriter.writerow(csv_headers)
            datawriter.writerow(Device_test)
            datawriter.writerow(Vmain_pre_test)
            datawriter.writerow(Imain_pre_test)
            datawriter.writerow(Vmain_static_test)
            datawriter.writerow(Imain_static_test)
            datawriter.writerow(Vmain_on_test)
            datawriter.writerow(Imain_on_test)

            datawriter.writerow(Vsys_pre_test)
            datawriter.writerow(Isys_pre_test)
            datawriter.writerow(Vsys_static_test)
            datawriter.writerow(Isys_static_test)
            datawriter.writerow(Vsys_on_test)
            datawriter.writerow(Isys_on_test)

            datawriter.writerow(Vdepth_pre_test)
            datawriter.writerow(Idepth_pre_test)
            datawriter.writerow(Vdepth_static_test)
            datawriter.writerow(Idepth_static_test)
            datawriter.writerow(Vdepth_on_test)
            datawriter.writerow(Idepth_on_test)

            datawriter.writerow(Vaux_pre_test)
            datawriter.writerow(Iaux_pre_test)
            datawriter.writerow(Vaux_static_test)
            datawriter.writerow(Iaux_static_test)
            datawriter.writerow(Vaux_on_test)
            datawriter.writerow(Iaux_on_test)

            datawriter.writerow(VDDA1_test)
            datawriter.writerow(VHIGH_test)
            datawriter.writerow(VLOW_test)
            datawriter.writerow(VLD_test)

        return [tests_failed, ICQ_dict]


    def CamMeasureAnaTestVoltage(self, SOURCE, N_AVERAGES = 1):
        &#34;&#34;&#34;
        Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  
        Inputs:
            - source: Internal ADSD3100 voltage to measure.  Valid options are: 
               &#39;DAC_TX1&#39; 
               &#39;DAC_TX2&#39; 
               &#39;DAC_AMPTEST1&#39; 
               &#39;DAC_BIAS1&#39; 
               &#39;DAC_BIAS2&#39; 
               &#39;DAC_SATREF&#39; 
               &#39;DAC_VREST&#39; 
               &#39;DAC_AMPTEST0&#39; 
               &#39;DAC_CMREF&#39; 
               &#39;DACwithSF_X-Y&#39;,                       
                 X,Y valid options are {AMPTEST0,AMPTEST1,CMREF,GND} 
                 where X = adc_muxp_in/amp_testseln/ATP 
                   and Y = adc_muxn_in/amp_testselp/ATN 
               &#39;comp_vref0&#39; 
               &#39;comp_vref1&#39; 
               &#39;comp_vref2&#39; 
               &#39;amp_vcm&#39;                              
               &#39;AnaTestMux_0&#39; ... &#39;AnaTestMux_31&#39; 
        
            - num_averages (optional). How many times to read the voltage and average 
        
        Outputs:
            - voltage (optional). Measured voltage 
        &#34;&#34;&#34;

        # voltage = CamMeasureAnaTestVoltage(source)
        # voltage = CamMeasureAnaTestVoltage(source, num_averages)
        
        # Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  On ADSD3100
        # BUB this requires jumpers on J29 pins 2-3 (ATP_ADC) and J31 pins 2-3 (ATN_ADC)
        

        val = self.regread(0x0026)
        time.sleep(0.1)
        success = True
        val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running

        if(val!=0):
            time.sleep(1.0)
            val = self.regread(0x0026)
            print(&#34;Retry - val = &#34;, val)
            time.sleep(5.0)
            val = self.regread(0x0026)
            print(&#34;Retry - val = &#34;, val)
            time.sleep(0.1)
            val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running
 
        #self.error_assert(success, &#39;Cannot communicate with chip&#39;)
        self.error_assert(not(val), &#39;Must stop uSeq before calling&#39;)
        ADC_config = dict()

        ADC_config[&#39;mux&#39;] = &#39;AIN0-AIN1&#39;

        val = self.regread(0x017C)

        origSettingADC = dict()

        origSettingADC[&#39;xosc_ctrl&#39;] = int(val)
        origSettingADC[&#39;reg&#39;] = dict()
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = []
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = []

        val = int(val) | 0x0020
        s_ = self.regwrite(0x017C, val)
        # self.error_assert(success, &#39;Unable to write register 0x017C&#39;)

        val = self.regread(0x0146)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], int(val))
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0146)
        val = int(val) &amp; 0xFF7F #power up bandgap
        success = success and self.regwrite(0x0146, val)
        self.error_assert(success, &#39;Unable to power up bandgap&#39;)

        val = self.regread(0x0160) # original state of ana_test_mux_s1
        #self.error_assert(success, &#39;Unable to read ana_test_mux_s1&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0160)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        val = self.regread(0x0128) # original state of dac_ctrl2
        #self.error_assert(success, &#39;Unable to read dac_ctrl2&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0128)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        val = self.regread(0x0014) # original state of digPwrDown
        #self.error_assert(success, &#39;Unable to read digPwrDown&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0014)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        if SOURCE.startswith(&#39;DAC_&#39;):
            dacNames = [&#39;DAC_TX1&#39;,&#39;DAC_TX2&#39;,&#39;DAC_AMPTEST1&#39;,&#39;DAC_BIAS1&#39;,&#39;DAC_BIAS2&#39;,&#39;DAC_SATREF&#39;,&#39;DAC_VREST&#39;,&#39;DAC_AMPTEST0&#39;,&#39;DAC_CMREF&#39;]
            try:
                dacIdx = dacNames.index(SOURCE)
            except:
                raise Exception(&#39;Cannot measure voltage. Unknown DAC value&#39;)

            success = self.regwrite(0x0128, 0x0000)
            self.error_assert(success, &#39;Unable to power up DACs&#39;)

            val = self.regread(0x012A)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x012A)
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) &amp; 0xFF00
            val = val | int(dacIdx + 1) # =1 due to difference in indexing
            success = success and self.regwrite(0x012A, val)
            success = success and self.regwrite(0x0160, 0x0013)
            self.error_assert(success, &#39;Unable to configuire test mux&#39;)

        elif SOURCE.startswith(&#39;amp_vcm&#39;):
            val = self.regread(0x0146)
            val = val &amp; 0xFFCF
            s = self.regwrite(0x0146, val)
            success = self.regwrite(0x0160, 0x001B)

        elif SOURCE.startswith(&#39;DACwithSF_&#39;):
            val = self.regread(0x0146)
            val = int(val) &amp; 0xFFFD
            success = success and self.regwrite(0x0146, val)
            success = success and self.regwrite(0x0128, 0x0000)
            self.error_assert(success, &#39;Unable to power up DACs and column currents&#39;)

            tmp = SOURCE.split(&#39;_&#39;)
            DAC1 = tmp[1].split(&#39;-&#39;)[0]
            try: # if there is no DAC2
                DAC2 = tmp[1].split(&#39;-&#39;)[1]
            except:
                ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
                DAC2 = DAC1

            if (DAC2 == &#39;GND&#39; and DAC1 != &#39;GND&#39;):
                ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
                DAC2 = DAC1
            elif (DAC1 == &#39;GND&#39;):
                ADC_config[&#39;mux&#39;] = &#39;AIN1-GND&#39;
                DAC1 = DAC2

            if DAC1.upper() == &#39;AMPTEST0&#39;:
                amptestselOverrideVal = int(&#39;0x2000&#39;, 0)
            elif DAC1.upper() == &#39;AMPTEST1&#39;:
                amptestselOverrideVal = int(&#39;0x3000&#39;, 0)
            elif DAC1.upper() == &#39;CMREF&#39;:
                amptestselOverrideVal = int(&#39;0x4000&#39;, 0)
            else:
                raise Exception(&#39;Unknown source for DAC selection [0]&#39;)

            if DAC2.upper() == &#39;AMPTEST0&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0400&#39;, 0)
            elif DAC2.upper() == &#39;AMPTEST1&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0420&#39;, 0)
            elif DAC2.upper() == &#39;CMREF&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0800&#39;, 0)
            else:
                raise Exception(&#39;Unknown source for DAC selection [1]&#39;)

            # val = self.regread(0x0E10)
            # print(&#39;regread 0x0E10&#39;, hex(val))
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            # val = self.regread(0x0E18)
            # print(&#39;regread 0x0E18&#39;, hex(val))
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            # val = self.regread(0x0E00)
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E00&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)


            # s = self.regrmw(0x0014,0x0000,0x0001)
            # s = self.regrmw(0x0E00,0x0002,0x0003)
            # s = self.regrmw(0x0E18,0x7C20,0x7C20)
            # s = self.regrmw(0x0E10,amptestselOverrideVal,0x7C20)
            
            val = self.regread(0x0E10)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) &amp; int(&#39;0x83DF&#39; ,0)
            val = val | amptestselOverrideVal
            s_ = self.regwrite(0x0E10, val) # &gt;&gt;&gt;&gt;&gt; override
            #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

            val = self.regread(0x0E18)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) | int(&#39;0x7C20&#39; ,0)
            s_ = self.regwrite(0x0E18, val) # &gt;&gt;&gt;&gt;&gt; override
            #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

            success = success and self.regwrite(0x0014, 0x0000)
            s, origSettingADC[&#39;ampMuxOrig&#39;] = self.regreadburst(0x0E1C, 10, &#39;increment&#39;)
            ampMuxVal = [0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008]
            s = self.regwriteburst(0x0E1C, ampMuxVal, &#39;increment&#39;)

            # val = self.regread(0x0160)
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0160&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            s = self.regwrite(0x0160, 0x0012)
            self.error_assert(success, &#39;Unable to configuire test mux&#39;)
            # s = self.regwrite(0x0150, 0x0105)

        elif SOURCE.startswith(&#39;comp_v&#39;):
            val = self.regread(0x0146)
            val = int(val) &amp; int(&#39;0xFFEF&#39;,0)
            success = success and self.regwrite(0x0146, val)
            self.error_assert(success, &#39;Unable to power up col_comparator&#39;)

            if SOURCE.lower() == &#39;comp_vref0&#39;:
                success = success and self.regwrite(0x0160, 0x0014)
            elif SOURCE.lower() == &#39;comp_vref1&#39;:
                success = success and self.regwrite(0x0160, 0x0015)
            elif SOURCE.lower() == &#39;comp_vref2&#39;:
                success = success and self.regwrite(0x0160, 0x0016)
            else:
                raise Exception(&#39;Unknown source&#39;)

        elif SOURCE == &#39;amp_vcm&#39;:
            val = self.regread(0x0146)
            val = int(val) &amp; int(&#39;0xFFCF&#39;,0)
            success = success and self.regwrite(0x0146, val)
            self.error_assert(success, &#39;Unable to power up col_comparator and AMP&#39;)

            success = success and self.regwrite(0x0160, 0x001B)

        elif SOURCE.startswith(&#39;AnaTestMux_&#39;):
            ana_test_mux = int(SOURCE.split(&#39;_&#39;)[1])

            if np.isnan(ana_test_mux) or ana_test_mux &gt; 31 or ana_test_mux &lt; 0:
                print(&#39;Unknown source. The AnaTestMux_ option must include a mux value between 0-31\n&#39;)

            success = self.regwrite(0x0160, ana_test_mux)

        else:
            raise Exception(&#34;Unknown source&#34;)

        # adding pause to avoid bogus readings given the sampling freq increased in the newer FW version
        # val = self.regread(0x0e16)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e16&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # val = self.regread(0x0e14)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e14&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # s = self.regwrite(0x0e16, 0x4000)
        # s = self.regwrite(0x0e14, 0x0100)
        muxOptions = np.array([&#39;ain0-ain1&#39;,&#39;ain0-ain3&#39;,&#39;ain1-ain3&#39;,&#39;ain2-ain3&#39;,&#39;ain0-gnd&#39;,&#39;ain1-gnd&#39;,&#39;ain2-gnd&#39;,&#39;ain3-gnd&#39;])
        tmp, = np.where(muxOptions == ADC_config[&#39;mux&#39;].lower())
        muxVal = tmp[0]

        # for i in range(N_AVERAGES-1, -1,-1):
        #   time.sleep(0.01)
        #   val = self.ReadBoardADC(muxVal)
        #   voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

        # voltage = voltage / 1000000 # in V

        vRepeat = True
        nIter = 3

        while(vRepeat and (nIter &gt;= 1)):
            # print(vRepeat,nIter)
            for i in range(N_AVERAGES-1, -1,-1):
                time.sleep(0.01)
                val = self.ReadBoardADC(muxVal)
                voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

            voltage = voltage / 1000000 # in V

            if (self.prevVoltage != voltage) and (abs(voltage) &gt; 0.03) and (abs(voltage) &lt; 3.8):
                vRepeat = False
                self.prevVoltage = voltage
            else:
                time.sleep(0.1)
                nIter = nIter - 1

            # if nIter &lt; 1:
            #     print(&#39;\nONBOARD ADC ERROR\n&#39;)
            #     try:
            #         logging.info(&#39;\nONBOARD ADC ERROR\n&#39;)
            #     except:
            #         pass

        # clean up
        success = True
        keys = list(origSettingADC.keys())

        if &#39;ampMuxOrig&#39; in keys:
            success = self.regwriteburst(0x0E1C, np.array(origSettingADC[&#39;ampMuxOrig&#39;],dtype=np.uint16), &#39;increment&#39;)

        origADCAddr = np.array(origSettingADC[&#39;reg&#39;][&#39;addr&#39;],dtype=np.uint16)
        origADCVal = np.array(origSettingADC[&#39;reg&#39;][&#39;val&#39;],dtype=np.uint16)
        s = self.regwrite(origADCAddr, origADCVal)

        xosc_ctrl = origSettingADC[&#39;xosc_ctrl&#39;]

        if ((xosc_ctrl &gt;&gt; 6) &amp; 1) == 1: # if XIDLE_HOST originally was 1
            xosc_ctrl = xosc_ctrl | int(&#39;0x0010&#39;,0) # set XIDLE_HOST_set
            xosc_ctrl = xosc_ctrl &amp; int(&#39;0xFFDF&#39;,0) # dont set XIDLE_HOST_clear
            s = self.regwrite(0x017C, xosc_ctrl)
            # self.error_assert(success, &#39;Unable to restore register 0x017C&#39;)

        self.error_assert(success, &#39;Unable to restore original register settings&#39;)
        print(&#39;Analog test mux source:&#39;, SOURCE , &#39;measured voltage:&#39;, np.round(voltage, 4))
        try:
            logging.info(&#39;Analog test mux source: &#39; + str(SOURCE) +&#39; measured voltage: &#39; + str(np.round(voltage, 4)))
        except:
            pass

        return voltage
    

    def regwritemultiple(self, addr, val):
        &#34;&#34;&#34;
        Write multiple registers 
        Inputs:
            addr: address array 
            val: value array 

        Outputs:
            status 

        &#34;&#34;&#34;
        self.dev.writeSPISingle(addr, val)


    def regrmw(self, addr, val, mask=np.uint16(0x0000)):
        &#34;&#34;&#34;
        Register read-modify-write 
        Inputs:
            addr: address in hex or decimal 
            val: value in hex or decimal 
            mask: mask in hex or decimal 

        Outputs:
            success: status of rmw 

        &#34;&#34;&#34;
        addr = np.uint16(addr)
        val = np.uint16(val)
        mask = np.uint16(mask)
        prevVal = np.uint16(self.regread(addr))
        newVal = (prevVal &amp; ~mask) | (val &amp; mask)
        success = self.regwrite(addr, newVal)
        return success


    def dac_amptest0_get(self):
        &#34;&#34;&#34;
        Get amptest0 value 
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_amptest0


    def dac_amptest0_set(self, val):
        &#34;&#34;&#34;
        Set amptest0 value 
        Inputs:
            val: amptest0 value 

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0080) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_amptest0 = val
        return s


    def dac_amptest1_get(self):
        &#34;&#34;&#34;
        Get amptest1 value
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_amptest1


    def dac_amptest1_set(self, val):
        &#34;&#34;&#34;
        Set amptest1 value
        Inputs:
            val: amptest1 value

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0004) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_amptest1 = val
        return s


    def dac_cmref_get(self):
        &#34;&#34;&#34;
        Get cmref value
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_cmref


    def dac_cmref_set(self, val):
        &#34;&#34;&#34;
        Set cmref value
        Inputs:
            val: cmref value 

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0100) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_cmref = val
        return s
        

    def regreadburst(self, addr, length, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Register read burst (from RAM or multiple registers)
        Inputs:
            addr: Address 
            length: length to read 
            mode: RAM read or &#39;increament&#39; to read multiple registers 

        Outputs:
            True 
            val: read value in array 

        &#34;&#34;&#34;
        if mode == &#39;&#39;:
            s, tmp =  self.dev.readSPIBurst(addr, length*2+4) # Temporory workaround
            val = np.zeros(length)
            val = 256*tmp[::2] + tmp[1::2]
            return np.all(s), val[0:-2]
        elif mode == &#39;increment&#39;:
            val = np.zeros(length,dtype=np.uint16)
            for i in range(length):
                val[i] = self.regread(addr + 2*i)
            return True, val

    def print_regreadburst(self, addr, length):
        &#34;&#34;&#34;
        Print register read burst 
        Inputs: 
            addr: Address 
            length: length to read 

        Outputs:
            None 

        &#34;&#34;&#34;
        for i in range(length):
            val = self.regread(addr + 2*i)
            print(hex(addr + 2*i),&#39;--&gt;&#39;,hex(val))

    def regwriteburst(self, addr, data, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Register write burst (to RAM or multiple registers)
        Inputs:
            addr: Address array 
            data: Data array 
            mode: RAM read or &#39;increament&#39; to read multiple registers 

        Outputs:
            status 

        &#34;&#34;&#34;
        addr = np.uint16(addr)
        data = np.uint16(data)
        if mode == &#39;&#39;:
            RAMData = np.zeros( (len(data)*2), dtype = np.uint8)
            for i in range( len(data)):
                RAMData[2*i] = data[i] &gt;&gt; 8
                RAMData[2*i+1] = data[i] &amp; 0xFF
            return self.dev.writeSPIBurst(addr, RAMData)

        elif mode == &#39;increment&#39;:
            if isinstance(addr, np.uint16):
                for i in range(len(data)):
                    success = self.regwrite(addr + i*2, data[i])
            else:
                for i in range(len(data)):
                    success = self.regwrite(addr[i], data[i])

        return success

        
    def GetIndirectRegister(self, name):
        &#34;&#34;&#34;
        Read indirect registers
        Inputs:
            name: register name 

        Outputs:
            status
            value

        &#34;&#34;&#34;
        if name == &#39;N_OVRD_ANAMODE&#39;:
            addr = 0x1fc1
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_0&#39;:
            addr = 0x1fc5
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_1&#39;:
            addr = 0x1fc9
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_2&#39;:
            addr = 0x1fcd
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;LASER_CONTROL&#39;:
            addr = 0x1fd1
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
            addr = 0x1fb1
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_USE_LASER&#39;:
                return val &amp; 0xFF
            else:
                return val &gt;&gt; 8

        elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
            addr = 0x1fb5
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_OVRD_ANAMODE&#39;:
                return s, val &amp; 0xFF
            else:
                return s, val &gt;&gt; 8

        elif name == &#39;B_LVDS_PD&#39;:
            addr = 0x1fb9
            s = self.regwrite(0x0004, addr)
            return self.regread(0x0006)

        elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
            addr = 0x1fbd
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_EN_PHASESWEEP&#39;:
                return s, val &amp; 0xFF
            else:
                return s, val &gt;&gt; 8

        else:
            raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))
            return  0, -1


    def SetIndirectRegister(self, name, val):
        &#34;&#34;&#34;
        Set indirect registers
        Inputs:
            name: register name 
            val: register value 

        Outputs:
            status

        &#34;&#34;&#34;
        if name == &#39;N_OVRD_ANAMODE&#39;:
            addr = 0x1fc1
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_0&#39;:
            addr = 0x1fc5
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_1&#39;:
            addr = 0x1fc9
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_2&#39;:
            addr = 0x1fcd
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;LASER_CONTROL&#39;:
            addr = 0x1fd1
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
            addr = 0x1fb1
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_USE_LASER&#39;:
                s_  = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
            addr = 0x1fb5
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_OVRD_ANAMODE&#39;:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        elif name == &#39;B_LVDS_PD&#39;:
            addr = 0x1fb9
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
            addr = 0x1fbd
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_EN_PHASESWEEP&#39;:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        else:
            raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))

        s = self.regwrite(0x000C, 0x00C4)
        val = self.regread(0x0012)
        return s and self.regwrite(0x0012, np.uint16(val + 1)) # update sequence


    def LoadGainOffsetCalib(self, fname):
        &#34;&#34;&#34;
        Loads gain and offset to memory
        Inputs:
            fname: location of csv file 

        Outputs:
            none

        &#34;&#34;&#34;
        fin = open(fname, &#39;r&#39;)
        csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)
        arr = np.array([],dtype=np.uint16)
        for row in csv_reader:
            arr = np.append(arr, np.uint16(int(str(row[0]),0)))
        
        ADC_updnoffset = arr[0]
        ADC_iramp = arr[1]

        Vref1DAC = arr[2]
        Vref1Set = arr[3]
        Vref2DAC = arr[4]
        Vref2Set = arr[5]
        Vref3DAC = arr[6]
        Vref3Set = arr[7]
        VCMDAC = arr[8]
        VCMSet = arr[9]
        inverseGlobalADCGain = np.zeros(4,dtype=np.uint16)
        inverseGlobalADCGain[0] = arr[10]
        inverseGlobalADCGain[1] = arr[11]
        inverseGlobalADCGain[2] = arr[12]
        inverseGlobalADCGain[3] = arr[13]
        perColGain = arr[14:12814]
        perColOffset = arr[12814:25614]

        dac_ctrl2_s1 = Vref1DAC | (Vref2DAC &lt;&lt; 8)
        dac_ctrl3_s1 = Vref3DAC

        if &#39;VCMDAC&#39; != 0:
            dac_ctrl3_s1 = dac_ctrl3_s1| (VCMDAC &lt;&lt; 8)

        dac_ctrl2_s1_mask = 0x003F * (Vref1Set != 0) + 0x3F00 * (Vref2Set != 0)
        dac_ctrl3_s1_mask = 0x003F * (Vref3Set != 0)

        if VCMSet != 0 and VCMDAC != 0:
            dac_ctrl3_s1_mask = dac_ctrl3_s1_mask + 0x3F00 * (VCMSet != 0)
    
        val = self.regread(0x0112)
        if val != 22833:
            raise Exception(&#39;Cannot Communicate with chip / incorrect chipId&#39;)

        digPwrDown = self.regread(0x0014)
        s = self.regwrite(0x0014, 0x0000)

        s = self.regwrite(0x0102, ADC_updnoffset)
        s = s and self.regwrite(0x0104, ADC_iramp)
        s = s and self.regwriteburst(0x0520, inverseGlobalADCGain, &#39;increment&#39;)
        s = s and self.regrmw(0x012E, dac_ctrl2_s1, dac_ctrl2_s1_mask)
        s = s and self.regrmw(0x0130, dac_ctrl3_s1, dac_ctrl3_s1_mask)

        # perColGain
        s = s and self.regwrite(0x0500, 0x0008)
        s = s and self.regwrite(0x0502, 0x0000)
        s = s and self.regwriteburst(0x0504, perColGain)
        s = s and self.regrmw(0x0528, 0x0000, 0x0004)

        # perColOffset
        s = s and self.regwrite(0x0500, 0x0004)
        s = s and self.regwrite(0x0502, 0x0000)
        s = s and self.regwriteburst(0x0504, perColOffset)
        s = s and self.regrmw(0x0528, 0x0000, 0x0002)

        s = self.regwrite(0x0014, digPwrDown)
        if s:
            print(&#39;Gain and Offset calibration data loaded!&#39;)


    def SetLSDACValue(self, LSDAC_VALUE):
        &#34;&#34;&#34;
        Sets LSDAC value. This function encrypts the LSDAC values
        before writing to memory
        Inputs:
            LSDAC_VALUE: 2D array of LSDAC value (unencrypted) 

        Outputs:
            none

        &#34;&#34;&#34;

        #Stop execution before configuring LSDAC
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        while( regData[0] != 0x0):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)

        address, value = LSDAC.GenerateLSDACBlock(LSDAC_VALUE, self.n_modes_cfg)
        numel = len(address)
        newAddresses = np.array([])
        newValues = np.zeros(numel*2,dtype=object)
        for i in range(numel):
            newAddresses = np.append(newAddresses, np.array([0x0000,0x0002]))
        newValues[::2] = address
        newValues[1::2] = value
        print(&#39;Addr&#39;, newAddresses)
        print(&#39;Val&#39;, newValues)
        self.regwrite( np.asarray(newAddresses, dtype=np.uint16), np.asarray(newValues, dtype=np.uint16))

        #Start execution again after configuring LSDAC
        self.dev.writeSPISingle( 0x000C, 0x0001)

        print(&#39;LSDAC value set to&#39;, LSDAC_VALUE)
        try:
            logging.info(&#39;LSDAC value set to&#39; + str(LSDAC_VALUE))
        except:
            pass



    def ReadBoardADC(self, val):
        &#34;&#34;&#34;
        Read onboard ADC value
        Inputs:
            val: value 

        Outputs:
            ADC value 

        &#34;&#34;&#34;
        return self.dev.getADCvalue(val)


    def _setInternalClassMode( self):
        &#34;&#34;&#34;Configures internal variables depending in the selected mode.

        Inputs:
            none

        Outputs:
            none
        &#34;&#34;&#34;
        with open(&#39;config/CameraModeInfo.yaml&#39;) as y:
            modeInfo = yaml.load(y, Loader=yaml.SafeLoader)

        try:
            self.width = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;width&#39;]
            self.height = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;height&#39;]
            self.subFrames = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;nCaptures&#39;]
            self.nFreq = len(modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqsMhz&#39;])
            self.nPhases = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;nPhases&#39;]
            self.freqs = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqsMhz&#39;]
            self.freqPerPhase = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqPerPhase&#39;]
        except:
            raise Exception(&#34;Invalid mode selected (valid modes = 0-10)&#34;)
                
        self.rawImage = np.zeros( (self.height, self.width, self.subFrames), dtype = np.int16)
        self.pRAW = np.zeros( (self.height, self.width * self.subFrames), dtype = np.int16)
        self.unwrappedDepth = np.zeros( (self.height, self.width, self.nFreq), dtype = np.double)
        return 0

    def setFPS( self, fps):
        &#34;&#34;&#34;Changes camera framerate
        
        :param fps: Camera framerate 
        :type fps: int 
        :returns: None  
        :rtype: None 
        &#34;&#34;&#34;
        self.dev.setCAMFps(fps)


    def GetFramesADCCalib(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for ADC calibration
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            success: status of capture 
            frames: frames in a 3D array 

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)

        frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 = np.resize(subImage, (self.height, self.width))
                frames[:,:,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - ADC Calib&#39;)
        logging.info(&#39;Frame captured - ADC Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        

        return success, frames


    def GetFramesPixVoltage(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for pixel voltage test
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            success: status of capture  
            frames: frames in a 3D array  

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)

        frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize(image16, (self.height, self.width))
                frames[:,:,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - ADC Calib&#39;)
        logging.info(&#39;Frame captured - ADC Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        
        return success, frames


    def GetFramesCompDACalib(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for comparator DAC calibratiom
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            GT: gain tag values 
            ADC: ADC values 
            Sat: Saturation status values 

        &#34;&#34;&#34;
        # self.QuickStartSensor()
        self.Start()

        time.sleep(0.5)
        
        frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            #RawImage = self.dev.getFloatImage()
            tmp = tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]
            subImage = RawImage[0 : self.width*self.height]
            image16 = np.resize(subImage, (self.height, self.width))
            frames[:,:,0,frm] = image16.copy()

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                success = True

        print(&#39;Frame captured - CompDAC Calib&#39;)
        logging.info(&#39;Frame captured - CompDAC Calib&#39;)

        self.Stop()
        
        imgRaw = frames[2:,:,:,:]
        GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
        ADC = imgRaw.astype(np.uint16) &amp; 1023
        SAT = ADC &lt; 3

        if np.any(SAT == True):
            print(&#39;Saturation detected in comparator calibration frame!&#39;)
            logging.warning(&#39;Saturation detected in comparator calibration frame!&#39;)

        print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
        logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
        print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
        logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
        print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
        logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


        return GT,ADC,SAT

    def GetFramesPCGO(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for per column gain and offset
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            GT: gain tag values 
            ADC: ADC values 
            Sat: Saturation status values 

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)
        
        frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            #RawImage = self.dev.getFloatImage()
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 = np.resize(subImage, (self.height, self.width))
                frames[:,:,0,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - perColumn Calib&#39;)
        logging.info(&#39;Frame captured - perColumn Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        # time.sleep(0.1)
        
        imgRaw = frames[20:,:,:,:]
        GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
        ADC = imgRaw.astype(np.uint16) &amp; 1023
        SAT = ADC &lt; 3

        if np.any(SAT == True):
            print(&#39;Saturation detected in Per Col GO calibration frame!&#39;)

        print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
        logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
        print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
        logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
        print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
        logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


        return GT,ADC,SAT

    
    def procFrame( self):
        &#34;&#34;&#34;Retrieves a frame from the camera and process the frame data filling the internal buffers and processing the
        raw data from the camera.
        
        :returns: None 
        :rtype: None 
        &#34;&#34;&#34;

        RawImage = self.dev.getFloatImage()
        time.sleep(debug_delay)
        #RawImage = self.dev.getImage8U()
        if( self.dev.validFrame != 1):
        #if( self.dev.IO.validFrame != 1):
            return -1
        else:
            RawImage = RawImage[0]
            #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
            RAW = RawImage
            RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
            self.pRAW = RAW.copy()

            for i in range( self.subFrames):
                subImage = RawImage[ i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal( subImage)
                image16 = np.resize( image16, (self.height, self.width))
                
                self.rawImage[:,:,i] = image16.copy()

            for i in range( len(self.freqs)):                
                f = self.freqs[i]
                depth = self.visualize_map( self.rawImage[:,:,i*self.nPhases:(i+1)*self.nPhases], f)[0]

                self.unwrappedDepth[:,:,i] = depth.copy()

        return 0



    def block_max(self, img):
        &#34;&#34;&#34;
        Computes x and y coordinates of the brightest spot
        in the image
        Inputs:
            img: image array 

        Outputs:
            max_x: x coordinate of maximum brightness 
            max_y: y coordinate of maximum brightness 
        &#34;&#34;&#34;
        res = ndimage.interpolation.zoom(img,0.125)
        max_blk = np.where(res == np.amax(res))
        max_x = np.clip(max_blk[1][0] * 8 + 4, 16, 1007)
        max_y = np.clip(max_blk[0][0] * 8 + 4, 16, 1007)
        return max_x, max_y



    def StreamAndCapturePCM(self, paramDict = dict()):
        &#34;&#34;&#34;
        Streams and captures PCM image
        Inputs:
            paramDict: dictionary containing frame parameters 

        Outputs:
            True 
            frames_dict: dictionary containing frames and header 
        &#34;&#34;&#34;
         # Header Info

        keys = list(paramDict.keys())
        
        mode = 3

        if &#39;nFrames&#39; in keys:
            nFrames = paramDict[&#39;nFrames&#39;]
        else:
            nFrames = 5

        if &#39;fileName&#39; in keys:
            filename = paramDict[&#39;fileName&#39;]
        else:
            now = datetime.now()
            filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

        if &#39;outputFormat&#39; in keys:
            outputFormat = paramDict[&#39;outputFormat&#39;]
        else:
            outputFormat = &#39;pkl&#39;


        self.StartSensor()
        Temp_sensor_offset = 1493.55 # From calibration
        Temp_sensor_slope = 5.45 # From calibration
        self.changeMode(mode)


        while(True):

            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            #RawImage = self.dev.getImage8U()
            if( self.dev.validFrame != 1):
            #if( self.dev.IO.validFrame != 1):
                print(&#39;Invalid frame&#39;)
                pass

            else:
                RawImage = tmp[0]
                #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
                RAW = RawImage
                RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
                subImage = RawImage[0:self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal( subImage)
                image16 = np.resize( image16, (self.height, self.width))
                orig_image = np.copy(image16)
                image16 = image16 + np.amin( image16)*-1
                image16 = np.array( image16, dtype=np.uint16)

                # process image for visualization        
                mImg = np.uint8( (image16/np.amax(image16)*(255)))
                max_x, max_y = self.block_max(mImg)
                mImg = cv2.applyColorMap( mImg, cv2.COLORMAP_BONE)
                Imgstr = &#34;Relative PCM Image&#34;
                text1 = &#34;Press &#39;d&#39; to save and stop steaming&#34;
                text2 = &#34;Brightest 32x32 ROI mean = &#34; + str(np.round(np.mean(orig_image[max_y-16:max_y+16,max_x-16:max_x+16]),3))

                font = cv2.FONT_HERSHEY_SIMPLEX
                fontScale = 1
                fontColor = (255,0,255) #BGR
                thickness = 2
                org1 = (50, 50)
                org2 = (50, 1000)

                mImg = cv2.putText(mImg, text1, org1, font, fontScale, fontColor, thickness, cv2.LINE_AA)
                mImg = cv2.putText(mImg, text2, org2, font, fontScale, fontColor, thickness, cv2.LINE_AA)

                mImg = cv2.rectangle(mImg, (max_x-16, max_y-16), (max_x+16, max_y+16), (0,0,255), 2)

                #cv2.putText( mImg, str(j), ( 200, 200), cv2.FONT_HERSHEY_SIMPLEX, .5, ( 0, 0, 0), 2, cv2.LINE_AA)
                cv2.imshow( Imgstr, mImg)

            c = cv2.waitKey(50) &amp; 0xFF
            if (c == ord(&#39;d&#39;)) :
                cv2.destroyAllWindows()
                break
                


        captures = self.subFrames
        print(captures)
        # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
        #     captures = captures - 1

        Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
        Header_tmp = np.zeros(nFrames, dtype=object)
        RawImage = np.zeros(nFrames,dtype=object)
        Header = np.zeros([captures, nFrames],dtype=object)

        frm = 0
        count = 0
        while frm &lt; nFrames:
            print(&#39;Frame #&#39;, frm)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                print(&#39;skipped frame&#39;)
                pass
            else:
                RawImage[frm] = tmp[0]
                Header_tmp[frm] = tmp[1]
                frm = frm + 1
            print(&#39;count:&#39;, count)
            count = count + 1

        self.QuickStopSensor()
                
        Header_tmp_per_capture_size = 128

        for frm in range(nFrames):
            print(&#39;Restructuring frm #:&#39;, frm)
            for i in range(captures):
                Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
                subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize( image16, (self.height, self.width))
                Img[:,:,i,frm] = image16.copy()
                Header[i][frm] = dict()
                Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
                Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
                Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
                Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
                Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
                Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
                Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
                Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
                Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
                Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
                Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
                Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
                Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
                Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
                Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF

        if outputFormat == &#39;pkl&#39;:
            output = dict()
            output[&#39;Image&#39;] = Img
            output[&#39;Header&#39;] = Header
            f = open(filename, &#39;wb&#39;)
            pickle.dump(output, f)
            f.close()
        elif outputFormat == &#39;bin&#39;:
            for frm in range(nFrames):
                write_file = open(filename[:-4] + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)
        else:
            raise Exception(&#39;Invalid output format for storing frames.&#39;)

        frames_dict = dict()
        frames_dict[&#39;Image&#39;] = Img
        frames_dict[&#39;Header&#39;] = Header

        return True, frames_dict


    def CaptureFramesP0(self, paramDict = dict()):
        &#34;&#34;&#34;
        Captures frames for P0 calibration
        Inputs:
            paramDict: dictionary containing frame parameters 

        Outputs: 
            True 
            output: dictionary containing frames and header 
        &#34;&#34;&#34;

        keys = list(paramDict.keys())
        
        if &#39;mode&#39; in keys:
            mode = paramDict[&#39;mode&#39;]
        else:
            mode = 3

        if &#39;nFrames&#39; in keys:
            nFrames = paramDict[&#39;nFrames&#39;]
        else:
            nFrames = 5

        if &#39;nWarmupFrames&#39; in keys:   
            nWarmupFrames = paramDict[&#39;nWarmupFrames&#39;]
        else:
            nWarmupFrames = 5

        if &#39;OVERRIDE_LSDACS&#39; in keys:
            OVERRIDE_LSDACS = paramDict[&#39;OVERRIDE_LSDACS&#39;]
        else:
            OVERRIDE_LSDACS = False

        if &#39;LSDACValue&#39; in keys:
            LSDACValue = paramDict[&#39;LSDACValue&#39;]
        else:
            LSDACValue = -1 # default value

        if &#39;feedbackCap&#39; in keys:
            feedbackCap = paramDict[&#39;feedbackCap&#39;]
        else:
            feedbackCap = 0x8B42

        if &#39;samplingCap&#39; in keys:
            samplingCap = paramDict[&#39;samplingCap&#39;]
        else:
            samplingCap = 0x0333

        if &#39;fileName&#39; in keys:
            filename = paramDict[&#39;fileName&#39;]
        else:
            now = datetime.now()
            filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

        if &#39;enableSweep&#39; in keys:
            enableSweep = paramDict[&#39;enableSweep&#39;]
        else:
            enableSweep = False

        if &#39;outputFormat&#39; in keys:
            outputFormat = paramDict[&#39;outputFormat&#39;]
        else:
            outputFormat = &#39;pkl&#39;

        if &#39;also_save_image_as_bin&#39; in keys:
            also_save_image_as_bin = paramDict[&#39;also_save_image_as_bin&#39;]
        else:
            also_save_image_as_bin = False

        if &#39;displayFrame&#39; in keys:
            displayFrame = paramDict[&#39;displayFrame&#39;]
        else:
            displayFrame = False

        if &#39;displayDuration&#39; in keys:
            displayDuration = paramDict[&#39;displayDuration&#39;]
        else:
            displayDuration = 3


        if &#39;feedbackCap&#39; in keys:
            success = self.regwrite(0x10C, feedbackCap)
        if &#39;samplingCap&#39; in keys:
            success = self.regwrite(0x10E, samplingCap)

        # Disabling gain correction
        # success = self.regwrite(0x027C, 0x0000)

        if enableSweep:
            self.SetIndirectRegister(&#39;B_EN_PHASESWEEP&#39;, 1)

        Temp_sensor_offset = 1493.55 # From calibration
        Temp_sensor_slope = 5.45 # From calibration

        self.StartSensor()

        self.changeMode(mode)

        if OVERRIDE_LSDACS:
            success = self.SetLSDACValue(LSDACValue)


        # Warmup frames
        for i in range(nWarmupFrames):
            print(&#39;Warmup Frame #&#39;, i)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                tries = 2
                while((self.dev.validFrame != 1) and (tries &gt; 0)):
                    print(&#39;Frame retry #&#39;, tries)
                    time.sleep(0.5)
                    tmp = self.dev.getFloatImage()
                    time.sleep(0.5)
                    tries = tries - 1
                    if((self.dev.validFrame != 1) and (tries == 0)):
                        sys.exit()

        hdr_tmp = tmp[1]
        print(((hdr_tmp[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope)

        captures = self.subFrames
        # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
        #     captures = captures - 1

        Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
        Header_tmp = np.zeros(nFrames, dtype=object)
        RawImage = np.zeros(nFrames,dtype=object)
        Header = np.zeros([captures, nFrames],dtype=object)


        frm = 0
        count = 0
        while frm &lt; nFrames:
            print(&#39;Frame #&#39;, frm)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                print(&#39;skipped frame&#39;)
                pass
            else:
                RawImage[frm] = tmp[0]
                Header_tmp[frm] = tmp[1]
                frm = frm + 1
            print(&#39;count:&#39;, count)
            count = count + 1

        self.QuickStopSensor()
                
        Header_tmp_per_capture_size = 128

        for frm in range(nFrames):
            print(&#39;Restructuring frm #:&#39;, frm)
            for i in range(captures):
                Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
                subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize( image16, (self.height, self.width))
                Img[:,:,i,frm] = image16.copy()
                Header[i][frm] = dict()
                Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
                Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
                Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
                Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
                Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
                Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
                Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
                Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
                Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
                Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
                Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
                Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
                Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
                Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
                Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF


        output = dict()
        output[&#39;Image&#39;] = Img
        output[&#39;Header&#39;] = Header

        if outputFormat == &#39;pkl&#39;:
            f = open(filename, &#39;wb&#39;)
            pickle.dump(output, f)
            f.close()
        elif outputFormat == &#39;bin&#39;:
            if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
                os.mkdir(filename[:-4]+&#39;_bin&#39;)

            frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

            for frm in range(nFrames):
                write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

        elif outputFormat == &#39;none&#39;:
            pass # do not save frames
            
        else:
            raise Exception(&#39;Invalid output format for storing frames.&#39;)

        if also_save_image_as_bin and outputFormat != &#39;bin&#39;:
            if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
                os.mkdir(filename[:-4]+&#39;_bin&#39;)

            frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

            for frm in range(nFrames):
                write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

        if displayFrame:
            plt.figure()
            plt.imshow(np.mean(Img, axis=3)[:,:,0])
            plt.show(block=False)
            plt.pause(displayDuration)
            plt.close()

        return True, output


    def changeMode( self, Mode):
        &#34;&#34;&#34;Changes image sensor mode. This function will not change the camera resolution.
        
        :param Mode: image sensor mode. 
        :type Mode: int 
        :returns: None 
        :rtype: None 
        &#34;&#34;&#34;
        self.Mode = Mode
        self._setInternalClassMode()

        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        while( regData[0] != 0x0):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)
        self.dev.writeSPISingle( 0x0200, self.Mode)
        self.dev.writeSPISingle( 0x000C, 0x0001)


    def visualize_map(self, pixout, f_mhz):
        &#34;&#34;&#34;
        Visualizes map
        Inputs:
            pixout: raw pixel values 
            f_mhz: frequency in mhz 

        Outputs:
            dist: distance map in meter 
            ampl: amplitude map 
        &#34;&#34;&#34;          
        nPhase = self.nPhases #len(pixout[0,0,:])
        V1_real = np.sum(np.array([np.cos(2*np.pi*n/nPhase)
                        for n in range(0, nPhase)]) * pixout, axis=2)
        V1_imag = np.sum(-1 * np.array([np.sin(2*np.pi*n/nPhase)
                        for n in range(0, nPhase)]) * pixout, axis=2)
        dist = (299792458/(4*np.pi*f_mhz*1000000)*np.arctan2(V1_imag, V1_real))
        dist = dist % (299792458 * (1/f_mhz/1000000) / 2) # Rolling phases
        ampl = np.abs(V1_real, V1_imag)
        
        
        return dist, ampl # in meters

    def programCSV( self, filename):
        &#34;&#34;&#34;
        Programs the sensor with csv
        Inputs:
            filename: csv filename 

        Outputs:
            none 
        &#34;&#34;&#34; 
        fin = open(filename)
        csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)

        if( self._debug):
            fname = &#34;firmware0.bin&#34;
            fwrite = open( fname, &#34;w+b&#34;)
            fdebug = open( &#34;debug.txt&#34;, &#34;w&#34;)

        regAddr = 0x0000
        regData = 0x0000
        RAMAddr = 0x0000
        Data = []
        rData = []
        rAddr = []
        i = 0
        j = 0
        k = 0
        z = 0
        TxLen = 0
        prevTxLen = 0
        bProgram = 0
        bProgramRAM = 0

        for row in csv_reader:
            bProgram = 0
            bProgramRAM = 0

            try:
                TxLen = int( row[4])
            except:
                print( &#34;error parsing len&#34; + str(row))
                sys.exit()
            try:
                regAddr = int( row[0], 16)
            except:
                #print( &#34;error parsing reg addr&#34; + str(row))
                regAddr = -1

            try:
                regData = int( row[1], 16)
            except:
                print( &#34;error parsing reg data&#34; + str(row))
                regData = -1

            if( TxLen &gt; 2):
                if( regAddr != -1):
                    Data.append( regAddr)                    
                if( regData != -1):
                    Data.append( regData)  
                if( len(rAddr) &gt; 0):
                    bProgram = 1
            else:
                if( self._debug):
                    fwrite.write( regAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    fwrite.write( regData.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                
                i = i + 1
                rAddr.append( regAddr)
                rData.append( regData)

                if( len( Data) &gt; 0):
                    bProgramRAM = 1
    
            if( bProgram):
                print( &#34;programming &#34; + str( len(rAddr)) + &#34; single registers&#34;)
                i = 0            
                j = j + 1
                
                if( self.dev != None):
                    self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
                    #time.sleep(2)
                    pass

                if( self._debug):
                    fwrite.close()
                    fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                    fwrite = open( fname, &#34;w+b&#34;)
                    for i in range( len( rAddr)):
                        fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)

                rData = []
                rAddr = []

            if( bProgramRAM):
                print( &#34;programming RAM &#34; + str( len(Data)*2-2) + &#34; registers&#34;)
                i = 0
                RAMAddr = []
                RAMAddr = int(Data[0])
                #Data.remove(0)
                #Data = Data[1:-1]
                del Data[0]
                if( self._debug):                
                    fwrite.write( RAMAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    for dat in Data:
                        fwrite.write( dat.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

                    fwrite.close()
                    j = j + 1
                    fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                    fwrite = open( fname, &#34;w+b&#34;)

                if( self.dev != None):
                    RAMData = np.zeros( (len( Data)*2), dtype = np.uint8)                
                    for i in range( len(Data)):
                        RAMData[2*i] = Data[i] &gt;&gt; 8
                        RAMData[2*i+1] = Data[i] &amp; 0xFF
                    self.dev.writeSPIBurst( RAMAddr, RAMData)

                if( self._debug):
                    k = 0
                    for dat in Data:
                        if k == 0:
                            fdebug.write( hex(RAMAddr) + &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                        else:
                            if( k%2 == 0):
                                fdebug.write( &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                            else:
                                fdebug.write( hex(dat))
                        k = k + 1

                    if( k%2 ==0):
                        fdebug.write(&#34;\n&#34;)
                Data = []
            k = k + 1

        if( len( rAddr) &gt; 0):
            print( &#34;programming &#34; + str( len( rAddr)) + &#34; final registers&#34;)
            i = 0
            j = j + 1

            if( self._debug):
                fwrite.close()
                fname = &#34;firmware_final.bin&#34;
                fwrite = open( fname, &#34;w+b&#34;)
                for i in range( len( rAddr)):
                    fwrite.write( rAddr[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    fwrite.write( rData[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

            if( self.dev != None):
                self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
                pass

            if( self._debug):
                for i in range( len( rAddr)):
                    fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)
        if( self._debug):
            fdebug.close()

    def PowerMonitor( self,PMId):
        &#34;&#34;&#34;This function reads the voltage, current and power measured by a given
        power monitor in the Malka board.

        :param dev: Ardacho camera pointer. 
        :type dev: Ardacho IOLib device class. 
        :param PMId: Power Monitor id. Use any of the ids defined at the top of the application script. 
        :type PMId: int      
        :returns: returns a list with the measured parameters [ Voltage, Current, Power] 
        :rtype: [ float, float, float] 
        &#34;&#34;&#34;

        CONF_REG = 0x00
        VBUS_REG = 0x02
        POWER_REG = 0x03
        SHUNT_REG = 0x01
        CURR_REG = 0x04
        CAL_REG = 0x05
        
        self.dev.writePowerMonReg( PMId, CONF_REG, 0x4007 | 2 &lt;&lt; 9 | 4 &lt;&lt; 6 | 4 &lt;&lt; 3 )
        time.sleep(0.1)
        Vbus =  self.dev.readPowerMonReg( PMId, VBUS_REG)
        Cal = self.dev.readPowerMonReg( PMId, CAL_REG)
        CUR = self.dev.readPowerMonReg( PMId, CURR_REG)
        SHUNT = self.dev.readPowerMonReg( PMId, SHUNT_REG)
        PWR = self.dev.readPowerMonReg( PMId, POWER_REG)


        Volt = round(Vbus * 1.25/1000, 3)
        if( PMId == VMAIN_DEV_ID):
            Imax = (0.00512/0.01)*((32768)/Cal) # Vmain uses 0.01 shunt resistor
        else:
            Imax = (0.00512/0.02)*((32768)/Cal) # Vaux, Vdepth and Vsys uses 0.02 shunt resistor

        ILSB = (Imax/(32768))
        Curr =  round(CUR* ILSB,6)
        PwrLSB = 25*ILSB
        Power = round(PWR * PwrLSB, 6)
        return [ Volt, Curr, Power ]


    def sensorPowerDown( self):
        &#34;&#34;&#34;
        De-initialize camera
        Inputs:
            none 

        Outputs:
            0
        &#34;&#34;&#34; 
        # De-Initialize the camera
        self.dev.setGpio( CAM_RESET_N, 0)
        self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        self.dev.setGpio( PS_VAUXVPS1, 0)
        self.dev.setGpio( PS_VAUXVPS2, 0)
        self.dev.setGpio( PS_V5VVPS3, 0)
        self.dev.setGpio( LMZ_EN, 0)
        self.dev.setGpio( CAM_RESET_N, 0)

        # Wait for CAM_SHUTDOWN_N to go low indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 0    # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            time.sleep(0.1)
            if( cam_shutdown == 0):
                break
            else:
                retries = retries - 1

        if( retries == 0):
            print( &#34;Error during camera de-initialization&#34;)
            self.dev.setGpio( DEPTH_VAUX_RUN, 0)
            self.dev.setGpio( PS_VAUXVPS2, 0)
            self.dev.setGpio( PS_VAUXVPS1, 0)
            self.dev.setGpio( PS_V5VVPS3, 0)
            self.dev.setGpio( LMZ_EN, 0)
            return -1

        return 0

          
    def sensorPowerUp( self):
        &#34;&#34;&#34;
        Implements sensor initialization sequence enabling the power regulators and making functional checks.
        Inputs:
            none 

        Outputs:
            0 
        &#34;&#34;&#34; 
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0xF8]) # MZ1: Added VAUX DAC set for 12V 
        self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9A, 0x2C]) # MZ1: Added VAUX DAC set for 22V       
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xDE]) # MZ1: Added VAUX DAC set for 27V 

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 1) # enable Vmain
        [ Vmain, Imain, Pmain] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        # MZ: Added current and voltage measurements
        print(&#39;Vmain: &#39; + str(Vmain) + &#39;, Imain: &#39; + str(Imain) + &#39;, Pmain: &#39; + str(Pmain))

        self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
        [ Vdepth, Idepth, Pdepth] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vmain
        # MZ: Added current and voltage measurements
        print(&#39;Vdepth: &#39; + str(Vdepth) + &#39;, Idepth: &#39; + str(Idepth) + &#39;, Pdepth: &#39; + str(Pdepth))
        
        self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth
        time.sleep( 0.004) # wait 4 ms

        self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
        self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
        [ Vsys, Isys, Psys] = self.PowerMonitor( VSYS_DEV_ID)
        # MZ: Added current and voltage measurements
        print(&#34;Vsys: &#34; + str(Vsys) + &#34;, Isys: &#34; + str(Isys)+&#34;, Psys: &#34; + str(Psys))
        
        time.sleep( 0.004) # wait 4 ms

        self.dev.setGpio( DEPTH_VAUX_RUN, 1)
        time.sleep(0.0001) # wait 100 us
        [ Vaux, Iaux, Paux] = self.PowerMonitor( VAUX_DEV_ID)
        # MZ: Added current and voltage measurements
        print(&#39;Vaux: &#39; + str(Vaux) +&#39;, Iaux: &#39; + str(Iaux) +&#39;, Paux: &#39; + str(Paux))

        # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            if( cam_shutdown == 1):
                break
            else:
                retries = retries - 1


        # wait 2 ms
        time.sleep( 0.002)
        self.dev.setGpio( CAM_RESET_N, 1)        

        return 0

    def bitget(self, var, pos): # !Python indexing!
        &#34;&#34;&#34;
        Returns bit in a position
        Inputs:
            var: hex or decimal 
            pos: position 

        Outputs:
            bit in the position 
        &#34;&#34;&#34; 
        return(var &gt;&gt; pos) &amp; 1

    def repmatdec2Hex(self, dec, rep):
        &#34;&#34;&#34;
        Repeats decimal as a hex
        Inputs:
            dec: decimal input 
            rep: repeat count 

        Outputs:
            hex output 
        &#34;&#34;&#34; 
        hexval = hex(dec).split(&#39;x&#39;)[-1]
        out = &#39;&#39;
        for _ in range(rep):
            out = out + hexval
        return int(&#39;0x&#39; + out.upper(),0)

    def get_addr_hex2dec(self, addr, k):
        &#34;&#34;&#34;
        Repeats decimal as a hex with padding
        Inputs:
            addr: address 
            k: repeat count 

        Outputs:
            hex output with padding 
        &#34;&#34;&#34; 
        dec = int(addr,0) + k*2
        hex_raw = hex(dec).split(&#39;x&#39;)[-1]
        pad_zero = 4 - len(hex_raw)
        return (&#39;0x&#39; + &#39;0&#39;*pad_zero + hex_raw)

    def generate_truthtable(self, n):
        &#34;&#34;&#34;
        Generates a &#39;truth table&#39; of n variables
        Inputs:
            n: variable length 

        Outputs:
            truth table 
        &#34;&#34;&#34;
        if n &lt; 1:
            return [[]]
        subtable = self.generate_truthtable(n - 1)
        return [ row + [v] for row in subtable for v in [0,1] ]

    def ReadAmpGainSetting(self):
        &#34;&#34;&#34;
        Reads amplifier gain setting
        Inputs:
            none 

        Outputs:
            amp gain setting 
        &#34;&#34;&#34; 
        val = self.regread(0x014E) # Analog NCDS mode bit
        # self.error_assert(success, &#39;Cannot read Analog NCDS mode bit&#39;)
        ncds_mode = self.bitget(int(val), 3)

        if ncds_mode:
            Cin = np.array([160,80,80]) # For ADSD3100, Cin is different between analog and digital CDS modes
        else:
            Cin = np.array([320,160,80])

        Cfb = np.array([4*25.88,2*20.24,2*6.76,2*5.17,2*3.57]) # gain= (160*cin1+80*cin0+80)/(2*3.57+2*5.17*cfb0+2*6.76*cfb1+2*20.24*cfb2+4*25.88*cfb3)

        tmp1 = np.sum(np.array(self.generate_truthtable(2)) * Cin[0:2], axis=1) + Cin[2]
        tmp2 = np.sum(np.array(self.generate_truthtable(4)) * Cfb[0:4], axis=1) + Cfb[4]
        ampgainTable = np.transpose(np.reshape(tmp1,[1,len(tmp1)])) / tmp2

        # plt.plot(ampgainTable[0,:], label=&#34;Cin=0&#34;)
        # plt.plot(ampgainTable[1,:], label=&#34;Cin=1&#34;)
        # plt.plot(ampgainTable[2,:], label=&#34;Cin=2&#34;)
        # plt.plot(ampgainTable[3,:], label=&#34;Cin=3&#34;)
        # plt.legend()
        # plt.ylabel(&#39;Gain&#39;)
        # plt.xlabel(&#39;Cfb&#39;)
        # plt.title(&#39;ampgainTable&#39;)
        # plt.show()

        # Manually update table with gains measured on ADSD3100
        ampgainTable[3,1] = 16.75
        ampgainTable[3,2] = 14.7
        ampgainTable[3,4] = 6.8
        ampgainTable[3,11] = 2.35
        ampgainTable[0,8] = 0.72


        RegisterValueCin = self.regread(0x010E) # AMP Cin register
        # self.error_assert(success, &#39;Cannot read AMP Cin register&#39;)
        RegisterValueCfb = self.regread(0x010C) # AMP Cfb register
        # self.error_assert(success, &#39;Cannot read AMP Cfb register&#39;)

        ampgain = np.zeros(4)

        for i in range(4):
            Cfb = (int(RegisterValueCfb) &gt;&gt; i*4) &amp; 15
            Cin = (int(RegisterValueCin) &gt;&gt; i*4) &amp; 3
            ampgain[i] = ampgainTable[Cin, Cfb]

        return ampgain

    def SetDiffDacSfVoltage(self, DacCal, DacSel, TargetDiff, CMwindow, DacCal_folderName=&#34;&#34;):
        &#34;&#34;&#34;
        Sets differential DAC voltage
        Inputs:
            DacCal: DAC calibration values 
            DacSel: DAC selection ex: AMPTEST0 etc 
            TargetDiff: Voltage difference 
            CMWindow: CommonMode window 
            DacCal_folderName: location of file to store DacCal values 

        Outputs:
            DacCal : DAC calibration values 
            AMPTEST0, AMPTEST1, CMREF values 
            diff_meas_out: measured differential voltage 

        &#34;&#34;&#34; 
        #s, valArr = self.regreadburst(0x0E00, 80,&#39;increment&#39;)
        self.regwrite(0x0014,0x0000)
        #print(valArr)
        NUM_ITERATIONS = 1
        MAX_ERROR = [5e-3, 15e-3]

        if len(list(DacCal.keys())) == 0:
            CMREF_Samples = [150, 203, 255]
            AMPTEST_Samples = [150, 176, 203, 229, 255]
            CMREF_meas = np.zeros(len(CMREF_Samples))
            AMPTEST0_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
            AMPTEST1_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
            for j in range(len(CMREF_Samples)-1, -1,-1):
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF_Samples[j]))
                success = self.dac_cmref_set(np.uint8(CMREF_Samples[j]))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                CMREF_meas[j] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF&#39;)
                for k in range(len(AMPTEST_Samples)-1,-1,-1):
                    # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                    success = self.dac_amptest0_set(np.uint8(AMPTEST_Samples[k]))
                    self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
                    # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                    success = self.dac_amptest1_set(np.uint8(AMPTEST_Samples[k]))
                    self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)
                    AMPTEST0_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0&#39;)
                    AMPTEST1_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1&#39;)
            y,x = np.meshgrid(AMPTEST_Samples,CMREF_Samples)
            Xmeas = [[np.ones([len(CMREF_Samples)*len(AMPTEST_Samples)])], [np.transpose(x).flatten()],
                    [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
            Xmeas = np.squeeze(np.transpose(Xmeas))
            M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST0_meas).flatten(), rcond=None)[0] # Matrix left division

            [y,x] = np.meshgrid(range(0,256), range(0,256))
            Xfit = [[np.ones([np.size(y)])], [np.transpose(x).flatten()],
                    [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
            Xfit = np.squeeze(np.transpose(Xfit))
            DacCal[&#39;AMPTEST0_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

            M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST1_meas).flatten(), rcond=None)[0] # Matrix left division
            DacCal[&#39;AMPTEST1_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

            # Dacs are non-linear at low code values, so remove these points from the predicted data
            DacCal[&#39;AMPTEST0_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
            DacCal[&#39;AMPTEST0_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan
            DacCal[&#39;AMPTEST1_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
            DacCal[&#39;AMPTEST1_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan

            DacCal[&#39;CMREF_pred&#39;] = np.polyval(np.polyfit(CMREF_Samples, CMREF_meas, 1),range(0,256))
            DacCal[&#39;CMREF_pred&#39;][0:np.min(CMREF_Samples)] = np.nan # Remove CMREF values below min sampled DAC code

            DacCal[&#39;RangeCMREF&#39;] = np.array([CMREF_meas[-1], CMREF_meas[0]])
            DacCal[&#39;RangeAMPTEST0&#39;] = np.array([np.max(AMPTEST0_meas[:,0]), np.min(AMPTEST0_meas[:,-1])])
            DacCal[&#39;RangeAMPTEST1&#39;] = np.array([np.max(AMPTEST1_meas[:,0]), np.min(AMPTEST1_meas[:,-1])])
            if(DacCal_folderName != &#34;&#34;):
                f = open(os.path.join(DacCal_folderName, &#39;DacCal.pkl&#39;), &#39;wb&#39;)
                pickle.dump(DacCal, f)
                f.close()


        if DacSel.upper() == &#39;CMREF-AMPTEST0&#39;:
            # Sanity check inputs
            if (np.max(CMwindow) + TargetDiff/2) &lt; DacCal[&#39;RangeCMREF&#39;][0]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0])))
        
            if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

            diff = -(-np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;]).astype(np.float)
            cm = 0.5 * (np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;])

            diff = diff.astype(np.float)
            cond1 = ~np.isnan(cm)
            cond2 = ~np.isnan(cm)
            cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
            cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
            diff[cond1] = np.nan
            diff[cond2] = np.nan

            x,y = np.shape(diff)

            tmp = (abs(diff - TargetDiff)).flatten()
            error_pred = np.sort(tmp)
            idx = np.argsort(tmp)

            if error_pred[0] &gt; MAX_ERROR[1]:
                print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
                logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

            if NUM_ITERATIONS &gt; 1:
                diff_meas = np.zeros(NUM_ITERATIONS)

            for i in range(NUM_ITERATIONS):
                CMREF = int(idx[i] % x)
                AMPTEST0 = int(np.floor(idx[i] / x))

                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
                success = self.dac_cmref_set(np.uint8(CMREF))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
                success = self.dac_amptest0_set(np.uint8(AMPTEST0))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

                if NUM_ITERATIONS &gt; 1:
                    diff_meas[i] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)

            if NUM_ITERATIONS &gt; 1:
                idxMinErr = np.argmin(np.abs(TargetDiff - diff_meas))
                CMREF = int(idxMinErr[i] % x)
                AMPTEST0 = int(np.floor(idxMinErr[i] / x))
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
                success = self.dac_cmref_set(np.uint8(CMREF))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
                success = self.dac_amptest0_set(np.uint8(AMPTEST0))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

            cmSetpoint = cm[AMPTEST0-1, CMREF-1] # get predicted CM voltage
            AMPTEST1 = np.nanargmin(np.abs(cmSetpoint - DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF-1]))
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST1))
            success = self.dac_amptest1_set(np.uint8(AMPTEST1))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

            if NUM_ITERATIONS &gt; 1:
                diff_meas_out = diff_meas[idxMinErr]
            else:
                diff_meas_out = -self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)            

        elif DacSel.upper() == &#39;AMPTEST1-AMPTEST0&#39;:
            # Sanity check inputs
            if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

            if (np.max(CMwindow) - TargetDiff/2) &lt; DacCal[&#39;RangeAMPTEST0&#39;][0]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0])))


            CMREF = np.nanargmin(np.abs(np.mean(CMwindow) - DacCal[&#39;CMREF_pred&#39;]))

            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF))
            success = self.dac_cmref_set(np.uint8(CMREF))
            self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)

            diff = -np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1])
            cm = 0.5 * (np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1]))

            diff = -diff.astype(np.float)
            cond1 = ~np.isnan(cm)
            cond2 = ~np.isnan(cm)
            cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
            cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
            diff[cond1] = np.nan
            diff[cond2] = np.nan

            x,y = np.shape(diff)

            tmp = (abs(diff - TargetDiff)).flatten()
            error_pred = np.sort(tmp)
            idx = np.argsort(tmp)

            if error_pred[0] &gt; MAX_ERROR[1]:
                print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
                logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

            AMPTEST1 = int(idx[0] % x)
            AMPTEST0 = int(np.floor(idx[0] / x))

            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
            success = self.dac_amptest0_set(np.uint8(AMPTEST0))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], AMPTEST1)
            success = self.dac_amptest1_set(np.uint8(AMPTEST1))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

            diff_meas_out = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)

        # print(self.regreadburst(0x0E00, 80,&#39;increment&#39;))
        # s = self.regwriteburst(0x0E00, valArr, &#39;increment&#39;)
        self.regwrite(0x0014,0x0000)

        return DacCal, {&#39;CMREF&#39;: CMREF, &#39;AMPTEST0&#39;: AMPTEST0, &#39;AMPTEST1&#39;: AMPTEST1}, diff_meas_out

    def UpdateUseCaseFrameSetting(self, usecaseId, fieldname, fieldVal):
        &#34;&#34;&#34;
        Updates use case frame setting
        Inputs:
            usecaseId 
            fieldname 
            fieldVal 

        Outputs:
            success: status 
        &#34;&#34;&#34; 

        status = 0
        prevVal = 0

        if (usecaseId &lt; 0 or usecaseId &gt; 15):
            return False, False

        if fieldname == &#39;DRAINSTYLE&#39;:
            fieldIndex = 7
        else:
            return False, False

        # Offset 7 is where the use case entries start in
        # DMEM1, there are Frame Details and 3 ROIs per use case (4)
        ADDR = 7 + usecaseId * 4

        # Using Bank Addressing Scheme instead of auto bank addressing using LSBs
        # of the address due to bug in addressing the entire address space
        #
        # Separate out Bank ID and Bank Address
        # (2 LSBs indicate Bank ID)

        BANK_ID = int(ADDR) &amp; 3
        BANK_ADDR = ADDR &gt;&gt; 2
        IA_SELECT_VAL = (BANK_ID &lt;&lt; 8) + 2

        status = self.regwrite(0x0500, IA_SELECT_VAL)
        status = status and (self.regwrite(0x0502, BANK_ADDR))

        if status:
            status, usecaseVals = self.regreadburst(0x0506, 32)
            if status:
                usecaseVals = np.squeeze(usecaseVals)
                prevVal = usecaseVals[fieldIndex - 1]

                usecaseVals[fieldIndex - 1] = fieldVal

                status = self.regwrite(0x502, BANK_ADDR)
                status = status and self.regwriteburst(0x0504, usecaseVals)

        return status, prevVal

    def tregwrite(self, regaddr, regval, regmask = 0):
        &#34;&#34;&#34;
        Write to register while saving original value
        Inputs:
            regaddr: register address 
            regval: register value 
            regmask: register mask 

        Outputs:
            success: status of write 
        &#34;&#34;&#34; 
        if regmask == 0:
            origVal = self.regread(regaddr)
            success = self.regwrite(regaddr, regval)
        else:
            # if regmask == &#39;increment&#39;:
            #   origVal, success = self.regreadburst(regaddr, len(regval), &#39;increment&#39;)
            #   success = success and self.regwriteburst(regaddr, regval, &#39;increment&#39;)
            # else:
            origVal = self.regread(regaddr)
            success = self.regrmw(regaddr, regval, regmask)

        if (regaddr in self.origSetting[&#39;reg&#39;][&#39;addr&#39;]) == False:
            self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], regaddr)
            self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], origVal)

        return success

    def WriteOrigSettings(self):
        &#34;&#34;&#34;
        Writes back original settings to the registers based on tregwrite
        Inputs:
            none 

        Outputs:
            none 
        &#34;&#34;&#34; 
        rs = True
        for ns in range(len(self.origSetting[&#39;reg&#39;][&#39;addr&#39;])-1,-1,-1):
            # if len(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]) &gt; 1:
            #   rs = rs and self.regwriteburst(1, 
            #                                       str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]),
            #                                       self.convert2matlabArray(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]),
            #                                       &#39;increment&#39;)
            # else:
            # rs = rs and self.regwrite(1, str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]), int(float(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])))
            rs = rs and self.regwrite(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns], self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])

            # self.error_assert(rs, &#39;Cannot restore original register settings&#39;)

    def InitModes(self, clksValue_0, LockScale_0):
        &#34;&#34;&#34;
        Initialize sensor mode
        Inputs:
            clksValue_0 
            LockScale_0 

        Outputs:
            mode: returns information of the mode
        &#34;&#34;&#34; 
        name = [&#39;native_resolution&#39;, &#39;sub_sampled_2x&#39;, &#39;sub_sampled_4x&#39;, &#39;binned&#39;, &#39;dark&#39;, &#39;preamble&#39;, &#39;postamble&#39;]
        tmp = int(&#39;0x0E30&#39;, 0) + 6* np.arange(0,len(name))
        regAddrStart = tmp
        regAddrEnd = tmp + 2
        regAddrRepeat = tmp + 4

        name = np.append(name, &#39;binned_1x2&#39;)
        regAddrStart = np.append(regAddrStart, int(&#39;0x0E12&#39;, 0))
        regAddrEnd = np.append(regAddrEnd, int(&#39;0x0E1A&#39;, 0))
        regAddrRepeat = np.append(regAddrRepeat, int(&#39;0x0E02&#39;, 0))

        repeatCount = np.zeros(len(name))
        clksValue = np.zeros(len(name), dtype=object)
        LockScale = np.zeros(len(name), dtype=object)
        for i in range(len(name)):
            clksValue[i] = clksValue_0 
            LockScale[i] = LockScale

        mode = dict(
                    name = name,
                    repeatCount = repeatCount,
                    regAddrStart = regAddrStart,
                    regAddrEnd = regAddrEnd,
                    regAddrRepeat = regAddrRepeat,
                    clksValue = clksValue,
                    LockScale = LockScale
                    )
        return mode

    def DumpTimingTool(self, var1, var2 = 0, handles = dict()):
        &#34;&#34;&#34;
        Read / write dump engine timing
        Inputs:
            var1: read or write to chip 
            var2: 0-&gt; initialize Dump Engine Structure 
            handles: contains handles to add data to 

        Outputs:
            handles: Updates handles 
        &#34;&#34;&#34; 
        if var1 == &#39;ReadfromChip&#39;:
            if var2 == 0:
                handles = self.InitDE_Struct()

            chipID = self.regread(0x112)

            digPwrDownOrigState = self.regread(0x0014, handles[&#39;dispStr&#39;])
            success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; int(&#39;0xFFFE&#39;,0), handles[&#39;dispStr&#39;])
            self.error_assert(success, &#34;Failed to un-clock gate DE&#34;)

            handles[&#39;DEclkFreq&#39;] = self.ReadDEclkFreqFromChip()

            for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])):
                RamStart = self.regread(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i]) # Read dump engine settings from chip
                RamEnd = self.regread(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i])
                handles[&#39;mode&#39;][&#39;repeatCount&#39;][i] = self.regread(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i])
                success = self.regwrite(0x0E04, 0x0001)
                success = success and self.regwrite(0x0E06, RamStart)
                self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
                success, RamVals = self.regreadburst(0x0E0A, (RamEnd-RamStart+1)*4)
                success = success and self.regwrite(0x0E04, 0x0000)
                self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
                # clksValue = self.API.legacy_ConvertDumpEngineRamFormatToWaves(RamVals)
                # clksValue = np.array(clksValue) # convert to numpy array
                clksValue = self.ConvertDumpEngineRamFormatToWaves(RamVals)
                handles[&#39;mode&#39;][&#39;clksValue&#39;][i] = clksValue[(handles[&#39;clks&#39;][&#39;DE_Addr&#39;]).astype(&#39;int&#39;), :]

            success = success and self.regwrite(0x0014, digPwrDownOrigState)
            self.error_assert(success, &#39;Failed to restore original DE clock gate state&#39;)

            return handles
        
        elif var1 == &#39;WriteToChip&#39;:
            StartAddr = 0
            [regAddValPairs, ramBlob, memoryUsedPercent] = self.GenerateDumpEngineConfig(handles, StartAddr)
            print(&#39;Using&#39;, np.round(memoryUsedPercent), &#39;%&#39;, &#39;of dump engine RAM&#39;)
            logging.info(&#39;Using &#39; + str(np.round(memoryUsedPercent)) + &#39; %&#39; + &#39; of dump engine RAM&#39;)
            digPwrDownOrigState = self.regread(0x0014) # Load digPwrDown state
            success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; 0xFFFE)
            self.error_assert(success, &#39;Failed to un-clock gate DE&#39;)
            success = success and self.regwrite(regAddValPairs[::2], regAddValPairs[1::2]) # Start/End/Repeat values
            success = success and self.regwrite(0x0E04, 0x0001) # Enable configuration of the Dump Engine RAM
            success = success and self.regwrite(0x0E06, StartAddr) # dump engine ia_addr_reg is 0x0E06
            success = success and self.regwriteburst(0x0E08, ramBlob) # Write to RAM
            success = success and self.regwrite(0x0E04, 0x0000) # Disable configuration of the Dump Engine RAM

            success = success and self.regwrite(0x0014, digPwrDownOrigState) # Restore original DE clock gate state
        else:

            return False

    def DumpTimingTransformation(self, *argv):
        &#34;&#34;&#34;
        Perform Dump Engine transformations
        Inputs:
            variable arguments as below
            DE_struct: Dump Engine structure dictionary 
            mode: sensor mode such as native, binned etc 
            transformtion 

        Outputs:
            DE_struct: updated DE_struct
        &#34;&#34;&#34; 
        DE_Struct = argv[0]
        mode = argv[1]
        signalName = argv[2]
        transformation_tmp = argv[3]
        DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;])

        tmp = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == mode)
        modeIdx = tmp[0][0]

        if len(signalName) &gt; 0: # is array
            signalIdx = np.zeros(len(signalName))
            for i in range(len(signalName)):
                if transformation_tmp.startswith(&#39;ampTestSel_&#39;):
                    signalIdx[i] = 0
                else:
                    tmp = np.where(DE_Struct[&#39;clks&#39;][&#39;Name&#39;] == signalName[i])
                    signalIdx[i] = tmp[0][0]
        
        elif len(signalName) == 0:
            signalIdx = np.zeros(1)
            signalIdx[0] = 0

        transformation = np.zeros(len(signalIdx),dtype=object)
        for i in range(len(signalIdx)):
            transformation[i] = transformation_tmp

        # Perform transformations
        for signalCnt in range(len(signalIdx)):
            clkData = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt]),:]

            if transformation[signalCnt].startswith(&#39;ampTestSel_&#39;):
                MUX_TRANSITION_DELAY = 1
                idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 24)[0][0] # DR_Addr = 24 is amp_clk0
                ampclk = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
                idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 25)[0][0] # DR_Addr = 25 is amp_clk1
                ampclk = ampclk + 2 * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
                tmp1 = ampclk == 1
                tmp2 = ampclk == 3
                integrateSample = tmp1 | tmp2
                integrateSample = np.roll(integrateSample, MUX_TRANSITION_DELAY)
                amp_testsel_name = np.array([&#39;ATP&#39;,&#39;ATN&#39;,&#39;DACAMPTEST0&#39;,&#39;DACAMPTEST1&#39;,&#39;DACCMREF&#39;])
                amp_testsel_mux = np.array([[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1]])
                inputList = transformation[0].split(&#39;_&#39;)

                amp_testselp_reset_val = amp_testsel_mux[(np.where(inputList[1].upper() == amp_testsel_name))[0][0],:]
                amp_testseln_reset_val = amp_testsel_mux[(np.where(inputList[2].upper() == amp_testsel_name))[0][0],:]
                amp_testselp_int_val = amp_testsel_mux[(np.where(inputList[3].upper() == amp_testsel_name))[0][0],:]
                amp_testseln_int_val = amp_testsel_mux[(np.where(inputList[4].upper() == amp_testsel_name))[0][0],:]

                amp_testselp_idx = np.zeros(3, dtype=int)
                amp_testseln_idx = np.zeros(3, dtype=int)
                amp_testselp_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 37))[0][0]) # DR_Addr = 37 is amp_testselp[0] (ADSD3100)
                amp_testselp_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 42))[0][0]) # DR_Addr = 42 is amp_testselp[1] (ADSD3100)
                amp_testselp_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 43))[0][0]) # DR_Addr = 43 is amp_testselp[2] (ADSD3100)
                amp_testseln_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 44))[0][0]) # DR_Addr = 44 is amp_testseln[0] (ADSD3100)
                amp_testseln_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 45))[0][0]) # DR_Addr = 45 is amp_testselp[1] (ADSD3100)
                amp_testseln_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 46))[0][0]) # DR_Addr = 46 is amp_testselp[2] (ADSD3100)

                for k in range(3):
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k],:] = 0 # default all amp_testsel signals low
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k],:] = 0

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], np.invert(integrateSample)] = amp_testselp_reset_val[k] # amp_testselp reset
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], np.invert(integrateSample)] = amp_testseln_reset_val[k] # amp_testseln reset

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], integrateSample] = amp_testselp_int_val[k] # amp_testselp integer
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], integrateSample] = amp_testseln_int_val[k] # amp_testseln integer

            else:
                if transformation[signalCnt].startswith(&#39;copyTo&#39;):
                    destMode = transformation[signalCnt][6:]
                    destModeIdx = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == destMode.lower())[0][0] #+ 1

                    sourceLength = list(np.shape(clkData))[0]
                    destLength = list(np.shape(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]))[1]
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:]

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])


                    if sourceLength &gt; destLength:
                        for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                            append_bits = np.ones(sourceLength-destLength) * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][-1]
                            DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = np.append(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i], append_bits)
                    elif sourceLength &lt; destLength:
                        for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                            DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][0:sourceLength]

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]  = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][(signalIdx).astype(int),:]

                else:
                    print(&#39;Unknown tranformation&#39;)
                    logging.error(&#39;Unknown transformation&#39; + str(transformation[signalCnt]))

            if transformation[signalCnt] != &#39;stretchshrink&#39;:
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt])] = clkData

        return DE_Struct

    def InitDE_Struct(self, *argv):
        &#34;&#34;&#34;
        Initialize a dump engine structure
        Inputs:
            variable arguments 

        Outputs:
            DE_struct:  Dump engine structure dictionary 
        &#34;&#34;&#34; 
        NCLKS_INIT = 8
        DE_Struct = dict()
        if len(argv) &gt; 0:
            DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = argv[0]
        else:
            DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = False

        if len(argv) &gt; 1:
            DE_Struct[&#39;dispStr&#39;] = argv[1]
        else:
            DE_Struct[&#39;dispStr&#39;] = &#39;&#39;

        DE_Struct[&#39;clks&#39;], clksValue, LockScale = self.ReadConfigFile(&#39;./config/DumpTimingToolConfig_ADSD3100.csv&#39;)
        clksValue = np.transpose(np.reshape(clksValue, [1, len(clksValue)]))
        clksValue = clksValue * np.ones([1, NCLKS_INIT])

        DE_Struct[&#39;mode&#39;] = self.InitModes(clksValue, LockScale)

        return DE_Struct

    def ReadConfigFile(self, fname):
        &#34;&#34;&#34;
        Read dump engine configuration file (.csv)
        Inputs:
            fname: csv filename 

        Outputs:
            DE_struct: updated DE_struct 
        &#34;&#34;&#34; 
        clks = dict()
        clks[&#39;DE_Addr&#39;] = []
        clks[&#39;Name&#39;] = []
        clks[&#39;View&#39;] = []
        DefaultValue = []
        LockScale_Default = []
        clks[&#39;ToolTip&#39;] = []

        # path = os.path.dirname(os.path.abspath(__file__))
        # with open(os.path.join(path,fname)) as csv_file:
        with open(fname) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
            line_count = 0
            for row in csv_reader:
                if line_count == 0:
                    line_count += 1
                else:
                    clks[&#39;DE_Addr&#39;] = np.append(clks[&#39;DE_Addr&#39;], int(row[0]))
                    clks[&#39;Name&#39;]  = np.append(clks[&#39;Name&#39;] , row[1])
                    clks[&#39;View&#39;] = np.append(clks[&#39;View&#39;], bool(row[2]))
                    DefaultValue = np.append(DefaultValue, int(row[3]))
                    LockScale_Default = np.append(LockScale_Default, int(row[4]))
                    clks[&#39;ToolTip&#39;] = np.append(clks[&#39;ToolTip&#39;], row[5])
        csv_file.close()

        return clks, DefaultValue, LockScale_Default

    def ReadDEclkFreqFromChip(self):
        &#34;&#34;&#34;
        Read dump engine clock frequency
        Inputs:
            none 

        Outputs:
            adc_pllFreq/clk_de_div : adc pll frequency divied by DE clock division 
        &#34;&#34;&#34; 
        adcPllRegisterValue = self.regread(0x010A) # Read ADC PLL register
        adc_c = int(adcPllRegisterValue) &amp; 31
        adc_end5 =  (int(adcPllRegisterValue) &gt;&gt; 8) &amp; 15
        adc_pllFreq = 24*(adc_end5 + 4*(adc_c+1))

        clkDeRegisterValue = self.regread(0x011A) # Read Clock DE register
        de_c = int(clkDeRegisterValue) &amp; 31
        de_end5 = (int(clkDeRegisterValue) &gt;&gt; 8) &amp; 15
        clk_de_div = de_end5 + 4*(de_c+1)

        return adc_pllFreq/clk_de_div

        return clks, DefaultValue, LockScale_Default

    def GenerateDumpEngineConfig(self, handles, ramStart):
        &#34;&#34;&#34;
        Generates DE config register address value pairs
        Inputs:
            handles 
            ramStart: RAM start address 

        Outputs:
            regAddValPairs: register address value pairs 
            ramBlob: sorted clksValue in DE RAM format 
            memoryUsedPercent: RAM memory percent used 
        &#34;&#34;&#34; 
        ramOffset = ramStart
        ramBlob = []
        regAddValPairs = []
        signalOrderIdx = np.argsort(handles[&#39;clks&#39;][&#39;DE_Addr&#39;])

        for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])): # Error prone ,not !
            # outputData = self.API.legacy_ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
            outputData = self.ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i], ramOffset))
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i], ramOffset + len(outputData)/4 -1))
            ramOffset = ramOffset + len(outputData)/4
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i], handles[&#39;mode&#39;][&#39;repeatCount&#39;][i]))
            ramBlob = np.append(ramBlob, outputData)

        memoryUsedPercent = (ramOffset/(1024-6))*100

        if memoryUsedPercent &gt; 100:
            raise Exception(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
            logging.error(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
        
        return regAddValPairs, ramBlob, memoryUsedPercent

    def ConvertDumpEngineRamFormatToWaves(self, RamVals):
        &#34;&#34;&#34;
        Convert DE RAM format to wave format
        Inputs:
            RamVals: RAM values 

        Outputs:
            clksValue: clocks values 
        &#34;&#34;&#34; 
        RamVals = np.squeeze(np.array(RamVals).astype(np.uint16))
        DE_Vectors = RamVals.view(np.uint64) &amp; ((2**48)-1) # signals [47:0]
        duration = RamVals[3::4] # bits [63:48]
        DE_VectorsExpanded = np.repeat(DE_Vectors, duration+1)
        if len(DE_VectorsExpanded) == 0:
            clksValue = np.array[[]]
        else:
            clksValue = np.zeros([48, len(DE_VectorsExpanded)])
            for i in range(len(DE_VectorsExpanded)):
                clksValue[:,i] = list(np.binary_repr(DE_VectorsExpanded[i],48))[::-1] 
                # Expand out individual bits, LSB first (convert to double)
        
        return np.array(clksValue)

    def ConvertWavesToDumpEngineRamFormat(self, clksValue):
        &#34;&#34;&#34;
        Convert wave format to DE RAM format
        Inputs:
            clksValue: clocks values 

        Outputs:
            RamVals: RAM values 
            
        &#34;&#34;&#34; 
        DE_Vectors = np.dot(np.transpose(clksValue),np.array((2**(np.arange(0,np.shape(clksValue)[0],dtype=np.uint64)))))
        # Least significant bit first! Matrix multiplication is not supported on integer classes, so
        # keep as double precision here and convert to uint64 before adding the repeat count bits.
        idx = np.where(np.diff(np.append(-1, DE_Vectors)) != 0) # Time index for each unique signal state
        duration = np.diff(np.append(idx, len(DE_Vectors))) - 1 # Duration of each state
        RAM_Data = np.uint64(duration * (2**48)) + np.uint64(DE_Vectors[idx]) # Repeat count [63:48], signals [47:0]
        RamVals = RAM_Data.view(np.uint16) # Output in 16bit chunks
        
        return RamVals

    # MZ: Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation
    def InvertLSMOD( self):
        &#34;&#34;&#34;
        Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation
        Inputs:
            none

        Outputs:
            none
            
        &#34;&#34;&#34; 
        lsmod_cfg1 = self.dev.readSPISingle( 0x0138,1)
        val = lsmod_cfg1[0]
        val = ((val &amp; 0x0F) &lt;&lt; 4) + ((lsmod_cfg1[0] &amp; 0xF0) &gt;&gt; 4)
        print (&#34;Swapped = &#34;+ hex(val))
        self.dev.writeSPISingle(0x0138, val)
        print(&#34;LSMOD1L Config = &#34;+ hex(val))

    #  MZ: Function to program Archer config registers (I2C only)
    def ConfigADSD3000( self,slaveID,cfg):
        &#34;&#34;&#34;
        Function to program Archer config registers (I2C only)
        Inputs:
            slaveID: I2C slave ID 
            cfg: configuration array 

        Outputs:
            none
            
        &#34;&#34;&#34; 
        for i in range(cfg.shape[0]):
            addr_hi = (cfg[i,0]&gt;&gt;8) &amp; 0xFF
            addr_lo = cfg[i,0] &amp; 0xFF
            data_hi = (cfg[i,1]&gt;&gt;8) &amp; 0xFF
            data_lo = cfg[i,1] &amp; 0xFF
            self.dev.writeI2C(I2C_MODULE, slaveID, [addr_hi, addr_lo, data_hi, data_lo]) 
    
    
    def GetLDTemp( self, skipPtrSet, driver):
        &#34;&#34;&#34;
        Function read LD temperature
        Inputs:
            skipPtrSet: skip pointer set 
            driver: driver name 

        Outputs: 
            TempOut: Temperature  
            
        &#34;&#34;&#34; 
        TempOut = 999
        # return TempOut
        if driver == ARCHER:
            if skipPtrSet == False:
                self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x07]) # TempSense No Burst
                #self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x01]) # TempSense during bursts
            rd_reg = self.dev.readI2C(I2C_MODULE, ADSD3000_ID, 2)
            print(&#39;DigTemp:&#39;,str(rd_reg[0]*0x100+rd_reg[1]))
            TempOut = (rd_reg[0]*0x100+rd_reg[1])*0.389214 - 1134.766
        if driver == INTERSIL:
            if skipPtrSet == False:
                self.dev.writeI2C(I2C_MODULE, TEMP_SENSE_ID, [TEMP_REG, 0, 0])
            #TempDig = [0,0]
            TempDig = self.dev.readI2C(I2C_MODULE, TEMP_SENSE_ID, 2)
            TempOut = (TempDig[0]*0x100 + TempDig[1])&gt;&gt;4
            if TempOut &gt; 0x7FF:
                TempOut = ((TempOut ^ 0xFFF) + 1)*-0.0625
            else:
                TempOut = TempOut*0.0625
        return TempOut</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="CalibAPI.ICQtest"><code class="name flex">
<span>def <span class="ident">ICQtest</span></span>(<span>measurement, test_min, test_max)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes whether a test has passed or failed</p>
<h2 id="inputs">Inputs</h2>
<p>measurement: measured value<br>
test_min: minimum limit<br>
test_max: maximum limit
</p>
<h2 id="outputs">Outputs</h2>
<p>ret: status of test in string<br>
tests_failed: status of test in boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ICQtest(measurement, test_min, test_max):
    &#34;&#34;&#34;
    Computes whether a test has passed or failed
    Inputs:
        measurement: measured value  
        test_min: minimum limit  
        test_max: maximum limit  

    Outputs:
        ret: status of test in string  
        tests_failed: status of test in boolean  

    &#34;&#34;&#34;
    if(measurement&gt;test_min and measurement&lt;test_max):
        ret = &#34;PASSED&#34;
        tests_failed = 0
    else:
        ret = &#34;FAILED&#34;
        tests_failed = 1
    return ret, tests_failed</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CalibAPI.CalibAPI"><code class="flex name class">
<span>class <span class="ident">CalibAPI</span></span>
<span>(</span><span>module_class='Legacy', n_modes_cfg=10, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class constructor</p>
<p>:returns: None<br>
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalibAPI:

    def __init__( self, module_class = &#34;Legacy&#34;, n_modes_cfg = 10, debug = False):
        &#34;&#34;&#34;Class constructor
        
        :returns: None  
        :rtype: None  
        &#34;&#34;&#34;
        print(&#34;module class = &#34; + str(module_class))
        self.bProgrammed = False
        self.Mode = 3
        self.width = 1024
        self.height =1024
        self.subFrames = 1
        self._debug = debug
        self.fps = 30
        self.module_class = module_class
        self.rawImage = np.zeros( (self.height, self.width, self.subFrames), dtype = np.int16)
        self.pRAW = np.zeros( (self.height, self.width * self.subFrames), dtype = np.int16)
        self.rawN = np.zeros( [100, (self.height* self.width * self.subFrames)], dtype = np.int16)
        self.unwrappedDepth = np.zeros( (self.height, self.width), dtype = np.double)
        self.nPhases = 0
        self.nFreq = 0
        self.freqs = []
        # self.dev = ArdachoIOLib.ArdachoIOLib() #IOLib.tof_device() $$
        self.dev = tofdevice.tof_device()
        self.dac_amptest0 = 255
        self.dac_amptest1 = 182
        self.dac_cmref = 255
        self.firstStart = True
        self.flag = 0
        self.prevVoltage = 0
        self.origSetting = dict()
        self.origSetting[&#39;reg&#39;] = dict()
        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.array([],dtype=np.uint16)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.array([],dtype=np.uint16)
        self.n_modes_cfg = n_modes_cfg


    def __del__(self):
        &#34;&#34;&#34;Class destructor, deinitializes the camera.
        
        :returns: None  
        :rtype: None  
        &#34;&#34;&#34;
        self.Stop()

        ret = self.sensorPowerDown()
        if( ret &lt; 0):
            print(&#34;Error during sensor power down. Please restart your system&#34;)       

    def error_assert(self, var, message):
        &#34;&#34;&#34;
        Raises error if the test has failed with a message
        Inputs:
            var: status of test  
            message: error message to display  
        Outputs:
            none  

        &#34;&#34;&#34;
        if var == False:
            raise Exception(message)
            try:
                logging.error(message)
            except:
                pass


    def Start( self):
        &#34;&#34;&#34;
        Command to start the camera. First checks if the microsequencer
        has started.
        Inputs:
            none  

        Outputs:
            none  

        &#34;&#34;&#34;
        self.dev.writeSPISingle( 0x000C, 0x00C5)
        time.sleep(0.1) #Delay required for useq
        
        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))
            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                time.sleep(0.5)
                data = self.dev.readSPISingle( 0x0256,1 )
                data = data[0]
                print(&#34;data retry = &#34; + hex(data))
                if( data == 0x02):
                    print(&#34;uSeq running&#34;)
                    break
                else:
                    errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                    print( &#34;Error = &#34; + hex(errorCode))
                
        if( errorCode != 0x0 or data == 0x00):
            sys.exit()
        
        self.dev.startSensor()
      
        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)


    def Stop(self):
        &#34;&#34;&#34;
        Command to stop the camera
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;
        i = 0
        
        # self.dev.setGpio( MPSOC_SYNC_SEL0, 0)
        # self.dev.setGpio( MPSOC_SYNC_SEL1, 0)
        # self.dev.setGpio( MPSOC_SYNC_DIR, 0)
        # self.dev.setGpio( 171, 0) # external (0) / internal (1) sync source

        # self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # Gpio manual control
        # self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
        

        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.1)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stoping camera&#34;)
        print(&#34;CAMERA STOPPED&#34;)




    def Init( self, Mode=3, fps=30, cfg = &#34;&#34;):
        &#34;&#34;&#34;
        Initializes the image sensor.
        
        Inputs:
            Mode: sensor mode (0-10) 
            fps: maximum fps of the image stream 
            cfg: path to .cfg file 

        Outputs:
            0 if successful
        &#34;&#34;&#34;
        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        
        &#39;&#39;
        # 
        # self.dev.setGpio( MPSOC_SYNC_SEL0, 1)
        # self.dev.setGpio( MPSOC_SYNC_SEL1, 1)
        
        # SyncMaster = 1
        # SyncSlave = 0
        # syncSel = SyncMaster
        # self.dev.setGpio( 171, syncSel) # mux2 sel signal : external (0) / internal (1) sync source
        # self.dev.setGpio( MPSOC_SYNC_DIR, syncSel) # snl74 direction signal: external (0) / internal (1) sync source

        # #self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # timer (0) / GPIO (1) internal sync
        # #self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
        # 
        self.dev.setSyncMode( 0, 0) # external , external sync 1v8

        #self.dev.setSyncMode( 0, 0)

        ret = self.sensorPowerUp()
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()


        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate( self.fps)

        print(cfg)
        time.sleep(1)
        self.dev.programCfg(cfg)

        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)

        self.Start()

        return 0


    def ConnectSensor(self, Mode=3, fps=10, cfg = &#34;&#34;):
        &#34;&#34;&#34;
        Command to connect to sensor - powerup the device, set mode, set fps,
        and program cfg file
        Inputs:
            mode: camera mode 
            fps: frames per second 
            cfg: location of .cfg file 

        Outputs:
            none

        &#34;&#34;&#34;
        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        
        ret = self.sensorPowerUp()
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()


        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate( self.fps)

        # print(&#34;Config_1000.00_3p6A_66p_Ofilm.cfg&#34;)
        # time.sleep(3)

        
        print(cfg)
        logging.info(&#39;Loading cfg file: &#39; + cfg)
        time.sleep(0.5)
        self.dev.programCfg(cfg)
        # self.programCSV(&#34;process_data_Legacy_p.csv&#34;)

        if (self.module_class == &#39;Walden_R1&#39;):         # MZ: If Walden module then invert the LSMOD control register in ADSD3100
            self.InvertLSMOD()

        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)


    def testtestwrite(self,addr,val):
        &#34;&#34;&#34;
        Test a register write
        Inputs:
            addr: address in hex or decimal 
            val: value in hex or decimal 

        Outputs:
            none

        &#34;&#34;&#34;
        self.dev.writeSPISingle(addr, val)


    def DisconnectSensor(self):
        &#34;&#34;&#34;
        Command to disconnect sensor. Stop camera and powerdown.
        Inputs:
            none  

        Outputs:
            none  

        &#34;&#34;&#34;
        i = 0
        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.1)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stoping camera&#34;)
        print(&#34;CAMERA STOPPED&#34;)
        ret = self.sensorPowerDown()
        if( ret &lt; 0):
            print(&#34;Error during sensor power down. Please restart your system&#34;)



    def StartSensor(self):
        &#34;&#34;&#34;
        Command to start sensor. Needs ConnectSensor() to be run before.
        Starts capturing of raw data.
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;

        # Send start command to camera
        self.dev.writeSPISingle( 0x000C, 0x00C5)

        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))
            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                print( &#34;Error = &#34; + hex(errorCode))

        if( errorCode != 0x0 or data == 0x00):
            sys.exit()

        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)
        self.dev.startSensor()

        return 0

    def QuickStartSensor(self):
        &#34;&#34;&#34;
        Command to start sensor without checks
        Inputs:
            none 
        Outputs:
            none 

        &#34;&#34;&#34;
        self.dev.startSensor()
        if self.firstStart == True:
            self.dev.writeSPISingle( 0x000C, 0x00C5)
            self.firstStart = False
        else:
            self.dev.writeSPISingle( 0x000C, 0x0001)
        val = 1
        i = 0
        while (val != 0 and i &lt; 10):
            time.sleep(0.01)
            val = self.dev.readSPISingle(0x000C, 1)
            i = i + 1
        
        self.bProgrammed = True



    def StopSensor(self):
        &#34;&#34;&#34;
        Command to stop sensor.
        Inputs:
            none

        Outputs:
            none

        &#34;&#34;&#34;
        i = 0
        if( self.bProgrammed == True):
            # safely stop the camera
            self.dev.writeSPISingle( 0x000C, 0x0002)
            regData = self.dev.readSPISingle( 0x000C, 1)
            
            while( regData[0] != 0x0 and i&lt;20):
                time.sleep(0.01)
                regData = self.dev.readSPISingle( 0x000C, 1)
                i = i + 1
        if( i == 20):
            print(&#34;Error stopping camera&#34;)

    def QuickStopSensor(self):
        &#34;&#34;&#34;
        Command to stop sensor without checks 
        Inputs:
            none 

        Outputs:
            none 

        &#34;&#34;&#34;
        # self.dev.stopSensor()
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        i=0
            
        while( regData[0] != 0x0 and i&lt;20):
            time.sleep(0.01)
            regData = self.dev.readSPISingle( 0x000C, 1)
            i = i + 1
        if( i == 20):
            print(&#34;Error stopping camera&#34;)

        self.dev.stopSensor()



    def regread(self, addr, length=1):
        &#34;&#34;&#34;
        Read a register. If address lies between 0x0E00 and 0x0EFE,
        writes 0x0000 to 0x0014 beforehand.
        Inputs:
            addr: register address in hex or decimal 
            length: number of registers to read 

        Outputs:
            register value 

        &#34;&#34;&#34;
        if addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
            self.dev.writeSPISingle(0x0014, 0x0000)
            # print(&#39;did 0014&lt;-0000&#39;)

        if length == 1 or length == &#39;&#39;:
            return self.dev.readSPISingle(addr, 1)[0]
        else:
            return self.dev.readSPISingle(addr, length)

    def regwrite(self, addr, val, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Write to a register. If address lies between 0x0E00 and 0x0EFE,
        writes 0x0000 to 0x0014 beforehand.
        Inputs:
            addr: register address in hex or decimal 
            val: register value in hex or decimal 

        Outputs:
            status of write 

        &#34;&#34;&#34;
        #print(val , &#39;writing to&#39;, addr)
        if mode == &#39;&#39;:
            if isinstance(val, np.uint16) or isinstance(val, int):
                #print(&#39;stage1&#39;)
                if (addr in s1) or (addr in s2): # Analog registers
                    status = 0xFFFF
                    i = 10
                    while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                        status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                        #print(&#39;status1--&gt;&#39;,status)
                        i = i - 1
                    self.dev.writeSPISingle(addr, val)
                    if addr in s1:
                        self.dev.writeSPISingle(0x0150, 0x0105)
                        #print(&#39;sdsdsdf&#39;)
                    else:
                        self.dev.writeSPISingle(0x0150, 0x0501)
                    status = 0xFFFF
                    i = 10
                    while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                        status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                        #print(&#39;status2--&gt;&#39;,status)
                        i = i - 1
                
                elif addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
                    self.dev.writeSPISingle(0x0014, 0x0000)
                    #print(&#39;did 0014&lt;-0000&#39;)
                    self.dev.writeSPISingle(addr, val)

                else:
                    self.dev.writeSPISingle(addr, val)
                # ret_val = self.dev.readSPISingle(addr, 1)[0]
                return True
            else:
                self.dev.writeSPISingle(addr, val)
                return True

        elif mode == &#39;ignore&#39;:
            self.dev.writeSPISingle(addr, val)
            return True

        else:
            return False

    def testBoardADC(self):
        &#34;&#34;&#34;
        Function to check if the onboard ADC is functioning correctly
        Inputs:
            none 

        Outputs:
            status: staus of the test 

        &#34;&#34;&#34;
        print(&#39;Testing Board ADC...&#39;)
        try:
            logging.info(&#39;Testing Board ADC...&#39;)
        except:
            pass

        success = self.dac_amptest0_set(158)
        self.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
        success = self.dac_amptest1_set(205)
        self.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
        success = self.dac_cmref_set(255)
        self.error_assert(success, &#34;Cannot set dac_cmref&#34;)
        loop = 1
        status = False
        while(not(status) and loop &lt;= 10):
            b1 = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
            print(&#34;Attempt&#34;, loop)
            print(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
            try:
                logging.info(&#34;Attempt &#34; + str(loop))
                logginh.info(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
            except:
                pass

            if b1 &gt; 0.35 and b1 &lt; 0.6:
                status = True
            loop = loop + 1

        if status:
            print(&#39;Board ADC working correctly&#39;)
            try:
                logging.info(&#39;Board ADC working correctly&#39;)
            except:
                pass

        if status == False:
            raise Exception(&#34;ERROR: Either DACwithSF_AMPTEST1-AMPTEST0 or onboard ADC is incorrect&#34;)

        return status


    def ICQSensorPowerUp(self, tests_failed, limits = None, ICQ_dict=None):
        &#34;&#34;&#34;
        Implements ICQ + sensor initialization sequence enabling the power regulators 
            and making functional checks.
        Inputs:
            tests_failed: number of tests failed before the startup 
            limits: minimum and maximum thresholds 
            ICQ_dist: results of the tests done prior 

        Outputs:
            0
            ICQ_dict: result of the powerup 
            tests_failed: number of tests failed 

        &#34;&#34;&#34;
        global Vmain_pre_test
        global Vmain_static_test
        global Vmain_on_test
        global Vsys_pre_test
        global Vsys_static_test
        global Vsys_on_test
        global Vdepth_pre_test
        global Vdepth_static_test
        global Vdepth_on_test
        global Vaux_pre_test
        global Vaux_static_test
        global Vaux_on_test
        global Imain_pre_test
        global Imain_static_test
        global Imain_on_test
        global Isys_pre_test
        global Isys_static_test
        global Isys_on_test
        global Idepth_pre_test
        global Idepth_static_test
        global Idepth_on_test
        global Iaux_pre_test
        global Iaux_static_test
        global Iaux_on_test

        Vmain_pre_min = limits[&#39;Vmain_pre&#39;][0] #Vmain can&#39;t be disabled currently
        Vmain_pre_max = limits[&#39;Vmain_pre&#39;][1]
        Imain_pre_min = limits[&#39;Imain_pre&#39;][0]
        Imain_pre_max = limits[&#39;Imain_pre&#39;][1]
        Vsys_pre_min = limits[&#39;Vsys_pre&#39;][0]
        Vsys_pre_max = limits[&#39;Vsys_pre&#39;][1]
        Isys_pre_min = limits[&#39;Isys_pre&#39;][0]
        Isys_pre_max = limits[&#39;Isys_pre&#39;][1]
        Vdepth_pre_min = limits[&#39;Vdepth_pre&#39;][0]
        Vdepth_pre_max = limits[&#39;Vdepth_pre&#39;][1]
        Idepth_pre_min = limits[&#39;Idepth_pre&#39;][0]
        Idepth_pre_max = limits[&#39;Idepth_pre&#39;][1]
        Vaux_pre_min = limits[&#39;Vaux_pre&#39;][0]
        Vaux_pre_max = limits[&#39;Vaux_pre&#39;][1]
        Iaux_pre_min = limits[&#39;Iaux_pre&#39;][0]
        Iaux_pre_max = limits[&#39;Iaux_pre&#39;][1]

        Vmain_static_min = limits[&#39;Vmain_static&#39;][0]
        Vmain_static_max = limits[&#39;Vmain_static&#39;][1]
        Imain_static_min = limits[&#39;Imain_static&#39;][0]
        Imain_static_max = limits[&#39;Imain_static&#39;][1]
        Vsys_static_min = limits[&#39;Vsys_static&#39;][0]
        Vsys_static_max = limits[&#39;Vsys_static&#39;][1]
        Isys_static_min = limits[&#39;Isys_static&#39;][0]
        Isys_static_max = limits[&#39;Isys_static&#39;][1]
        Vdepth_static_min = limits[&#39;Vdepth_static&#39;][0]
        Vdepth_static_max = limits[&#39;Vdepth_static&#39;][1]
        Idepth_static_min = limits[&#39;Idepth_static&#39;][0]
        Idepth_static_max = limits[&#39;Idepth_static&#39;][1]
        Vaux_static_min = limits[&#39;Vaux_static&#39;][0]
        Vaux_static_max = limits[&#39;Vaux_static&#39;][1]
        Iaux_static_min = limits[&#39;Iaux_static&#39;][0]
        Iaux_static_max = limits[&#39;Iaux_static&#39;][1]

        self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 0) # disable Vmain
        time.sleep(0.004) # wait 4 ms
        [ Vmain_pre, Imain_pre, Pmain_pre] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain before enabled
        Imain_pre = Imain_pre * 1000 #Convert to mA

        Vmain_pre_pass, fail = ICQtest(Vmain_pre, Vmain_pre_min, Vmain_pre_max)
        tests_failed = tests_failed + fail
        Imain_pre_pass, fail = ICQtest(Imain_pre, Imain_pre_min, Imain_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain_pre = &#34; + str(Vmain_pre), Vmain_pre_pass)
        print(&#34; Imain_pre = &#34; + str(Imain_pre), Imain_pre_pass)

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 1) # enable Vmain
        time.sleep(0.01) # wait 10 ms
        [ Vmain_static, Imain_static, Pmain_static] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        Imain_static = Imain_static * 1000 #Convert to mA

        Vmain_static_pass, fail = ICQtest(Vmain_static, Vmain_static_min, Vmain_static_max)
        tests_failed = tests_failed + fail
        Imain_static_pass, fail = ICQtest(Imain_static, Imain_static_min, Imain_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain_static = &#34; + str(Vmain_static), Vmain_static_pass)
        print(&#34; Imain_static = &#34; + str(Imain_static), Imain_static_pass)
        #print(&#34; Pmain_static = &#34; + str(Pmain_static))

        time.sleep(0.1) # wait 100 ms
        [ Vdepth_pre, Idepth_pre, Pdepth_pre] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth before enabled
        Idepth_pre = Idepth_pre * 1000 #Convert to mA

        Vdepth_pre_pass, fail = ICQtest(Vdepth_pre, Vdepth_pre_min, Vdepth_pre_max)
        tests_failed = tests_failed + fail
        Idepth_pre_pass, fail = ICQtest(Idepth_pre, Idepth_pre_min, Idepth_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth_pre = &#34; + str(Vdepth_pre), Vdepth_pre_pass)
        print(&#34; Idepth_pre = &#34; + str(Idepth_pre), Idepth_pre_pass)

        self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
        [ Vdepth_static, Idepth_static, Pdepth_static] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
        Idepth_static = Idepth_static * 1000 #Convert to mA

        Vdepth_static_pass, fail = ICQtest(Vdepth_static, Vdepth_static_min, Vdepth_static_max)
        tests_failed = tests_failed + fail
        Idepth_static_pass, fail = ICQtest(Idepth_static, Idepth_static_min, Idepth_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth_static = &#34; + str(Vdepth_static), Vdepth_static_pass)
        print(&#34; Idepth_static = &#34; + str(Idepth_static), Idepth_static_pass)
        #print(&#34; Pdepth_static = &#34; + str(Pdepth_static))

        self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth

        time.sleep(0.1) # wait 100 ms
        [ Vsys_pre, Isys_pre, Psys_pre] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_pre = Isys_pre * 1000 #Convert to mA

        Vsys_pre_pass, fail = ICQtest(Vsys_pre, Vsys_pre_min, Vsys_pre_max)
        tests_failed = tests_failed + fail
        Isys_pre_pass, fail = ICQtest(Isys_pre, Isys_pre_min, Isys_pre_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys_pre = &#34; + str(Vsys_pre), Vsys_pre_pass)
        print(&#34; Isys_pre = &#34; + str(Isys_pre), Isys_pre_pass)

        self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
        self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
        time.sleep( 0.004) # wait 4 ms
        [ Vsys_static, Isys_static, Psys_static] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_static = Isys_static * 1000 #Convert to mA

        Vsys_static_pass, fail = ICQtest(Vsys_static, Vsys_static_min, Vsys_static_max)
        tests_failed = tests_failed + fail
        Isys_static_pass, fail = ICQtest(Isys_static, Isys_static_min, Isys_static_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys_static = &#34; + str(Vsys_static), Vsys_static_pass)
        print(&#34; Isys_static = &#34; + str(Isys_static), Isys_static_pass)
        #print(&#34; Psys_static = &#34; + str(Psys_static))
        time.sleep(0.01) # wait 10 ms

        self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        self.dev.setGpio( PS_VAUXVPS1, 0)
        time.sleep(0.1) # wait 100 ms
        [ Vaux_pre, Iaux_pre, Paux_pre] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_pre = Iaux_pre * 1000 #Convert to mA

        Vaux_pre_pass, fail = ICQtest(Vaux_pre, Vaux_pre_min, Vaux_pre_max)
        tests_failed = tests_failed + fail
        Iaux_pre_pass, fail = ICQtest(Iaux_pre, Iaux_pre_min, Iaux_pre_max)
        tests_failed = tests_failed + fail
        
        print(&#34; Vaux_pre = &#34; + str( Vaux_pre), Vaux_pre_pass)
        print(&#34; Iaux_pre = &#34; + str( Iaux_pre), Iaux_pre_pass)

        self.dev.setGpio( PS_VAUXVPS1, 1)
        self.dev.setGpio( DEPTH_VAUX_RUN, 1)
        time.sleep(0.0001) # wait 100 us
        [ Vaux_static, Iaux_static, Paux_static] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_static = Iaux_static * 1000 #Convert to mA

        Vaux_static_pass, fail = ICQtest(Vaux_static, Vaux_static_min, Vaux_static_max)
        tests_failed = tests_failed + fail
        Iaux_static_pass, fail = ICQtest(Iaux_static, Iaux_static_min, Iaux_static_max)  
        tests_failed = tests_failed + fail

        print(&#34; Vaux_static = &#34; + str( Vaux_static), Vaux_static_pass)
        print(&#34; Iaux_static = &#34; + str( Iaux_static), Iaux_static_pass)
        #print(&#34; Paux = &#34; + str( Paux))      

        Vmain_pre_test = [&#39;Vmain_pre_V&#39;, Vmain_pre, str(Vmain_pre_pass), Vmain_pre_min, Vmain_pre_max]
        ICQ_dict[&#39;Vmain_pre_V&#39;] = Vmain_pre_test[1:]
        Imain_pre_test = [&#39;Imain_pre_mA&#39;, Imain_pre, str(Imain_pre_pass), Imain_pre_min, Imain_pre_max]
        ICQ_dict[&#39;Imain_pre_mA&#39;] = Imain_pre_test[1:]
        Vsys_pre_test = [&#39;Vsys_pre_V&#39;, Vsys_pre, str(Vsys_pre_pass), Vsys_pre_min, Vsys_pre_max]
        ICQ_dict[&#39;Vsys_pre_V&#39;] = Vsys_pre_test[1:]
        Isys_pre_test = [&#39;Isys_pre_mA&#39;, Isys_pre, str(Isys_pre_pass), Isys_pre_min, Isys_pre_max]
        ICQ_dict[&#39;Isys_pre_mA&#39;] = Isys_pre_test[1:]
        Vdepth_pre_test = [&#39;Vdepth_pre_V&#39;, Vdepth_pre, str(Vdepth_pre_pass), Vdepth_pre_min, Vdepth_pre_max]
        ICQ_dict[&#39;Vdepth_pre_V&#39;] = Vdepth_pre_test[1:]
        Idepth_pre_test = [&#39;Idepth_pre_mA&#39;, Idepth_pre, str(Idepth_pre_pass), Idepth_pre_min, Idepth_pre_max]
        ICQ_dict[&#39;Idepth_pre_mA&#39;] = Idepth_pre_test[1:]
        Vaux_pre_test = [&#39;Vaux_pre_V&#39;, Vaux_pre, str(Vaux_pre_pass), Vaux_pre_min, Vaux_pre_max]
        ICQ_dict[&#39;Vaux_pre_V&#39;] = Vaux_pre_test[1:]
        Iaux_pre_test = [&#39;Iaux_pre_mA&#39;, Iaux_pre, str(Iaux_pre_pass), Iaux_pre_min, Iaux_pre_max]
        ICQ_dict[&#39;Iaux_pre_mA&#39;] = Iaux_pre_test[1:]
        
        Vmain_static_test = [&#39;Vmain_static_V&#39;, Vmain_static, str(Vmain_static_pass), Vmain_static_min, Vmain_static_max]
        ICQ_dict[&#39;Vmain_static_V&#39;] = Vmain_static_test[1:]
        Imain_static_test = [&#39;Imain_static_mA&#39;, Imain_static, str(Imain_static_pass), Imain_static_min, Imain_static_max]
        ICQ_dict[&#39;Imain_static_mA&#39;] = Imain_static_test[1:]
        Vsys_static_test = [&#39;Vsys_static_V&#39;, Vsys_static, str(Vsys_static_pass), Vsys_static_min, Vsys_static_max]
        ICQ_dict[&#39;Vsys_static_V&#39;] = Vsys_static_test[1:]
        Isys_static_test = [&#39;Isys_static_mA&#39;, Isys_static, str(Isys_static_pass), Isys_static_min, Isys_static_max]
        ICQ_dict[&#39;Isys_static_mA&#39;] = Isys_static_test[1:]
        Vdepth_static_test = [&#39;Vdepth_static_V&#39;, Vdepth_static, str(Vdepth_static_pass), Vdepth_static_min, Vdepth_static_max]
        ICQ_dict[&#39;Vdepth_static_V&#39;] = Vdepth_static_test[1:]
        Idepth_static_test = [&#39;Idepth_static_mA&#39;, Idepth_static, str(Idepth_static_pass), Idepth_static_min, Idepth_static_max]
        ICQ_dict[&#39;Idepth_static_mA&#39;] = Idepth_static_test[1:]
        Vaux_static_test = [&#39;Vaux_static_V&#39;, Vaux_static, str(Vaux_static_pass), Vaux_static_min, Vaux_static_max]
        ICQ_dict[&#39;Vaux_static_V&#39;] = Vaux_static_test[1:]
        Iaux_static_test = [&#39;Iaux_static_mA&#39;, Iaux_static, str(Iaux_static_pass), Iaux_static_min, Iaux_static_max]
        ICQ_dict[&#39;Iaux_static_mA&#39;] = Iaux_static_test[1:]

        if(tests_failed == 0):
            print(&#34;Static Malka Supplies PASSED&#34;)
            ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 1 
        else:
            print(&#34;Static Malka Supplies FAILED&#34;)
            ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 0 

        # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            if( cam_shutdown == 1):
                break
            else:
                retries = retries - 1

        # if( retries == 0):
        #     print( &#34;Error during camera initialization&#34;)
        #     self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        #     self.dev.setGpio( PS_VAUXVPS2, 0)
        #     self.dev.setGpio( PS_VAUXVPS1, 0)
        #     self.dev.setGpio( PS_V5VVPS3, 0)
        #     self.dev.setGpio( LMZ_EN, 0)
        #     return -1

        # wait 2 ms
        time.sleep( 0.002)
        self.dev.setGpio( CAM_RESET_N, 1)       

        return [0, ICQ_dict, tests_failed]

    def ICQSensorStart(self, Mode=3, fps=10, cfg = &#34;&#34;, file_name = &#34;&#34;, 
                        limits = None, ICQ_dict=None, ICQ_mode = &#39;no_laser&#39;):
        &#34;&#34;&#34;
        Starts the sensor, performs ICQ and saves it to csv file
        Inputs:
            mode: camera mode 
            fps: frequency per second 
            cfg: name of cfg file 
            file_name: name of csv file to store the results 
            limits: minimum and maximum thresholds 
            ICQ_dict: dictionary containing the results of prior tests 
            ICQ_mode: whether to enable laser or not 

        Outputs:
            0 
            ICQ_dict: result in a dictionary 

        &#34;&#34;&#34;

        tests_failed = 0
        global Vmain_on_test
        global Vsys_on_test
        global Vdepth_on_test
        global Vaux_on_test
        global Imain_on_test
        global Isys_on_test
        global Idepth_on_test
        global Iaux_on_test

        ret = self.dev.openDevice( Mode, -1)
        if( ret &lt; 0):
            print(&#34;Error opening the camera&#34;)
            return -2
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x98, 0xBB]) # MZ1: Added VAUX DAC set for 25V
        # self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xCE]) # DAC set for 27V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x4B]) # DAC set for 28V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x09]) # DAC set for 28.5V
        #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0x13]) # DAC set for ~13.8V

        [ret, ICQ_dict, tests_failed] = self.ICQSensorPowerUp(tests_failed, limits = limits, ICQ_dict=ICQ_dict)
        if( ret &lt; 0):
            print(&#34;Error during sensor power up. Please restart your system.&#34;)
            sys.exit()
        self.Mode = Mode
        self._setInternalClassMode()

        self.fps = fps
        self.dev.setCameraFrameRate(fps)

        self.dev.programCfg(cfg)
        #self.programCSV(&#34;process_data_Legacy.csv&#34;)

        
        if( Mode != 3):
            #self.changeMode( self.Mode)
            self.dev.writeSPISingle( 0x0200, self.Mode)
        
        self.dev.startSensor()
        print(&#34; Camera running... &#34;)

        # Send start command to camera
        self.dev.writeSPISingle( 0x000C, 0x00C5)

        Vmain_on_min = limits[&#39;Vmain_on&#39;][0]
        Vmain_on_max = limits[&#39;Vmain_on&#39;][1]
        Imain_on_min = limits[&#39;Imain_on&#39;][0]
        Imain_on_max = limits[&#39;Imain_on&#39;][1]
        Vsys_on_min = limits[&#39;Vsys_on&#39;][0]
        Vsys_on_max = limits[&#39;Vsys_on&#39;][1]
        Isys_on_min = limits[&#39;Isys_on&#39;][0]
        Isys_on_max = limits[&#39;Isys_on&#39;][1]
        Vdepth_on_min = limits[&#39;Vdepth_on&#39;][0]
        Vdepth_on_max = limits[&#39;Vdepth_on&#39;][1]
        Idepth_on_min = limits[&#39;Idepth_on&#39;][0]
        Idepth_on_max = limits[&#39;Idepth_on&#39;][1]
        Vaux_on_min = limits[&#39;Vaux_on&#39;][0]
        Vaux_on_max = limits[&#39;Vaux_on&#39;][1]
        Iaux_on_min = limits[&#39;Iaux_on&#39;][0]
        Iaux_on_max = limits[&#39;Iaux_on&#39;][1]

        #Measure supply rails after enabling camera
        [ Vmain_on, Imain_on, Pmain_on] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        Imain_on = Imain_on * 1000 #Convert to mA
        
        Vmain_on_pass, fail = ICQtest(Vmain_on, Vmain_on_min, Vmain_on_max)
        tests_failed = tests_failed + fail
        Imain_on_pass, fail = ICQtest(Imain_on, Imain_on_min, Imain_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vmain-on = &#34; + str(Vmain_on), Vmain_on_pass)
        print(&#34; Imain-on = &#34; + str(Imain_on), Imain_on_pass)
        #print(&#34; Pmain_on = &#34; + str(Pmain_on))

        [ Vdepth_on, Idepth_on, Pdepth_on] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
        Idepth_on = Idepth_on * 1000 #Convert to mA

        Vdepth_on_pass, fail = ICQtest(Vdepth_on, Vdepth_on_min, Vdepth_on_max)
        tests_failed = tests_failed + fail
        Idepth_on_pass, fail = ICQtest(Idepth_on, Idepth_on_min, Idepth_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vdepth-on = &#34; + str(Vdepth_on), Vdepth_on_pass)
        print(&#34; Idepth-on = &#34; + str(Idepth_on), Idepth_on_pass)
        #print(&#34; Pdepth_on = &#34; + str(Pdepth_on))

        [ Vsys_on, Isys_on, Psys_on] = self.PowerMonitor( VSYS_DEV_ID)
        Isys_on = Isys_on * 1000 #Convert to mA

        Vsys_on_pass, fail = ICQtest(Vsys_on, Vsys_on_min, Vsys_on_max)
        tests_failed = tests_failed + fail
        Isys_on_pass, fail = ICQtest(Isys_on, Isys_on_min, Isys_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vsys-on = &#34; + str(Vsys_on), Vsys_on_pass)
        print(&#34; Isys-on = &#34; + str(Isys_on), Isys_on_pass)
        #print(&#34; Psys_on = &#34; + str(Psys_on))
        time.sleep( 0.004) # wait 4 ms

        [ Vaux_on, Iaux_on, Paux_on] = self.PowerMonitor( VAUX_DEV_ID)
        Iaux_on = Iaux_on * 1000 #Convert to mA

        Vaux_on_pass, fail = ICQtest(Vaux_on, Vaux_on_min, Vaux_on_max)
        tests_failed = tests_failed + fail
        Iaux_on_pass, fail = ICQtest(Iaux_on, Iaux_on_min, Iaux_on_max)
        tests_failed = tests_failed + fail

        print(&#34; Vaux-on = &#34; + str( Vaux_on), Vaux_on_pass)
        print(&#34; Iaux-on = &#34; + str( Iaux_on), Iaux_on_pass)
        #print(&#34; Paux_on = &#34; + str( Paux_on))
   
        
        Vmain_on_test = [&#39;Vmain-on_V&#39;, Vmain_on, str(Vmain_on_pass), Vmain_on_min, Vmain_on_max]
        ICQ_dict[&#39;Vmain-on_V&#39;] = Vmain_on_test[1:]
        Imain_on_test = [&#39;Imain-on_mA&#39;, Imain_on, str(Imain_on_pass), Imain_on_min, Imain_on_max]
        ICQ_dict[&#39;Imain-on_mA&#39;] = Imain_on_test[1:]
        Vsys_on_test = [&#39;Vsys-on_V&#39;, Vsys_on, str(Vsys_on_pass), Vsys_on_min, Vsys_on_max]
        ICQ_dict[&#39;Vsys-on_V&#39;] = Vsys_on_test[1:]
        Isys_on_test = [&#39;Isys-on_mA&#39;, Isys_on, str(Isys_on_pass), Isys_on_min, Isys_on_max]
        ICQ_dict[&#39;Isys-on_mA&#39;] = Isys_on_test[1:]
        Vdepth_on_test = [&#39;Vdepth-on_V&#39;, Vdepth_on, str(Vdepth_on_pass), Vdepth_on_min, Vdepth_on_max]
        ICQ_dict[&#39;Vdepth-on_V&#39;] = Vdepth_on_test[1:]
        Idepth_on_test = [&#39;Idepth-on_mA&#39;, Idepth_on, str(Idepth_on_pass), Idepth_on_min, Idepth_on_max]
        ICQ_dict[&#39;Idepth-on_mA&#39;] = Idepth_on_test[1:]
        Vaux_on_test = [&#39;Vaux-on_V&#39;, Vaux_on, str(Vaux_on_pass), Vaux_on_min, Vaux_on_max]
        ICQ_dict[&#39;Vaux-on_V&#39;] = Vaux_on_test[1:]
        Iaux_on_test = [&#39;Iaux-on_mA&#39;, Iaux_on, str(Iaux_on_pass), Iaux_on_min, Iaux_on_max]
        ICQ_dict[&#39;Iaux-on_mA&#39;] = Iaux_on_test[1:]

        
        # check if useq works
        errorCode = 0
        for i in range(10):
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data = &#34; + hex(data))

            ADC_LSB = 0.000125
            ADC_REF = 2.5 #Vref
            ADC_BITS = 2**12 #12 bit ADC

            VDDA1_min = limits[&#39;VDDA1&#39;][0]
            VDDA1_max = limits[&#39;VDDA1&#39;][1]
            VHIGH_min = limits[&#39;VHIGH&#39;][0]
            VHIGH_max = limits[&#39;VHIGH&#39;][1]
            VLOW_min = limits[&#39;VLOW&#39;][0]
            VLOW_max = limits[&#39;VLOW&#39;][1]
            VLD_min = limits[&#39;VLD&#39;][0]
            VLD_max = limits[&#39;VLD&#39;][1]

            time.sleep(0.1)
            self.dev.writeSPISingle( 0x0160, 0x0007) #Diff V1p2
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(0)
            ADC_code = self.dev.getADCvalue(0)
            VDDA1 = ADC_code * ADC_LSB
            VDDA1_pass, fail = ICQtest(VDDA1, VDDA1_min, VDDA1_max)
            tests_failed = tests_failed + fail
            print(&#34; VDDA1 = &#34; + str(VDDA1), VDDA1_pass)

            self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vhigh
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(4)
            VHIGH = ADC_code * ADC_LSB
            VHIGH_pass, fail = ICQtest(VHIGH, VHIGH_min, VHIGH_max)
            tests_failed = tests_failed + fail
            print(&#34; VHIGH = &#34; + str(VHIGH), VHIGH_pass)

            self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vlow
            time.sleep(0.1)
            ADC_code = self.dev.getADCvalue(5)
            VLOW = ADC_code * ADC_LSB
            VLOW_pass, fail = ICQtest(VLOW, VLOW_min, VLOW_max)
            tests_failed = tests_failed + fail
            print(&#34; VLOW = &#34; + str(VLOW), VLOW_pass)

            VDDA1_test = [&#39;VDDA1_V&#39;, VDDA1, str(VDDA1_pass), VDDA1_min, VDDA1_max]
            ICQ_dict[&#39;VDDA1_V&#39;] = VDDA1_test[1:]
            VHIGH_test = [&#39;VHIGH_V&#39;, VHIGH, str(VHIGH_pass), VHIGH_min, VHIGH_max]
            ICQ_dict[&#39;VHIGH_V&#39;] = VHIGH_test[1:]
            VLOW_test = [&#39;VLOW_V&#39;, VLOW, str(VLOW_pass), VLOW_min, VLOW_max]
            ICQ_dict[&#39;VLOW_V&#39;] = VLOW_test[1:]

            if ICQ_mode == &#39;laser&#39;:
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x04, 0x00, 0x10])
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x02, 0x00, 0x10])
                self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x40])
                VLD = self.dev.readI2C(I2C_MALKA, AD5593R_ID, 2)
                VLD[0] = VLD[0] &amp; 0x0F #ADC conversion is 12 LSBs (bits 13-15 = ADC channel info) 
                VLD = VLD[0] *256 + VLD[1] #unpack bytes
                VLD = VLD * (ADC_REF / ADC_BITS) #convert ADC code to voltage
                VLD = VLD * 5 #Resistor divider schematic - needs to be corrected
                VLD_pass, fail = ICQtest(VLD, VLD_min, VLD_max)
                tests_failed = tests_failed + fail
                print(&#34; VLD = &#34; + str(VLD), VLD_pass)
                VLD_test = [&#39;VLD_V&#39;, VLD, str(VLD_pass), VLD_min, VLD_max]
                ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

            elif ICQ_mode == &#39;no_laser&#39;:
                VLD_test = [&#39;VLD_V&#39;, 0, &#39;NA&#39;, -0.1, 0.1]
                ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

            else:
                raise Exception(&#34;\n\nERROR: Invalid ICQ mode\n\n&#34;)
                  

            if(tests_failed == 0):
                print(&#34;Device PASSED&#34;)
                device_passed = &#34;PASSED&#34;
                ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 1
            else:
                print(&#34;Device FAILED&#34;)
                device_passed = &#34;FAILED&#34;
                print(&#34;Number of tests failed = &#34;, tests_failed)
                ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 0


            Device_test = [&#39;Pass/Fail&#39;, tests_failed, str(device_passed), 0, 0]

            # #data directory path
            # DATA_PATH = &#39;./datalogs&#39;
            # #data file name
            # DATA_NAME = &#39;IQC_log&#39;
            # #todays date
            

            time.sleep(0.1)
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                print( &#34;Error = &#34; + hex(errorCode))
                
        if( errorCode != 0x0 or data == 0x00):
            sys.exit()
            
        # Kick-off camera stream
        self.bProgrammed = True
        print(&#34;camera programmed&#34;)

        self.QuickStopSensor()

        now = datetime.now()
        date_string = now.date().strftime(&#34;%Y_%m_%d&#34;)
        time_string = now.time().strftime(&#34;_%H_%M_%S&#34;)

        #create total file path (with date)
        # file_name = DATA_PATH + &#39;/&#39; + date_string + time_string + &#39;_&#39; + DATA_NAME + &#34;.csv&#34;      
        file_name = file_name + &#39;.csv&#39;          

        if not os.path.isfile(file_name):
            csv_headers = [&#39;Test&#39;, &#39;Value&#39;, &#39;Result&#39;, &#39;Min Limit&#39;, &#39;Max Limit&#39;]

        with open(file_name, &#39;w&#39;, newline=&#39;&#39;) as new_data_file:
            datawriter = csv.writer(new_data_file)
            datawriter.writerow(csv_headers)
            datawriter.writerow(Device_test)
            datawriter.writerow(Vmain_pre_test)
            datawriter.writerow(Imain_pre_test)
            datawriter.writerow(Vmain_static_test)
            datawriter.writerow(Imain_static_test)
            datawriter.writerow(Vmain_on_test)
            datawriter.writerow(Imain_on_test)

            datawriter.writerow(Vsys_pre_test)
            datawriter.writerow(Isys_pre_test)
            datawriter.writerow(Vsys_static_test)
            datawriter.writerow(Isys_static_test)
            datawriter.writerow(Vsys_on_test)
            datawriter.writerow(Isys_on_test)

            datawriter.writerow(Vdepth_pre_test)
            datawriter.writerow(Idepth_pre_test)
            datawriter.writerow(Vdepth_static_test)
            datawriter.writerow(Idepth_static_test)
            datawriter.writerow(Vdepth_on_test)
            datawriter.writerow(Idepth_on_test)

            datawriter.writerow(Vaux_pre_test)
            datawriter.writerow(Iaux_pre_test)
            datawriter.writerow(Vaux_static_test)
            datawriter.writerow(Iaux_static_test)
            datawriter.writerow(Vaux_on_test)
            datawriter.writerow(Iaux_on_test)

            datawriter.writerow(VDDA1_test)
            datawriter.writerow(VHIGH_test)
            datawriter.writerow(VLOW_test)
            datawriter.writerow(VLD_test)

        return [tests_failed, ICQ_dict]


    def CamMeasureAnaTestVoltage(self, SOURCE, N_AVERAGES = 1):
        &#34;&#34;&#34;
        Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  
        Inputs:
            - source: Internal ADSD3100 voltage to measure.  Valid options are: 
               &#39;DAC_TX1&#39; 
               &#39;DAC_TX2&#39; 
               &#39;DAC_AMPTEST1&#39; 
               &#39;DAC_BIAS1&#39; 
               &#39;DAC_BIAS2&#39; 
               &#39;DAC_SATREF&#39; 
               &#39;DAC_VREST&#39; 
               &#39;DAC_AMPTEST0&#39; 
               &#39;DAC_CMREF&#39; 
               &#39;DACwithSF_X-Y&#39;,                       
                 X,Y valid options are {AMPTEST0,AMPTEST1,CMREF,GND} 
                 where X = adc_muxp_in/amp_testseln/ATP 
                   and Y = adc_muxn_in/amp_testselp/ATN 
               &#39;comp_vref0&#39; 
               &#39;comp_vref1&#39; 
               &#39;comp_vref2&#39; 
               &#39;amp_vcm&#39;                              
               &#39;AnaTestMux_0&#39; ... &#39;AnaTestMux_31&#39; 
        
            - num_averages (optional). How many times to read the voltage and average 
        
        Outputs:
            - voltage (optional). Measured voltage 
        &#34;&#34;&#34;

        # voltage = CamMeasureAnaTestVoltage(source)
        # voltage = CamMeasureAnaTestVoltage(source, num_averages)
        
        # Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  On ADSD3100
        # BUB this requires jumpers on J29 pins 2-3 (ATP_ADC) and J31 pins 2-3 (ATN_ADC)
        

        val = self.regread(0x0026)
        time.sleep(0.1)
        success = True
        val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running

        if(val!=0):
            time.sleep(1.0)
            val = self.regread(0x0026)
            print(&#34;Retry - val = &#34;, val)
            time.sleep(5.0)
            val = self.regread(0x0026)
            print(&#34;Retry - val = &#34;, val)
            time.sleep(0.1)
            val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running
 
        #self.error_assert(success, &#39;Cannot communicate with chip&#39;)
        self.error_assert(not(val), &#39;Must stop uSeq before calling&#39;)
        ADC_config = dict()

        ADC_config[&#39;mux&#39;] = &#39;AIN0-AIN1&#39;

        val = self.regread(0x017C)

        origSettingADC = dict()

        origSettingADC[&#39;xosc_ctrl&#39;] = int(val)
        origSettingADC[&#39;reg&#39;] = dict()
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = []
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = []

        val = int(val) | 0x0020
        s_ = self.regwrite(0x017C, val)
        # self.error_assert(success, &#39;Unable to write register 0x017C&#39;)

        val = self.regread(0x0146)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], int(val))
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0146)
        val = int(val) &amp; 0xFF7F #power up bandgap
        success = success and self.regwrite(0x0146, val)
        self.error_assert(success, &#39;Unable to power up bandgap&#39;)

        val = self.regread(0x0160) # original state of ana_test_mux_s1
        #self.error_assert(success, &#39;Unable to read ana_test_mux_s1&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0160)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        val = self.regread(0x0128) # original state of dac_ctrl2
        #self.error_assert(success, &#39;Unable to read dac_ctrl2&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0128)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        val = self.regread(0x0014) # original state of digPwrDown
        #self.error_assert(success, &#39;Unable to read digPwrDown&#39;)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0014)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        if SOURCE.startswith(&#39;DAC_&#39;):
            dacNames = [&#39;DAC_TX1&#39;,&#39;DAC_TX2&#39;,&#39;DAC_AMPTEST1&#39;,&#39;DAC_BIAS1&#39;,&#39;DAC_BIAS2&#39;,&#39;DAC_SATREF&#39;,&#39;DAC_VREST&#39;,&#39;DAC_AMPTEST0&#39;,&#39;DAC_CMREF&#39;]
            try:
                dacIdx = dacNames.index(SOURCE)
            except:
                raise Exception(&#39;Cannot measure voltage. Unknown DAC value&#39;)

            success = self.regwrite(0x0128, 0x0000)
            self.error_assert(success, &#39;Unable to power up DACs&#39;)

            val = self.regread(0x012A)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x012A)
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) &amp; 0xFF00
            val = val | int(dacIdx + 1) # =1 due to difference in indexing
            success = success and self.regwrite(0x012A, val)
            success = success and self.regwrite(0x0160, 0x0013)
            self.error_assert(success, &#39;Unable to configuire test mux&#39;)

        elif SOURCE.startswith(&#39;amp_vcm&#39;):
            val = self.regread(0x0146)
            val = val &amp; 0xFFCF
            s = self.regwrite(0x0146, val)
            success = self.regwrite(0x0160, 0x001B)

        elif SOURCE.startswith(&#39;DACwithSF_&#39;):
            val = self.regread(0x0146)
            val = int(val) &amp; 0xFFFD
            success = success and self.regwrite(0x0146, val)
            success = success and self.regwrite(0x0128, 0x0000)
            self.error_assert(success, &#39;Unable to power up DACs and column currents&#39;)

            tmp = SOURCE.split(&#39;_&#39;)
            DAC1 = tmp[1].split(&#39;-&#39;)[0]
            try: # if there is no DAC2
                DAC2 = tmp[1].split(&#39;-&#39;)[1]
            except:
                ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
                DAC2 = DAC1

            if (DAC2 == &#39;GND&#39; and DAC1 != &#39;GND&#39;):
                ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
                DAC2 = DAC1
            elif (DAC1 == &#39;GND&#39;):
                ADC_config[&#39;mux&#39;] = &#39;AIN1-GND&#39;
                DAC1 = DAC2

            if DAC1.upper() == &#39;AMPTEST0&#39;:
                amptestselOverrideVal = int(&#39;0x2000&#39;, 0)
            elif DAC1.upper() == &#39;AMPTEST1&#39;:
                amptestselOverrideVal = int(&#39;0x3000&#39;, 0)
            elif DAC1.upper() == &#39;CMREF&#39;:
                amptestselOverrideVal = int(&#39;0x4000&#39;, 0)
            else:
                raise Exception(&#39;Unknown source for DAC selection [0]&#39;)

            if DAC2.upper() == &#39;AMPTEST0&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0400&#39;, 0)
            elif DAC2.upper() == &#39;AMPTEST1&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0420&#39;, 0)
            elif DAC2.upper() == &#39;CMREF&#39;:
                amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0800&#39;, 0)
            else:
                raise Exception(&#39;Unknown source for DAC selection [1]&#39;)

            # val = self.regread(0x0E10)
            # print(&#39;regread 0x0E10&#39;, hex(val))
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            # val = self.regread(0x0E18)
            # print(&#39;regread 0x0E18&#39;, hex(val))
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            # val = self.regread(0x0E00)
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E00&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)


            # s = self.regrmw(0x0014,0x0000,0x0001)
            # s = self.regrmw(0x0E00,0x0002,0x0003)
            # s = self.regrmw(0x0E18,0x7C20,0x7C20)
            # s = self.regrmw(0x0E10,amptestselOverrideVal,0x7C20)
            
            val = self.regread(0x0E10)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) &amp; int(&#39;0x83DF&#39; ,0)
            val = val | amptestselOverrideVal
            s_ = self.regwrite(0x0E10, val) # &gt;&gt;&gt;&gt;&gt; override
            #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

            val = self.regread(0x0E18)
            origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
            origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
            val = int(val) | int(&#39;0x7C20&#39; ,0)
            s_ = self.regwrite(0x0E18, val) # &gt;&gt;&gt;&gt;&gt; override
            #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

            success = success and self.regwrite(0x0014, 0x0000)
            s, origSettingADC[&#39;ampMuxOrig&#39;] = self.regreadburst(0x0E1C, 10, &#39;increment&#39;)
            ampMuxVal = [0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008]
            s = self.regwriteburst(0x0E1C, ampMuxVal, &#39;increment&#39;)

            # val = self.regread(0x0160)
            # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0160&#39;, 0))
            # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

            s = self.regwrite(0x0160, 0x0012)
            self.error_assert(success, &#39;Unable to configuire test mux&#39;)
            # s = self.regwrite(0x0150, 0x0105)

        elif SOURCE.startswith(&#39;comp_v&#39;):
            val = self.regread(0x0146)
            val = int(val) &amp; int(&#39;0xFFEF&#39;,0)
            success = success and self.regwrite(0x0146, val)
            self.error_assert(success, &#39;Unable to power up col_comparator&#39;)

            if SOURCE.lower() == &#39;comp_vref0&#39;:
                success = success and self.regwrite(0x0160, 0x0014)
            elif SOURCE.lower() == &#39;comp_vref1&#39;:
                success = success and self.regwrite(0x0160, 0x0015)
            elif SOURCE.lower() == &#39;comp_vref2&#39;:
                success = success and self.regwrite(0x0160, 0x0016)
            else:
                raise Exception(&#39;Unknown source&#39;)

        elif SOURCE == &#39;amp_vcm&#39;:
            val = self.regread(0x0146)
            val = int(val) &amp; int(&#39;0xFFCF&#39;,0)
            success = success and self.regwrite(0x0146, val)
            self.error_assert(success, &#39;Unable to power up col_comparator and AMP&#39;)

            success = success and self.regwrite(0x0160, 0x001B)

        elif SOURCE.startswith(&#39;AnaTestMux_&#39;):
            ana_test_mux = int(SOURCE.split(&#39;_&#39;)[1])

            if np.isnan(ana_test_mux) or ana_test_mux &gt; 31 or ana_test_mux &lt; 0:
                print(&#39;Unknown source. The AnaTestMux_ option must include a mux value between 0-31\n&#39;)

            success = self.regwrite(0x0160, ana_test_mux)

        else:
            raise Exception(&#34;Unknown source&#34;)

        # adding pause to avoid bogus readings given the sampling freq increased in the newer FW version
        # val = self.regread(0x0e16)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e16&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # val = self.regread(0x0e14)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e14&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # s = self.regwrite(0x0e16, 0x4000)
        # s = self.regwrite(0x0e14, 0x0100)
        muxOptions = np.array([&#39;ain0-ain1&#39;,&#39;ain0-ain3&#39;,&#39;ain1-ain3&#39;,&#39;ain2-ain3&#39;,&#39;ain0-gnd&#39;,&#39;ain1-gnd&#39;,&#39;ain2-gnd&#39;,&#39;ain3-gnd&#39;])
        tmp, = np.where(muxOptions == ADC_config[&#39;mux&#39;].lower())
        muxVal = tmp[0]

        # for i in range(N_AVERAGES-1, -1,-1):
        #   time.sleep(0.01)
        #   val = self.ReadBoardADC(muxVal)
        #   voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

        # voltage = voltage / 1000000 # in V

        vRepeat = True
        nIter = 3

        while(vRepeat and (nIter &gt;= 1)):
            # print(vRepeat,nIter)
            for i in range(N_AVERAGES-1, -1,-1):
                time.sleep(0.01)
                val = self.ReadBoardADC(muxVal)
                voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

            voltage = voltage / 1000000 # in V

            if (self.prevVoltage != voltage) and (abs(voltage) &gt; 0.03) and (abs(voltage) &lt; 3.8):
                vRepeat = False
                self.prevVoltage = voltage
            else:
                time.sleep(0.1)
                nIter = nIter - 1

            # if nIter &lt; 1:
            #     print(&#39;\nONBOARD ADC ERROR\n&#39;)
            #     try:
            #         logging.info(&#39;\nONBOARD ADC ERROR\n&#39;)
            #     except:
            #         pass

        # clean up
        success = True
        keys = list(origSettingADC.keys())

        if &#39;ampMuxOrig&#39; in keys:
            success = self.regwriteburst(0x0E1C, np.array(origSettingADC[&#39;ampMuxOrig&#39;],dtype=np.uint16), &#39;increment&#39;)

        origADCAddr = np.array(origSettingADC[&#39;reg&#39;][&#39;addr&#39;],dtype=np.uint16)
        origADCVal = np.array(origSettingADC[&#39;reg&#39;][&#39;val&#39;],dtype=np.uint16)
        s = self.regwrite(origADCAddr, origADCVal)

        xosc_ctrl = origSettingADC[&#39;xosc_ctrl&#39;]

        if ((xosc_ctrl &gt;&gt; 6) &amp; 1) == 1: # if XIDLE_HOST originally was 1
            xosc_ctrl = xosc_ctrl | int(&#39;0x0010&#39;,0) # set XIDLE_HOST_set
            xosc_ctrl = xosc_ctrl &amp; int(&#39;0xFFDF&#39;,0) # dont set XIDLE_HOST_clear
            s = self.regwrite(0x017C, xosc_ctrl)
            # self.error_assert(success, &#39;Unable to restore register 0x017C&#39;)

        self.error_assert(success, &#39;Unable to restore original register settings&#39;)
        print(&#39;Analog test mux source:&#39;, SOURCE , &#39;measured voltage:&#39;, np.round(voltage, 4))
        try:
            logging.info(&#39;Analog test mux source: &#39; + str(SOURCE) +&#39; measured voltage: &#39; + str(np.round(voltage, 4)))
        except:
            pass

        return voltage
    

    def regwritemultiple(self, addr, val):
        &#34;&#34;&#34;
        Write multiple registers 
        Inputs:
            addr: address array 
            val: value array 

        Outputs:
            status 

        &#34;&#34;&#34;
        self.dev.writeSPISingle(addr, val)


    def regrmw(self, addr, val, mask=np.uint16(0x0000)):
        &#34;&#34;&#34;
        Register read-modify-write 
        Inputs:
            addr: address in hex or decimal 
            val: value in hex or decimal 
            mask: mask in hex or decimal 

        Outputs:
            success: status of rmw 

        &#34;&#34;&#34;
        addr = np.uint16(addr)
        val = np.uint16(val)
        mask = np.uint16(mask)
        prevVal = np.uint16(self.regread(addr))
        newVal = (prevVal &amp; ~mask) | (val &amp; mask)
        success = self.regwrite(addr, newVal)
        return success


    def dac_amptest0_get(self):
        &#34;&#34;&#34;
        Get amptest0 value 
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_amptest0


    def dac_amptest0_set(self, val):
        &#34;&#34;&#34;
        Set amptest0 value 
        Inputs:
            val: amptest0 value 

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0080) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_amptest0 = val
        return s


    def dac_amptest1_get(self):
        &#34;&#34;&#34;
        Get amptest1 value
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_amptest1


    def dac_amptest1_set(self, val):
        &#34;&#34;&#34;
        Set amptest1 value
        Inputs:
            val: amptest1 value

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0004) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_amptest1 = val
        return s


    def dac_cmref_get(self):
        &#34;&#34;&#34;
        Get cmref value
        Inputs:
            none

        Outputs:
            value

        &#34;&#34;&#34;
        return self.dac_cmref


    def dac_cmref_set(self, val):
        &#34;&#34;&#34;
        Set cmref value
        Inputs:
            val: cmref value 

        Outputs:
            s: status

        &#34;&#34;&#34;
        s = self.regwrite(0x0132, np.uint16(val))
        s_ = self.regwrite(0x0126, 0x0100) # Latch DAC_AMPTEST0
        # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
        # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
        if s:
            self.dac_cmref = val
        return s
        

    def regreadburst(self, addr, length, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Register read burst (from RAM or multiple registers)
        Inputs:
            addr: Address 
            length: length to read 
            mode: RAM read or &#39;increament&#39; to read multiple registers 

        Outputs:
            True 
            val: read value in array 

        &#34;&#34;&#34;
        if mode == &#39;&#39;:
            s, tmp =  self.dev.readSPIBurst(addr, length*2+4) # Temporory workaround
            val = np.zeros(length)
            val = 256*tmp[::2] + tmp[1::2]
            return np.all(s), val[0:-2]
        elif mode == &#39;increment&#39;:
            val = np.zeros(length,dtype=np.uint16)
            for i in range(length):
                val[i] = self.regread(addr + 2*i)
            return True, val

    def print_regreadburst(self, addr, length):
        &#34;&#34;&#34;
        Print register read burst 
        Inputs: 
            addr: Address 
            length: length to read 

        Outputs:
            None 

        &#34;&#34;&#34;
        for i in range(length):
            val = self.regread(addr + 2*i)
            print(hex(addr + 2*i),&#39;--&gt;&#39;,hex(val))

    def regwriteburst(self, addr, data, mode = &#39;&#39;):
        &#34;&#34;&#34;
        Register write burst (to RAM or multiple registers)
        Inputs:
            addr: Address array 
            data: Data array 
            mode: RAM read or &#39;increament&#39; to read multiple registers 

        Outputs:
            status 

        &#34;&#34;&#34;
        addr = np.uint16(addr)
        data = np.uint16(data)
        if mode == &#39;&#39;:
            RAMData = np.zeros( (len(data)*2), dtype = np.uint8)
            for i in range( len(data)):
                RAMData[2*i] = data[i] &gt;&gt; 8
                RAMData[2*i+1] = data[i] &amp; 0xFF
            return self.dev.writeSPIBurst(addr, RAMData)

        elif mode == &#39;increment&#39;:
            if isinstance(addr, np.uint16):
                for i in range(len(data)):
                    success = self.regwrite(addr + i*2, data[i])
            else:
                for i in range(len(data)):
                    success = self.regwrite(addr[i], data[i])

        return success

        
    def GetIndirectRegister(self, name):
        &#34;&#34;&#34;
        Read indirect registers
        Inputs:
            name: register name 

        Outputs:
            status
            value

        &#34;&#34;&#34;
        if name == &#39;N_OVRD_ANAMODE&#39;:
            addr = 0x1fc1
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_0&#39;:
            addr = 0x1fc5
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_1&#39;:
            addr = 0x1fc9
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;WAVE_FUNCTION_2&#39;:
            addr = 0x1fcd
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;LASER_CONTROL&#39;:
            addr = 0x1fd1
            s = self.regwrite(0x0004, addr)
            return s, self.regread(0x0006)

        elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
            addr = 0x1fb1
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_USE_LASER&#39;:
                return val &amp; 0xFF
            else:
                return val &gt;&gt; 8

        elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
            addr = 0x1fb5
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_OVRD_ANAMODE&#39;:
                return s, val &amp; 0xFF
            else:
                return s, val &gt;&gt; 8

        elif name == &#39;B_LVDS_PD&#39;:
            addr = 0x1fb9
            s = self.regwrite(0x0004, addr)
            return self.regread(0x0006)

        elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
            addr = 0x1fbd
            s = self.regwrite(0x0004, addr)
            val = self.regread(0x0006)
            if name == &#39;B_EN_PHASESWEEP&#39;:
                return s, val &amp; 0xFF
            else:
                return s, val &gt;&gt; 8

        else:
            raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))
            return  0, -1


    def SetIndirectRegister(self, name, val):
        &#34;&#34;&#34;
        Set indirect registers
        Inputs:
            name: register name 
            val: register value 

        Outputs:
            status

        &#34;&#34;&#34;
        if name == &#39;N_OVRD_ANAMODE&#39;:
            addr = 0x1fc1
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_0&#39;:
            addr = 0x1fc5
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_1&#39;:
            addr = 0x1fc9
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;WAVE_FUNCTION_2&#39;:
            addr = 0x1fcd
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;LASER_CONTROL&#39;:
            addr = 0x1fd1
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
            addr = 0x1fb1
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_USE_LASER&#39;:
                s_  = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
            addr = 0x1fb5
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_OVRD_ANAMODE&#39;:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        elif name == &#39;B_LVDS_PD&#39;:
            addr = 0x1fb9
            s = self.regwrite(0x0000, addr)
            s_ = self.regwrite(0x0002, np.uint16(val))

        elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
            addr = 0x1fbd
            s = self.regwrite(0x0004, addr)
            prevVal = self.regread(0x0006)
            s = self.regwrite(0x0000, addr)
            if name == &#39;B_EN_PHASESWEEP&#39;:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
            else:
                s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

        else:
            raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))

        s = self.regwrite(0x000C, 0x00C4)
        val = self.regread(0x0012)
        return s and self.regwrite(0x0012, np.uint16(val + 1)) # update sequence


    def LoadGainOffsetCalib(self, fname):
        &#34;&#34;&#34;
        Loads gain and offset to memory
        Inputs:
            fname: location of csv file 

        Outputs:
            none

        &#34;&#34;&#34;
        fin = open(fname, &#39;r&#39;)
        csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)
        arr = np.array([],dtype=np.uint16)
        for row in csv_reader:
            arr = np.append(arr, np.uint16(int(str(row[0]),0)))
        
        ADC_updnoffset = arr[0]
        ADC_iramp = arr[1]

        Vref1DAC = arr[2]
        Vref1Set = arr[3]
        Vref2DAC = arr[4]
        Vref2Set = arr[5]
        Vref3DAC = arr[6]
        Vref3Set = arr[7]
        VCMDAC = arr[8]
        VCMSet = arr[9]
        inverseGlobalADCGain = np.zeros(4,dtype=np.uint16)
        inverseGlobalADCGain[0] = arr[10]
        inverseGlobalADCGain[1] = arr[11]
        inverseGlobalADCGain[2] = arr[12]
        inverseGlobalADCGain[3] = arr[13]
        perColGain = arr[14:12814]
        perColOffset = arr[12814:25614]

        dac_ctrl2_s1 = Vref1DAC | (Vref2DAC &lt;&lt; 8)
        dac_ctrl3_s1 = Vref3DAC

        if &#39;VCMDAC&#39; != 0:
            dac_ctrl3_s1 = dac_ctrl3_s1| (VCMDAC &lt;&lt; 8)

        dac_ctrl2_s1_mask = 0x003F * (Vref1Set != 0) + 0x3F00 * (Vref2Set != 0)
        dac_ctrl3_s1_mask = 0x003F * (Vref3Set != 0)

        if VCMSet != 0 and VCMDAC != 0:
            dac_ctrl3_s1_mask = dac_ctrl3_s1_mask + 0x3F00 * (VCMSet != 0)
    
        val = self.regread(0x0112)
        if val != 22833:
            raise Exception(&#39;Cannot Communicate with chip / incorrect chipId&#39;)

        digPwrDown = self.regread(0x0014)
        s = self.regwrite(0x0014, 0x0000)

        s = self.regwrite(0x0102, ADC_updnoffset)
        s = s and self.regwrite(0x0104, ADC_iramp)
        s = s and self.regwriteburst(0x0520, inverseGlobalADCGain, &#39;increment&#39;)
        s = s and self.regrmw(0x012E, dac_ctrl2_s1, dac_ctrl2_s1_mask)
        s = s and self.regrmw(0x0130, dac_ctrl3_s1, dac_ctrl3_s1_mask)

        # perColGain
        s = s and self.regwrite(0x0500, 0x0008)
        s = s and self.regwrite(0x0502, 0x0000)
        s = s and self.regwriteburst(0x0504, perColGain)
        s = s and self.regrmw(0x0528, 0x0000, 0x0004)

        # perColOffset
        s = s and self.regwrite(0x0500, 0x0004)
        s = s and self.regwrite(0x0502, 0x0000)
        s = s and self.regwriteburst(0x0504, perColOffset)
        s = s and self.regrmw(0x0528, 0x0000, 0x0002)

        s = self.regwrite(0x0014, digPwrDown)
        if s:
            print(&#39;Gain and Offset calibration data loaded!&#39;)


    def SetLSDACValue(self, LSDAC_VALUE):
        &#34;&#34;&#34;
        Sets LSDAC value. This function encrypts the LSDAC values
        before writing to memory
        Inputs:
            LSDAC_VALUE: 2D array of LSDAC value (unencrypted) 

        Outputs:
            none

        &#34;&#34;&#34;

        #Stop execution before configuring LSDAC
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        while( regData[0] != 0x0):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)

        address, value = LSDAC.GenerateLSDACBlock(LSDAC_VALUE, self.n_modes_cfg)
        numel = len(address)
        newAddresses = np.array([])
        newValues = np.zeros(numel*2,dtype=object)
        for i in range(numel):
            newAddresses = np.append(newAddresses, np.array([0x0000,0x0002]))
        newValues[::2] = address
        newValues[1::2] = value
        print(&#39;Addr&#39;, newAddresses)
        print(&#39;Val&#39;, newValues)
        self.regwrite( np.asarray(newAddresses, dtype=np.uint16), np.asarray(newValues, dtype=np.uint16))

        #Start execution again after configuring LSDAC
        self.dev.writeSPISingle( 0x000C, 0x0001)

        print(&#39;LSDAC value set to&#39;, LSDAC_VALUE)
        try:
            logging.info(&#39;LSDAC value set to&#39; + str(LSDAC_VALUE))
        except:
            pass



    def ReadBoardADC(self, val):
        &#34;&#34;&#34;
        Read onboard ADC value
        Inputs:
            val: value 

        Outputs:
            ADC value 

        &#34;&#34;&#34;
        return self.dev.getADCvalue(val)


    def _setInternalClassMode( self):
        &#34;&#34;&#34;Configures internal variables depending in the selected mode.

        Inputs:
            none

        Outputs:
            none
        &#34;&#34;&#34;
        with open(&#39;config/CameraModeInfo.yaml&#39;) as y:
            modeInfo = yaml.load(y, Loader=yaml.SafeLoader)

        try:
            self.width = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;width&#39;]
            self.height = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;height&#39;]
            self.subFrames = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;nCaptures&#39;]
            self.nFreq = len(modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqsMhz&#39;])
            self.nPhases = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;nPhases&#39;]
            self.freqs = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqsMhz&#39;]
            self.freqPerPhase = modeInfo[&#39;mode&#39;][int(self.Mode)][&#39;freqPerPhase&#39;]
        except:
            raise Exception(&#34;Invalid mode selected (valid modes = 0-10)&#34;)
                
        self.rawImage = np.zeros( (self.height, self.width, self.subFrames), dtype = np.int16)
        self.pRAW = np.zeros( (self.height, self.width * self.subFrames), dtype = np.int16)
        self.unwrappedDepth = np.zeros( (self.height, self.width, self.nFreq), dtype = np.double)
        return 0

    def setFPS( self, fps):
        &#34;&#34;&#34;Changes camera framerate
        
        :param fps: Camera framerate 
        :type fps: int 
        :returns: None  
        :rtype: None 
        &#34;&#34;&#34;
        self.dev.setCAMFps(fps)


    def GetFramesADCCalib(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for ADC calibration
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            success: status of capture 
            frames: frames in a 3D array 

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)

        frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 = np.resize(subImage, (self.height, self.width))
                frames[:,:,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - ADC Calib&#39;)
        logging.info(&#39;Frame captured - ADC Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        

        return success, frames


    def GetFramesPixVoltage(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for pixel voltage test
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            success: status of capture  
            frames: frames in a 3D array  

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)

        frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize(image16, (self.height, self.width))
                frames[:,:,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - ADC Calib&#39;)
        logging.info(&#39;Frame captured - ADC Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        
        return success, frames


    def GetFramesCompDACalib(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for comparator DAC calibratiom
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            GT: gain tag values 
            ADC: ADC values 
            Sat: Saturation status values 

        &#34;&#34;&#34;
        # self.QuickStartSensor()
        self.Start()

        time.sleep(0.5)
        
        frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            #RawImage = self.dev.getFloatImage()
            tmp = tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]
            subImage = RawImage[0 : self.width*self.height]
            image16 = np.resize(subImage, (self.height, self.width))
            frames[:,:,0,frm] = image16.copy()

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                success = True

        print(&#39;Frame captured - CompDAC Calib&#39;)
        logging.info(&#39;Frame captured - CompDAC Calib&#39;)

        self.Stop()
        
        imgRaw = frames[2:,:,:,:]
        GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
        ADC = imgRaw.astype(np.uint16) &amp; 1023
        SAT = ADC &lt; 3

        if np.any(SAT == True):
            print(&#39;Saturation detected in comparator calibration frame!&#39;)
            logging.warning(&#39;Saturation detected in comparator calibration frame!&#39;)

        print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
        logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
        print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
        logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
        print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
        logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


        return GT,ADC,SAT

    def GetFramesPCGO(self, nFrames=1):
        &#34;&#34;&#34;
        Captures frames for per column gain and offset
        Inputs:
            nFrames: number of frames to capture 

        Outputs:
            GT: gain tag values 
            ADC: ADC values 
            Sat: Saturation status values 

        &#34;&#34;&#34;
        self.QuickStartSensor()

        time.sleep(0.5)
        
        frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
        for frm in range(nFrames):
            #RawImage = self.dev.getFloatImage()
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            RawImage = tmp[0]

            if self.dev.validFrame !=1:
                raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
                return -1
            else:
                subImage = RawImage[0 : self.width*self.height]
                image16 = np.resize(subImage, (self.height, self.width))
                frames[:,:,0,frm] = image16.copy()
                success = True

        print(&#39;Frame captured - perColumn Calib&#39;)
        logging.info(&#39;Frame captured - perColumn Calib&#39;)
        # self.QuickStopSensor()
        #self.dev.stopSensor()
        self.QuickStopSensor()
        # time.sleep(0.1)
        
        imgRaw = frames[20:,:,:,:]
        GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
        ADC = imgRaw.astype(np.uint16) &amp; 1023
        SAT = ADC &lt; 3

        if np.any(SAT == True):
            print(&#39;Saturation detected in Per Col GO calibration frame!&#39;)

        print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
        logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
        print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
        logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
        print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
        logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


        return GT,ADC,SAT

    
    def procFrame( self):
        &#34;&#34;&#34;Retrieves a frame from the camera and process the frame data filling the internal buffers and processing the
        raw data from the camera.
        
        :returns: None 
        :rtype: None 
        &#34;&#34;&#34;

        RawImage = self.dev.getFloatImage()
        time.sleep(debug_delay)
        #RawImage = self.dev.getImage8U()
        if( self.dev.validFrame != 1):
        #if( self.dev.IO.validFrame != 1):
            return -1
        else:
            RawImage = RawImage[0]
            #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
            RAW = RawImage
            RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
            self.pRAW = RAW.copy()

            for i in range( self.subFrames):
                subImage = RawImage[ i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal( subImage)
                image16 = np.resize( image16, (self.height, self.width))
                
                self.rawImage[:,:,i] = image16.copy()

            for i in range( len(self.freqs)):                
                f = self.freqs[i]
                depth = self.visualize_map( self.rawImage[:,:,i*self.nPhases:(i+1)*self.nPhases], f)[0]

                self.unwrappedDepth[:,:,i] = depth.copy()

        return 0



    def block_max(self, img):
        &#34;&#34;&#34;
        Computes x and y coordinates of the brightest spot
        in the image
        Inputs:
            img: image array 

        Outputs:
            max_x: x coordinate of maximum brightness 
            max_y: y coordinate of maximum brightness 
        &#34;&#34;&#34;
        res = ndimage.interpolation.zoom(img,0.125)
        max_blk = np.where(res == np.amax(res))
        max_x = np.clip(max_blk[1][0] * 8 + 4, 16, 1007)
        max_y = np.clip(max_blk[0][0] * 8 + 4, 16, 1007)
        return max_x, max_y



    def StreamAndCapturePCM(self, paramDict = dict()):
        &#34;&#34;&#34;
        Streams and captures PCM image
        Inputs:
            paramDict: dictionary containing frame parameters 

        Outputs:
            True 
            frames_dict: dictionary containing frames and header 
        &#34;&#34;&#34;
         # Header Info

        keys = list(paramDict.keys())
        
        mode = 3

        if &#39;nFrames&#39; in keys:
            nFrames = paramDict[&#39;nFrames&#39;]
        else:
            nFrames = 5

        if &#39;fileName&#39; in keys:
            filename = paramDict[&#39;fileName&#39;]
        else:
            now = datetime.now()
            filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

        if &#39;outputFormat&#39; in keys:
            outputFormat = paramDict[&#39;outputFormat&#39;]
        else:
            outputFormat = &#39;pkl&#39;


        self.StartSensor()
        Temp_sensor_offset = 1493.55 # From calibration
        Temp_sensor_slope = 5.45 # From calibration
        self.changeMode(mode)


        while(True):

            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            #RawImage = self.dev.getImage8U()
            if( self.dev.validFrame != 1):
            #if( self.dev.IO.validFrame != 1):
                print(&#39;Invalid frame&#39;)
                pass

            else:
                RawImage = tmp[0]
                #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
                RAW = RawImage
                RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
                subImage = RawImage[0:self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal( subImage)
                image16 = np.resize( image16, (self.height, self.width))
                orig_image = np.copy(image16)
                image16 = image16 + np.amin( image16)*-1
                image16 = np.array( image16, dtype=np.uint16)

                # process image for visualization        
                mImg = np.uint8( (image16/np.amax(image16)*(255)))
                max_x, max_y = self.block_max(mImg)
                mImg = cv2.applyColorMap( mImg, cv2.COLORMAP_BONE)
                Imgstr = &#34;Relative PCM Image&#34;
                text1 = &#34;Press &#39;d&#39; to save and stop steaming&#34;
                text2 = &#34;Brightest 32x32 ROI mean = &#34; + str(np.round(np.mean(orig_image[max_y-16:max_y+16,max_x-16:max_x+16]),3))

                font = cv2.FONT_HERSHEY_SIMPLEX
                fontScale = 1
                fontColor = (255,0,255) #BGR
                thickness = 2
                org1 = (50, 50)
                org2 = (50, 1000)

                mImg = cv2.putText(mImg, text1, org1, font, fontScale, fontColor, thickness, cv2.LINE_AA)
                mImg = cv2.putText(mImg, text2, org2, font, fontScale, fontColor, thickness, cv2.LINE_AA)

                mImg = cv2.rectangle(mImg, (max_x-16, max_y-16), (max_x+16, max_y+16), (0,0,255), 2)

                #cv2.putText( mImg, str(j), ( 200, 200), cv2.FONT_HERSHEY_SIMPLEX, .5, ( 0, 0, 0), 2, cv2.LINE_AA)
                cv2.imshow( Imgstr, mImg)

            c = cv2.waitKey(50) &amp; 0xFF
            if (c == ord(&#39;d&#39;)) :
                cv2.destroyAllWindows()
                break
                


        captures = self.subFrames
        print(captures)
        # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
        #     captures = captures - 1

        Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
        Header_tmp = np.zeros(nFrames, dtype=object)
        RawImage = np.zeros(nFrames,dtype=object)
        Header = np.zeros([captures, nFrames],dtype=object)

        frm = 0
        count = 0
        while frm &lt; nFrames:
            print(&#39;Frame #&#39;, frm)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                print(&#39;skipped frame&#39;)
                pass
            else:
                RawImage[frm] = tmp[0]
                Header_tmp[frm] = tmp[1]
                frm = frm + 1
            print(&#39;count:&#39;, count)
            count = count + 1

        self.QuickStopSensor()
                
        Header_tmp_per_capture_size = 128

        for frm in range(nFrames):
            print(&#39;Restructuring frm #:&#39;, frm)
            for i in range(captures):
                Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
                subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize( image16, (self.height, self.width))
                Img[:,:,i,frm] = image16.copy()
                Header[i][frm] = dict()
                Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
                Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
                Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
                Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
                Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
                Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
                Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
                Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
                Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
                Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
                Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
                Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
                Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
                Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
                Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF

        if outputFormat == &#39;pkl&#39;:
            output = dict()
            output[&#39;Image&#39;] = Img
            output[&#39;Header&#39;] = Header
            f = open(filename, &#39;wb&#39;)
            pickle.dump(output, f)
            f.close()
        elif outputFormat == &#39;bin&#39;:
            for frm in range(nFrames):
                write_file = open(filename[:-4] + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)
        else:
            raise Exception(&#39;Invalid output format for storing frames.&#39;)

        frames_dict = dict()
        frames_dict[&#39;Image&#39;] = Img
        frames_dict[&#39;Header&#39;] = Header

        return True, frames_dict


    def CaptureFramesP0(self, paramDict = dict()):
        &#34;&#34;&#34;
        Captures frames for P0 calibration
        Inputs:
            paramDict: dictionary containing frame parameters 

        Outputs: 
            True 
            output: dictionary containing frames and header 
        &#34;&#34;&#34;

        keys = list(paramDict.keys())
        
        if &#39;mode&#39; in keys:
            mode = paramDict[&#39;mode&#39;]
        else:
            mode = 3

        if &#39;nFrames&#39; in keys:
            nFrames = paramDict[&#39;nFrames&#39;]
        else:
            nFrames = 5

        if &#39;nWarmupFrames&#39; in keys:   
            nWarmupFrames = paramDict[&#39;nWarmupFrames&#39;]
        else:
            nWarmupFrames = 5

        if &#39;OVERRIDE_LSDACS&#39; in keys:
            OVERRIDE_LSDACS = paramDict[&#39;OVERRIDE_LSDACS&#39;]
        else:
            OVERRIDE_LSDACS = False

        if &#39;LSDACValue&#39; in keys:
            LSDACValue = paramDict[&#39;LSDACValue&#39;]
        else:
            LSDACValue = -1 # default value

        if &#39;feedbackCap&#39; in keys:
            feedbackCap = paramDict[&#39;feedbackCap&#39;]
        else:
            feedbackCap = 0x8B42

        if &#39;samplingCap&#39; in keys:
            samplingCap = paramDict[&#39;samplingCap&#39;]
        else:
            samplingCap = 0x0333

        if &#39;fileName&#39; in keys:
            filename = paramDict[&#39;fileName&#39;]
        else:
            now = datetime.now()
            filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

        if &#39;enableSweep&#39; in keys:
            enableSweep = paramDict[&#39;enableSweep&#39;]
        else:
            enableSweep = False

        if &#39;outputFormat&#39; in keys:
            outputFormat = paramDict[&#39;outputFormat&#39;]
        else:
            outputFormat = &#39;pkl&#39;

        if &#39;also_save_image_as_bin&#39; in keys:
            also_save_image_as_bin = paramDict[&#39;also_save_image_as_bin&#39;]
        else:
            also_save_image_as_bin = False

        if &#39;displayFrame&#39; in keys:
            displayFrame = paramDict[&#39;displayFrame&#39;]
        else:
            displayFrame = False

        if &#39;displayDuration&#39; in keys:
            displayDuration = paramDict[&#39;displayDuration&#39;]
        else:
            displayDuration = 3


        if &#39;feedbackCap&#39; in keys:
            success = self.regwrite(0x10C, feedbackCap)
        if &#39;samplingCap&#39; in keys:
            success = self.regwrite(0x10E, samplingCap)

        # Disabling gain correction
        # success = self.regwrite(0x027C, 0x0000)

        if enableSweep:
            self.SetIndirectRegister(&#39;B_EN_PHASESWEEP&#39;, 1)

        Temp_sensor_offset = 1493.55 # From calibration
        Temp_sensor_slope = 5.45 # From calibration

        self.StartSensor()

        self.changeMode(mode)

        if OVERRIDE_LSDACS:
            success = self.SetLSDACValue(LSDACValue)


        # Warmup frames
        for i in range(nWarmupFrames):
            print(&#39;Warmup Frame #&#39;, i)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                tries = 2
                while((self.dev.validFrame != 1) and (tries &gt; 0)):
                    print(&#39;Frame retry #&#39;, tries)
                    time.sleep(0.5)
                    tmp = self.dev.getFloatImage()
                    time.sleep(0.5)
                    tries = tries - 1
                    if((self.dev.validFrame != 1) and (tries == 0)):
                        sys.exit()

        hdr_tmp = tmp[1]
        print(((hdr_tmp[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope)

        captures = self.subFrames
        # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
        #     captures = captures - 1

        Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
        Header_tmp = np.zeros(nFrames, dtype=object)
        RawImage = np.zeros(nFrames,dtype=object)
        Header = np.zeros([captures, nFrames],dtype=object)


        frm = 0
        count = 0
        while frm &lt; nFrames:
            print(&#39;Frame #&#39;, frm)
            tmp = self.dev.getFloatImage()
            time.sleep(debug_delay)
            if( self.dev.validFrame != 1):
                print(&#39;skipped frame&#39;)
                pass
            else:
                RawImage[frm] = tmp[0]
                Header_tmp[frm] = tmp[1]
                frm = frm + 1
            print(&#39;count:&#39;, count)
            count = count + 1

        self.QuickStopSensor()
                
        Header_tmp_per_capture_size = 128

        for frm in range(nFrames):
            print(&#39;Restructuring frm #:&#39;, frm)
            for i in range(captures):
                Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
                subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
                # convert fractional raw image from camera to 16bit signed image
                image16 =  self.dev.ConvertFloat2LinearVal(subImage)
                image16 = np.resize( image16, (self.height, self.width))
                Img[:,:,i,frm] = image16.copy()
                Header[i][frm] = dict()
                Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
                Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
                Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
                Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
                Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
                Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
                Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
                Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
                Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
                Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
                Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
                Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
                Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
                Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
                Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF


        output = dict()
        output[&#39;Image&#39;] = Img
        output[&#39;Header&#39;] = Header

        if outputFormat == &#39;pkl&#39;:
            f = open(filename, &#39;wb&#39;)
            pickle.dump(output, f)
            f.close()
        elif outputFormat == &#39;bin&#39;:
            if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
                os.mkdir(filename[:-4]+&#39;_bin&#39;)

            frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

            for frm in range(nFrames):
                write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

        elif outputFormat == &#39;none&#39;:
            pass # do not save frames
            
        else:
            raise Exception(&#39;Invalid output format for storing frames.&#39;)

        if also_save_image_as_bin and outputFormat != &#39;bin&#39;:
            if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
                os.mkdir(filename[:-4]+&#39;_bin&#39;)

            frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

            for frm in range(nFrames):
                write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
                tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
                # tmp_flattened = np.zeros([],dtype=np.int16)
                for i in range(captures):
                    if i == 0:
                        tmp_flattened = tmp[:,:,i].flatten()
                    if i &gt; 0 :
                        tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
                tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

        if displayFrame:
            plt.figure()
            plt.imshow(np.mean(Img, axis=3)[:,:,0])
            plt.show(block=False)
            plt.pause(displayDuration)
            plt.close()

        return True, output


    def changeMode( self, Mode):
        &#34;&#34;&#34;Changes image sensor mode. This function will not change the camera resolution.
        
        :param Mode: image sensor mode. 
        :type Mode: int 
        :returns: None 
        :rtype: None 
        &#34;&#34;&#34;
        self.Mode = Mode
        self._setInternalClassMode()

        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        while( regData[0] != 0x0):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)
        self.dev.writeSPISingle( 0x0200, self.Mode)
        self.dev.writeSPISingle( 0x000C, 0x0001)


    def visualize_map(self, pixout, f_mhz):
        &#34;&#34;&#34;
        Visualizes map
        Inputs:
            pixout: raw pixel values 
            f_mhz: frequency in mhz 

        Outputs:
            dist: distance map in meter 
            ampl: amplitude map 
        &#34;&#34;&#34;          
        nPhase = self.nPhases #len(pixout[0,0,:])
        V1_real = np.sum(np.array([np.cos(2*np.pi*n/nPhase)
                        for n in range(0, nPhase)]) * pixout, axis=2)
        V1_imag = np.sum(-1 * np.array([np.sin(2*np.pi*n/nPhase)
                        for n in range(0, nPhase)]) * pixout, axis=2)
        dist = (299792458/(4*np.pi*f_mhz*1000000)*np.arctan2(V1_imag, V1_real))
        dist = dist % (299792458 * (1/f_mhz/1000000) / 2) # Rolling phases
        ampl = np.abs(V1_real, V1_imag)
        
        
        return dist, ampl # in meters

    def programCSV( self, filename):
        &#34;&#34;&#34;
        Programs the sensor with csv
        Inputs:
            filename: csv filename 

        Outputs:
            none 
        &#34;&#34;&#34; 
        fin = open(filename)
        csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)

        if( self._debug):
            fname = &#34;firmware0.bin&#34;
            fwrite = open( fname, &#34;w+b&#34;)
            fdebug = open( &#34;debug.txt&#34;, &#34;w&#34;)

        regAddr = 0x0000
        regData = 0x0000
        RAMAddr = 0x0000
        Data = []
        rData = []
        rAddr = []
        i = 0
        j = 0
        k = 0
        z = 0
        TxLen = 0
        prevTxLen = 0
        bProgram = 0
        bProgramRAM = 0

        for row in csv_reader:
            bProgram = 0
            bProgramRAM = 0

            try:
                TxLen = int( row[4])
            except:
                print( &#34;error parsing len&#34; + str(row))
                sys.exit()
            try:
                regAddr = int( row[0], 16)
            except:
                #print( &#34;error parsing reg addr&#34; + str(row))
                regAddr = -1

            try:
                regData = int( row[1], 16)
            except:
                print( &#34;error parsing reg data&#34; + str(row))
                regData = -1

            if( TxLen &gt; 2):
                if( regAddr != -1):
                    Data.append( regAddr)                    
                if( regData != -1):
                    Data.append( regData)  
                if( len(rAddr) &gt; 0):
                    bProgram = 1
            else:
                if( self._debug):
                    fwrite.write( regAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    fwrite.write( regData.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                
                i = i + 1
                rAddr.append( regAddr)
                rData.append( regData)

                if( len( Data) &gt; 0):
                    bProgramRAM = 1
    
            if( bProgram):
                print( &#34;programming &#34; + str( len(rAddr)) + &#34; single registers&#34;)
                i = 0            
                j = j + 1
                
                if( self.dev != None):
                    self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
                    #time.sleep(2)
                    pass

                if( self._debug):
                    fwrite.close()
                    fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                    fwrite = open( fname, &#34;w+b&#34;)
                    for i in range( len( rAddr)):
                        fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)

                rData = []
                rAddr = []

            if( bProgramRAM):
                print( &#34;programming RAM &#34; + str( len(Data)*2-2) + &#34; registers&#34;)
                i = 0
                RAMAddr = []
                RAMAddr = int(Data[0])
                #Data.remove(0)
                #Data = Data[1:-1]
                del Data[0]
                if( self._debug):                
                    fwrite.write( RAMAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    for dat in Data:
                        fwrite.write( dat.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

                    fwrite.close()
                    j = j + 1
                    fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                    fwrite = open( fname, &#34;w+b&#34;)

                if( self.dev != None):
                    RAMData = np.zeros( (len( Data)*2), dtype = np.uint8)                
                    for i in range( len(Data)):
                        RAMData[2*i] = Data[i] &gt;&gt; 8
                        RAMData[2*i+1] = Data[i] &amp; 0xFF
                    self.dev.writeSPIBurst( RAMAddr, RAMData)

                if( self._debug):
                    k = 0
                    for dat in Data:
                        if k == 0:
                            fdebug.write( hex(RAMAddr) + &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                        else:
                            if( k%2 == 0):
                                fdebug.write( &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                            else:
                                fdebug.write( hex(dat))
                        k = k + 1

                    if( k%2 ==0):
                        fdebug.write(&#34;\n&#34;)
                Data = []
            k = k + 1

        if( len( rAddr) &gt; 0):
            print( &#34;programming &#34; + str( len( rAddr)) + &#34; final registers&#34;)
            i = 0
            j = j + 1

            if( self._debug):
                fwrite.close()
                fname = &#34;firmware_final.bin&#34;
                fwrite = open( fname, &#34;w+b&#34;)
                for i in range( len( rAddr)):
                    fwrite.write( rAddr[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                    fwrite.write( rData[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

            if( self.dev != None):
                self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
                pass

            if( self._debug):
                for i in range( len( rAddr)):
                    fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)
        if( self._debug):
            fdebug.close()

    def PowerMonitor( self,PMId):
        &#34;&#34;&#34;This function reads the voltage, current and power measured by a given
        power monitor in the Malka board.

        :param dev: Ardacho camera pointer. 
        :type dev: Ardacho IOLib device class. 
        :param PMId: Power Monitor id. Use any of the ids defined at the top of the application script. 
        :type PMId: int      
        :returns: returns a list with the measured parameters [ Voltage, Current, Power] 
        :rtype: [ float, float, float] 
        &#34;&#34;&#34;

        CONF_REG = 0x00
        VBUS_REG = 0x02
        POWER_REG = 0x03
        SHUNT_REG = 0x01
        CURR_REG = 0x04
        CAL_REG = 0x05
        
        self.dev.writePowerMonReg( PMId, CONF_REG, 0x4007 | 2 &lt;&lt; 9 | 4 &lt;&lt; 6 | 4 &lt;&lt; 3 )
        time.sleep(0.1)
        Vbus =  self.dev.readPowerMonReg( PMId, VBUS_REG)
        Cal = self.dev.readPowerMonReg( PMId, CAL_REG)
        CUR = self.dev.readPowerMonReg( PMId, CURR_REG)
        SHUNT = self.dev.readPowerMonReg( PMId, SHUNT_REG)
        PWR = self.dev.readPowerMonReg( PMId, POWER_REG)


        Volt = round(Vbus * 1.25/1000, 3)
        if( PMId == VMAIN_DEV_ID):
            Imax = (0.00512/0.01)*((32768)/Cal) # Vmain uses 0.01 shunt resistor
        else:
            Imax = (0.00512/0.02)*((32768)/Cal) # Vaux, Vdepth and Vsys uses 0.02 shunt resistor

        ILSB = (Imax/(32768))
        Curr =  round(CUR* ILSB,6)
        PwrLSB = 25*ILSB
        Power = round(PWR * PwrLSB, 6)
        return [ Volt, Curr, Power ]


    def sensorPowerDown( self):
        &#34;&#34;&#34;
        De-initialize camera
        Inputs:
            none 

        Outputs:
            0
        &#34;&#34;&#34; 
        # De-Initialize the camera
        self.dev.setGpio( CAM_RESET_N, 0)
        self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        self.dev.setGpio( PS_VAUXVPS1, 0)
        self.dev.setGpio( PS_VAUXVPS2, 0)
        self.dev.setGpio( PS_V5VVPS3, 0)
        self.dev.setGpio( LMZ_EN, 0)
        self.dev.setGpio( CAM_RESET_N, 0)

        # Wait for CAM_SHUTDOWN_N to go low indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 0    # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            time.sleep(0.1)
            if( cam_shutdown == 0):
                break
            else:
                retries = retries - 1

        if( retries == 0):
            print( &#34;Error during camera de-initialization&#34;)
            self.dev.setGpio( DEPTH_VAUX_RUN, 0)
            self.dev.setGpio( PS_VAUXVPS2, 0)
            self.dev.setGpio( PS_VAUXVPS1, 0)
            self.dev.setGpio( PS_V5VVPS3, 0)
            self.dev.setGpio( LMZ_EN, 0)
            return -1

        return 0

          
    def sensorPowerUp( self):
        &#34;&#34;&#34;
        Implements sensor initialization sequence enabling the power regulators and making functional checks.
        Inputs:
            none 

        Outputs:
            0 
        &#34;&#34;&#34; 
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0xF8]) # MZ1: Added VAUX DAC set for 12V 
        self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9A, 0x2C]) # MZ1: Added VAUX DAC set for 22V       
        #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xDE]) # MZ1: Added VAUX DAC set for 27V 

        self.dev.setGpio( CAM_RESET_N, 0) # reset camera
        self.dev.setGpio( LMZ_EN, 1) # enable Vmain
        [ Vmain, Imain, Pmain] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
        # MZ: Added current and voltage measurements
        print(&#39;Vmain: &#39; + str(Vmain) + &#39;, Imain: &#39; + str(Imain) + &#39;, Pmain: &#39; + str(Pmain))

        self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
        [ Vdepth, Idepth, Pdepth] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vmain
        # MZ: Added current and voltage measurements
        print(&#39;Vdepth: &#39; + str(Vdepth) + &#39;, Idepth: &#39; + str(Idepth) + &#39;, Pdepth: &#39; + str(Pdepth))
        
        self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth
        time.sleep( 0.004) # wait 4 ms

        self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
        self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
        [ Vsys, Isys, Psys] = self.PowerMonitor( VSYS_DEV_ID)
        # MZ: Added current and voltage measurements
        print(&#34;Vsys: &#34; + str(Vsys) + &#34;, Isys: &#34; + str(Isys)+&#34;, Psys: &#34; + str(Psys))
        
        time.sleep( 0.004) # wait 4 ms

        self.dev.setGpio( DEPTH_VAUX_RUN, 1)
        time.sleep(0.0001) # wait 100 us
        [ Vaux, Iaux, Paux] = self.PowerMonitor( VAUX_DEV_ID)
        # MZ: Added current and voltage measurements
        print(&#39;Vaux: &#39; + str(Vaux) +&#39;, Iaux: &#39; + str(Iaux) +&#39;, Paux: &#39; + str(Paux))

        # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
        retries = 10
        while( retries &gt; 0):
            if (self.module_class == &#39;Walden_R1&#39;):
                cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
            else:
                cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
            if( cam_shutdown == 1):
                break
            else:
                retries = retries - 1


        # wait 2 ms
        time.sleep( 0.002)
        self.dev.setGpio( CAM_RESET_N, 1)        

        return 0

    def bitget(self, var, pos): # !Python indexing!
        &#34;&#34;&#34;
        Returns bit in a position
        Inputs:
            var: hex or decimal 
            pos: position 

        Outputs:
            bit in the position 
        &#34;&#34;&#34; 
        return(var &gt;&gt; pos) &amp; 1

    def repmatdec2Hex(self, dec, rep):
        &#34;&#34;&#34;
        Repeats decimal as a hex
        Inputs:
            dec: decimal input 
            rep: repeat count 

        Outputs:
            hex output 
        &#34;&#34;&#34; 
        hexval = hex(dec).split(&#39;x&#39;)[-1]
        out = &#39;&#39;
        for _ in range(rep):
            out = out + hexval
        return int(&#39;0x&#39; + out.upper(),0)

    def get_addr_hex2dec(self, addr, k):
        &#34;&#34;&#34;
        Repeats decimal as a hex with padding
        Inputs:
            addr: address 
            k: repeat count 

        Outputs:
            hex output with padding 
        &#34;&#34;&#34; 
        dec = int(addr,0) + k*2
        hex_raw = hex(dec).split(&#39;x&#39;)[-1]
        pad_zero = 4 - len(hex_raw)
        return (&#39;0x&#39; + &#39;0&#39;*pad_zero + hex_raw)

    def generate_truthtable(self, n):
        &#34;&#34;&#34;
        Generates a &#39;truth table&#39; of n variables
        Inputs:
            n: variable length 

        Outputs:
            truth table 
        &#34;&#34;&#34;
        if n &lt; 1:
            return [[]]
        subtable = self.generate_truthtable(n - 1)
        return [ row + [v] for row in subtable for v in [0,1] ]

    def ReadAmpGainSetting(self):
        &#34;&#34;&#34;
        Reads amplifier gain setting
        Inputs:
            none 

        Outputs:
            amp gain setting 
        &#34;&#34;&#34; 
        val = self.regread(0x014E) # Analog NCDS mode bit
        # self.error_assert(success, &#39;Cannot read Analog NCDS mode bit&#39;)
        ncds_mode = self.bitget(int(val), 3)

        if ncds_mode:
            Cin = np.array([160,80,80]) # For ADSD3100, Cin is different between analog and digital CDS modes
        else:
            Cin = np.array([320,160,80])

        Cfb = np.array([4*25.88,2*20.24,2*6.76,2*5.17,2*3.57]) # gain= (160*cin1+80*cin0+80)/(2*3.57+2*5.17*cfb0+2*6.76*cfb1+2*20.24*cfb2+4*25.88*cfb3)

        tmp1 = np.sum(np.array(self.generate_truthtable(2)) * Cin[0:2], axis=1) + Cin[2]
        tmp2 = np.sum(np.array(self.generate_truthtable(4)) * Cfb[0:4], axis=1) + Cfb[4]
        ampgainTable = np.transpose(np.reshape(tmp1,[1,len(tmp1)])) / tmp2

        # plt.plot(ampgainTable[0,:], label=&#34;Cin=0&#34;)
        # plt.plot(ampgainTable[1,:], label=&#34;Cin=1&#34;)
        # plt.plot(ampgainTable[2,:], label=&#34;Cin=2&#34;)
        # plt.plot(ampgainTable[3,:], label=&#34;Cin=3&#34;)
        # plt.legend()
        # plt.ylabel(&#39;Gain&#39;)
        # plt.xlabel(&#39;Cfb&#39;)
        # plt.title(&#39;ampgainTable&#39;)
        # plt.show()

        # Manually update table with gains measured on ADSD3100
        ampgainTable[3,1] = 16.75
        ampgainTable[3,2] = 14.7
        ampgainTable[3,4] = 6.8
        ampgainTable[3,11] = 2.35
        ampgainTable[0,8] = 0.72


        RegisterValueCin = self.regread(0x010E) # AMP Cin register
        # self.error_assert(success, &#39;Cannot read AMP Cin register&#39;)
        RegisterValueCfb = self.regread(0x010C) # AMP Cfb register
        # self.error_assert(success, &#39;Cannot read AMP Cfb register&#39;)

        ampgain = np.zeros(4)

        for i in range(4):
            Cfb = (int(RegisterValueCfb) &gt;&gt; i*4) &amp; 15
            Cin = (int(RegisterValueCin) &gt;&gt; i*4) &amp; 3
            ampgain[i] = ampgainTable[Cin, Cfb]

        return ampgain

    def SetDiffDacSfVoltage(self, DacCal, DacSel, TargetDiff, CMwindow, DacCal_folderName=&#34;&#34;):
        &#34;&#34;&#34;
        Sets differential DAC voltage
        Inputs:
            DacCal: DAC calibration values 
            DacSel: DAC selection ex: AMPTEST0 etc 
            TargetDiff: Voltage difference 
            CMWindow: CommonMode window 
            DacCal_folderName: location of file to store DacCal values 

        Outputs:
            DacCal : DAC calibration values 
            AMPTEST0, AMPTEST1, CMREF values 
            diff_meas_out: measured differential voltage 

        &#34;&#34;&#34; 
        #s, valArr = self.regreadburst(0x0E00, 80,&#39;increment&#39;)
        self.regwrite(0x0014,0x0000)
        #print(valArr)
        NUM_ITERATIONS = 1
        MAX_ERROR = [5e-3, 15e-3]

        if len(list(DacCal.keys())) == 0:
            CMREF_Samples = [150, 203, 255]
            AMPTEST_Samples = [150, 176, 203, 229, 255]
            CMREF_meas = np.zeros(len(CMREF_Samples))
            AMPTEST0_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
            AMPTEST1_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
            for j in range(len(CMREF_Samples)-1, -1,-1):
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF_Samples[j]))
                success = self.dac_cmref_set(np.uint8(CMREF_Samples[j]))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                CMREF_meas[j] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF&#39;)
                for k in range(len(AMPTEST_Samples)-1,-1,-1):
                    # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                    success = self.dac_amptest0_set(np.uint8(AMPTEST_Samples[k]))
                    self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
                    # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                    success = self.dac_amptest1_set(np.uint8(AMPTEST_Samples[k]))
                    self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)
                    AMPTEST0_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0&#39;)
                    AMPTEST1_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1&#39;)
            y,x = np.meshgrid(AMPTEST_Samples,CMREF_Samples)
            Xmeas = [[np.ones([len(CMREF_Samples)*len(AMPTEST_Samples)])], [np.transpose(x).flatten()],
                    [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
            Xmeas = np.squeeze(np.transpose(Xmeas))
            M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST0_meas).flatten(), rcond=None)[0] # Matrix left division

            [y,x] = np.meshgrid(range(0,256), range(0,256))
            Xfit = [[np.ones([np.size(y)])], [np.transpose(x).flatten()],
                    [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
            Xfit = np.squeeze(np.transpose(Xfit))
            DacCal[&#39;AMPTEST0_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

            M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST1_meas).flatten(), rcond=None)[0] # Matrix left division
            DacCal[&#39;AMPTEST1_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

            # Dacs are non-linear at low code values, so remove these points from the predicted data
            DacCal[&#39;AMPTEST0_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
            DacCal[&#39;AMPTEST0_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan
            DacCal[&#39;AMPTEST1_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
            DacCal[&#39;AMPTEST1_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan

            DacCal[&#39;CMREF_pred&#39;] = np.polyval(np.polyfit(CMREF_Samples, CMREF_meas, 1),range(0,256))
            DacCal[&#39;CMREF_pred&#39;][0:np.min(CMREF_Samples)] = np.nan # Remove CMREF values below min sampled DAC code

            DacCal[&#39;RangeCMREF&#39;] = np.array([CMREF_meas[-1], CMREF_meas[0]])
            DacCal[&#39;RangeAMPTEST0&#39;] = np.array([np.max(AMPTEST0_meas[:,0]), np.min(AMPTEST0_meas[:,-1])])
            DacCal[&#39;RangeAMPTEST1&#39;] = np.array([np.max(AMPTEST1_meas[:,0]), np.min(AMPTEST1_meas[:,-1])])
            if(DacCal_folderName != &#34;&#34;):
                f = open(os.path.join(DacCal_folderName, &#39;DacCal.pkl&#39;), &#39;wb&#39;)
                pickle.dump(DacCal, f)
                f.close()


        if DacSel.upper() == &#39;CMREF-AMPTEST0&#39;:
            # Sanity check inputs
            if (np.max(CMwindow) + TargetDiff/2) &lt; DacCal[&#39;RangeCMREF&#39;][0]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0])))
        
            if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

            diff = -(-np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;]).astype(np.float)
            cm = 0.5 * (np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;])

            diff = diff.astype(np.float)
            cond1 = ~np.isnan(cm)
            cond2 = ~np.isnan(cm)
            cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
            cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
            diff[cond1] = np.nan
            diff[cond2] = np.nan

            x,y = np.shape(diff)

            tmp = (abs(diff - TargetDiff)).flatten()
            error_pred = np.sort(tmp)
            idx = np.argsort(tmp)

            if error_pred[0] &gt; MAX_ERROR[1]:
                print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
                logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

            if NUM_ITERATIONS &gt; 1:
                diff_meas = np.zeros(NUM_ITERATIONS)

            for i in range(NUM_ITERATIONS):
                CMREF = int(idx[i] % x)
                AMPTEST0 = int(np.floor(idx[i] / x))

                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
                success = self.dac_cmref_set(np.uint8(CMREF))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
                success = self.dac_amptest0_set(np.uint8(AMPTEST0))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

                if NUM_ITERATIONS &gt; 1:
                    diff_meas[i] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)

            if NUM_ITERATIONS &gt; 1:
                idxMinErr = np.argmin(np.abs(TargetDiff - diff_meas))
                CMREF = int(idxMinErr[i] % x)
                AMPTEST0 = int(np.floor(idxMinErr[i] / x))
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
                success = self.dac_cmref_set(np.uint8(CMREF))
                self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
                success = self.dac_amptest0_set(np.uint8(AMPTEST0))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

            cmSetpoint = cm[AMPTEST0-1, CMREF-1] # get predicted CM voltage
            AMPTEST1 = np.nanargmin(np.abs(cmSetpoint - DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF-1]))
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST1))
            success = self.dac_amptest1_set(np.uint8(AMPTEST1))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

            if NUM_ITERATIONS &gt; 1:
                diff_meas_out = diff_meas[idxMinErr]
            else:
                diff_meas_out = -self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)            

        elif DacSel.upper() == &#39;AMPTEST1-AMPTEST0&#39;:
            # Sanity check inputs
            if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

            if (np.max(CMwindow) - TargetDiff/2) &lt; DacCal[&#39;RangeAMPTEST0&#39;][0]:
                raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0]))
                logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0])))


            CMREF = np.nanargmin(np.abs(np.mean(CMwindow) - DacCal[&#39;CMREF_pred&#39;]))

            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF))
            success = self.dac_cmref_set(np.uint8(CMREF))
            self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)

            diff = -np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1])
            cm = 0.5 * (np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1]))

            diff = -diff.astype(np.float)
            cond1 = ~np.isnan(cm)
            cond2 = ~np.isnan(cm)
            cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
            cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
            diff[cond1] = np.nan
            diff[cond2] = np.nan

            x,y = np.shape(diff)

            tmp = (abs(diff - TargetDiff)).flatten()
            error_pred = np.sort(tmp)
            idx = np.argsort(tmp)

            if error_pred[0] &gt; MAX_ERROR[1]:
                print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
                logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

            AMPTEST1 = int(idx[0] % x)
            AMPTEST0 = int(np.floor(idx[0] / x))

            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
            success = self.dac_amptest0_set(np.uint8(AMPTEST0))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], AMPTEST1)
            success = self.dac_amptest1_set(np.uint8(AMPTEST1))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

            diff_meas_out = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)

        # print(self.regreadburst(0x0E00, 80,&#39;increment&#39;))
        # s = self.regwriteburst(0x0E00, valArr, &#39;increment&#39;)
        self.regwrite(0x0014,0x0000)

        return DacCal, {&#39;CMREF&#39;: CMREF, &#39;AMPTEST0&#39;: AMPTEST0, &#39;AMPTEST1&#39;: AMPTEST1}, diff_meas_out

    def UpdateUseCaseFrameSetting(self, usecaseId, fieldname, fieldVal):
        &#34;&#34;&#34;
        Updates use case frame setting
        Inputs:
            usecaseId 
            fieldname 
            fieldVal 

        Outputs:
            success: status 
        &#34;&#34;&#34; 

        status = 0
        prevVal = 0

        if (usecaseId &lt; 0 or usecaseId &gt; 15):
            return False, False

        if fieldname == &#39;DRAINSTYLE&#39;:
            fieldIndex = 7
        else:
            return False, False

        # Offset 7 is where the use case entries start in
        # DMEM1, there are Frame Details and 3 ROIs per use case (4)
        ADDR = 7 + usecaseId * 4

        # Using Bank Addressing Scheme instead of auto bank addressing using LSBs
        # of the address due to bug in addressing the entire address space
        #
        # Separate out Bank ID and Bank Address
        # (2 LSBs indicate Bank ID)

        BANK_ID = int(ADDR) &amp; 3
        BANK_ADDR = ADDR &gt;&gt; 2
        IA_SELECT_VAL = (BANK_ID &lt;&lt; 8) + 2

        status = self.regwrite(0x0500, IA_SELECT_VAL)
        status = status and (self.regwrite(0x0502, BANK_ADDR))

        if status:
            status, usecaseVals = self.regreadburst(0x0506, 32)
            if status:
                usecaseVals = np.squeeze(usecaseVals)
                prevVal = usecaseVals[fieldIndex - 1]

                usecaseVals[fieldIndex - 1] = fieldVal

                status = self.regwrite(0x502, BANK_ADDR)
                status = status and self.regwriteburst(0x0504, usecaseVals)

        return status, prevVal

    def tregwrite(self, regaddr, regval, regmask = 0):
        &#34;&#34;&#34;
        Write to register while saving original value
        Inputs:
            regaddr: register address 
            regval: register value 
            regmask: register mask 

        Outputs:
            success: status of write 
        &#34;&#34;&#34; 
        if regmask == 0:
            origVal = self.regread(regaddr)
            success = self.regwrite(regaddr, regval)
        else:
            # if regmask == &#39;increment&#39;:
            #   origVal, success = self.regreadburst(regaddr, len(regval), &#39;increment&#39;)
            #   success = success and self.regwriteburst(regaddr, regval, &#39;increment&#39;)
            # else:
            origVal = self.regread(regaddr)
            success = self.regrmw(regaddr, regval, regmask)

        if (regaddr in self.origSetting[&#39;reg&#39;][&#39;addr&#39;]) == False:
            self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], regaddr)
            self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], origVal)

        return success

    def WriteOrigSettings(self):
        &#34;&#34;&#34;
        Writes back original settings to the registers based on tregwrite
        Inputs:
            none 

        Outputs:
            none 
        &#34;&#34;&#34; 
        rs = True
        for ns in range(len(self.origSetting[&#39;reg&#39;][&#39;addr&#39;])-1,-1,-1):
            # if len(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]) &gt; 1:
            #   rs = rs and self.regwriteburst(1, 
            #                                       str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]),
            #                                       self.convert2matlabArray(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]),
            #                                       &#39;increment&#39;)
            # else:
            # rs = rs and self.regwrite(1, str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]), int(float(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])))
            rs = rs and self.regwrite(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns], self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])

            # self.error_assert(rs, &#39;Cannot restore original register settings&#39;)

    def InitModes(self, clksValue_0, LockScale_0):
        &#34;&#34;&#34;
        Initialize sensor mode
        Inputs:
            clksValue_0 
            LockScale_0 

        Outputs:
            mode: returns information of the mode
        &#34;&#34;&#34; 
        name = [&#39;native_resolution&#39;, &#39;sub_sampled_2x&#39;, &#39;sub_sampled_4x&#39;, &#39;binned&#39;, &#39;dark&#39;, &#39;preamble&#39;, &#39;postamble&#39;]
        tmp = int(&#39;0x0E30&#39;, 0) + 6* np.arange(0,len(name))
        regAddrStart = tmp
        regAddrEnd = tmp + 2
        regAddrRepeat = tmp + 4

        name = np.append(name, &#39;binned_1x2&#39;)
        regAddrStart = np.append(regAddrStart, int(&#39;0x0E12&#39;, 0))
        regAddrEnd = np.append(regAddrEnd, int(&#39;0x0E1A&#39;, 0))
        regAddrRepeat = np.append(regAddrRepeat, int(&#39;0x0E02&#39;, 0))

        repeatCount = np.zeros(len(name))
        clksValue = np.zeros(len(name), dtype=object)
        LockScale = np.zeros(len(name), dtype=object)
        for i in range(len(name)):
            clksValue[i] = clksValue_0 
            LockScale[i] = LockScale

        mode = dict(
                    name = name,
                    repeatCount = repeatCount,
                    regAddrStart = regAddrStart,
                    regAddrEnd = regAddrEnd,
                    regAddrRepeat = regAddrRepeat,
                    clksValue = clksValue,
                    LockScale = LockScale
                    )
        return mode

    def DumpTimingTool(self, var1, var2 = 0, handles = dict()):
        &#34;&#34;&#34;
        Read / write dump engine timing
        Inputs:
            var1: read or write to chip 
            var2: 0-&gt; initialize Dump Engine Structure 
            handles: contains handles to add data to 

        Outputs:
            handles: Updates handles 
        &#34;&#34;&#34; 
        if var1 == &#39;ReadfromChip&#39;:
            if var2 == 0:
                handles = self.InitDE_Struct()

            chipID = self.regread(0x112)

            digPwrDownOrigState = self.regread(0x0014, handles[&#39;dispStr&#39;])
            success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; int(&#39;0xFFFE&#39;,0), handles[&#39;dispStr&#39;])
            self.error_assert(success, &#34;Failed to un-clock gate DE&#34;)

            handles[&#39;DEclkFreq&#39;] = self.ReadDEclkFreqFromChip()

            for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])):
                RamStart = self.regread(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i]) # Read dump engine settings from chip
                RamEnd = self.regread(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i])
                handles[&#39;mode&#39;][&#39;repeatCount&#39;][i] = self.regread(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i])
                success = self.regwrite(0x0E04, 0x0001)
                success = success and self.regwrite(0x0E06, RamStart)
                self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
                success, RamVals = self.regreadburst(0x0E0A, (RamEnd-RamStart+1)*4)
                success = success and self.regwrite(0x0E04, 0x0000)
                self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
                # clksValue = self.API.legacy_ConvertDumpEngineRamFormatToWaves(RamVals)
                # clksValue = np.array(clksValue) # convert to numpy array
                clksValue = self.ConvertDumpEngineRamFormatToWaves(RamVals)
                handles[&#39;mode&#39;][&#39;clksValue&#39;][i] = clksValue[(handles[&#39;clks&#39;][&#39;DE_Addr&#39;]).astype(&#39;int&#39;), :]

            success = success and self.regwrite(0x0014, digPwrDownOrigState)
            self.error_assert(success, &#39;Failed to restore original DE clock gate state&#39;)

            return handles
        
        elif var1 == &#39;WriteToChip&#39;:
            StartAddr = 0
            [regAddValPairs, ramBlob, memoryUsedPercent] = self.GenerateDumpEngineConfig(handles, StartAddr)
            print(&#39;Using&#39;, np.round(memoryUsedPercent), &#39;%&#39;, &#39;of dump engine RAM&#39;)
            logging.info(&#39;Using &#39; + str(np.round(memoryUsedPercent)) + &#39; %&#39; + &#39; of dump engine RAM&#39;)
            digPwrDownOrigState = self.regread(0x0014) # Load digPwrDown state
            success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; 0xFFFE)
            self.error_assert(success, &#39;Failed to un-clock gate DE&#39;)
            success = success and self.regwrite(regAddValPairs[::2], regAddValPairs[1::2]) # Start/End/Repeat values
            success = success and self.regwrite(0x0E04, 0x0001) # Enable configuration of the Dump Engine RAM
            success = success and self.regwrite(0x0E06, StartAddr) # dump engine ia_addr_reg is 0x0E06
            success = success and self.regwriteburst(0x0E08, ramBlob) # Write to RAM
            success = success and self.regwrite(0x0E04, 0x0000) # Disable configuration of the Dump Engine RAM

            success = success and self.regwrite(0x0014, digPwrDownOrigState) # Restore original DE clock gate state
        else:

            return False

    def DumpTimingTransformation(self, *argv):
        &#34;&#34;&#34;
        Perform Dump Engine transformations
        Inputs:
            variable arguments as below
            DE_struct: Dump Engine structure dictionary 
            mode: sensor mode such as native, binned etc 
            transformtion 

        Outputs:
            DE_struct: updated DE_struct
        &#34;&#34;&#34; 
        DE_Struct = argv[0]
        mode = argv[1]
        signalName = argv[2]
        transformation_tmp = argv[3]
        DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;])

        tmp = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == mode)
        modeIdx = tmp[0][0]

        if len(signalName) &gt; 0: # is array
            signalIdx = np.zeros(len(signalName))
            for i in range(len(signalName)):
                if transformation_tmp.startswith(&#39;ampTestSel_&#39;):
                    signalIdx[i] = 0
                else:
                    tmp = np.where(DE_Struct[&#39;clks&#39;][&#39;Name&#39;] == signalName[i])
                    signalIdx[i] = tmp[0][0]
        
        elif len(signalName) == 0:
            signalIdx = np.zeros(1)
            signalIdx[0] = 0

        transformation = np.zeros(len(signalIdx),dtype=object)
        for i in range(len(signalIdx)):
            transformation[i] = transformation_tmp

        # Perform transformations
        for signalCnt in range(len(signalIdx)):
            clkData = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt]),:]

            if transformation[signalCnt].startswith(&#39;ampTestSel_&#39;):
                MUX_TRANSITION_DELAY = 1
                idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 24)[0][0] # DR_Addr = 24 is amp_clk0
                ampclk = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
                idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 25)[0][0] # DR_Addr = 25 is amp_clk1
                ampclk = ampclk + 2 * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
                tmp1 = ampclk == 1
                tmp2 = ampclk == 3
                integrateSample = tmp1 | tmp2
                integrateSample = np.roll(integrateSample, MUX_TRANSITION_DELAY)
                amp_testsel_name = np.array([&#39;ATP&#39;,&#39;ATN&#39;,&#39;DACAMPTEST0&#39;,&#39;DACAMPTEST1&#39;,&#39;DACCMREF&#39;])
                amp_testsel_mux = np.array([[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1]])
                inputList = transformation[0].split(&#39;_&#39;)

                amp_testselp_reset_val = amp_testsel_mux[(np.where(inputList[1].upper() == amp_testsel_name))[0][0],:]
                amp_testseln_reset_val = amp_testsel_mux[(np.where(inputList[2].upper() == amp_testsel_name))[0][0],:]
                amp_testselp_int_val = amp_testsel_mux[(np.where(inputList[3].upper() == amp_testsel_name))[0][0],:]
                amp_testseln_int_val = amp_testsel_mux[(np.where(inputList[4].upper() == amp_testsel_name))[0][0],:]

                amp_testselp_idx = np.zeros(3, dtype=int)
                amp_testseln_idx = np.zeros(3, dtype=int)
                amp_testselp_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 37))[0][0]) # DR_Addr = 37 is amp_testselp[0] (ADSD3100)
                amp_testselp_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 42))[0][0]) # DR_Addr = 42 is amp_testselp[1] (ADSD3100)
                amp_testselp_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 43))[0][0]) # DR_Addr = 43 is amp_testselp[2] (ADSD3100)
                amp_testseln_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 44))[0][0]) # DR_Addr = 44 is amp_testseln[0] (ADSD3100)
                amp_testseln_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 45))[0][0]) # DR_Addr = 45 is amp_testselp[1] (ADSD3100)
                amp_testseln_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 46))[0][0]) # DR_Addr = 46 is amp_testselp[2] (ADSD3100)

                for k in range(3):
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k],:] = 0 # default all amp_testsel signals low
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k],:] = 0

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], np.invert(integrateSample)] = amp_testselp_reset_val[k] # amp_testselp reset
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], np.invert(integrateSample)] = amp_testseln_reset_val[k] # amp_testseln reset

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], integrateSample] = amp_testselp_int_val[k] # amp_testselp integer
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], integrateSample] = amp_testseln_int_val[k] # amp_testseln integer

            else:
                if transformation[signalCnt].startswith(&#39;copyTo&#39;):
                    destMode = transformation[signalCnt][6:]
                    destModeIdx = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == destMode.lower())[0][0] #+ 1

                    sourceLength = list(np.shape(clkData))[0]
                    destLength = list(np.shape(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]))[1]
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:]

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])


                    if sourceLength &gt; destLength:
                        for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                            append_bits = np.ones(sourceLength-destLength) * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][-1]
                            DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = np.append(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i], append_bits)
                    elif sourceLength &lt; destLength:
                        for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                            DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][0:sourceLength]

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]  = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])

                    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][(signalIdx).astype(int),:]

                else:
                    print(&#39;Unknown tranformation&#39;)
                    logging.error(&#39;Unknown transformation&#39; + str(transformation[signalCnt]))

            if transformation[signalCnt] != &#39;stretchshrink&#39;:
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt])] = clkData

        return DE_Struct

    def InitDE_Struct(self, *argv):
        &#34;&#34;&#34;
        Initialize a dump engine structure
        Inputs:
            variable arguments 

        Outputs:
            DE_struct:  Dump engine structure dictionary 
        &#34;&#34;&#34; 
        NCLKS_INIT = 8
        DE_Struct = dict()
        if len(argv) &gt; 0:
            DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = argv[0]
        else:
            DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = False

        if len(argv) &gt; 1:
            DE_Struct[&#39;dispStr&#39;] = argv[1]
        else:
            DE_Struct[&#39;dispStr&#39;] = &#39;&#39;

        DE_Struct[&#39;clks&#39;], clksValue, LockScale = self.ReadConfigFile(&#39;./config/DumpTimingToolConfig_ADSD3100.csv&#39;)
        clksValue = np.transpose(np.reshape(clksValue, [1, len(clksValue)]))
        clksValue = clksValue * np.ones([1, NCLKS_INIT])

        DE_Struct[&#39;mode&#39;] = self.InitModes(clksValue, LockScale)

        return DE_Struct

    def ReadConfigFile(self, fname):
        &#34;&#34;&#34;
        Read dump engine configuration file (.csv)
        Inputs:
            fname: csv filename 

        Outputs:
            DE_struct: updated DE_struct 
        &#34;&#34;&#34; 
        clks = dict()
        clks[&#39;DE_Addr&#39;] = []
        clks[&#39;Name&#39;] = []
        clks[&#39;View&#39;] = []
        DefaultValue = []
        LockScale_Default = []
        clks[&#39;ToolTip&#39;] = []

        # path = os.path.dirname(os.path.abspath(__file__))
        # with open(os.path.join(path,fname)) as csv_file:
        with open(fname) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
            line_count = 0
            for row in csv_reader:
                if line_count == 0:
                    line_count += 1
                else:
                    clks[&#39;DE_Addr&#39;] = np.append(clks[&#39;DE_Addr&#39;], int(row[0]))
                    clks[&#39;Name&#39;]  = np.append(clks[&#39;Name&#39;] , row[1])
                    clks[&#39;View&#39;] = np.append(clks[&#39;View&#39;], bool(row[2]))
                    DefaultValue = np.append(DefaultValue, int(row[3]))
                    LockScale_Default = np.append(LockScale_Default, int(row[4]))
                    clks[&#39;ToolTip&#39;] = np.append(clks[&#39;ToolTip&#39;], row[5])
        csv_file.close()

        return clks, DefaultValue, LockScale_Default

    def ReadDEclkFreqFromChip(self):
        &#34;&#34;&#34;
        Read dump engine clock frequency
        Inputs:
            none 

        Outputs:
            adc_pllFreq/clk_de_div : adc pll frequency divied by DE clock division 
        &#34;&#34;&#34; 
        adcPllRegisterValue = self.regread(0x010A) # Read ADC PLL register
        adc_c = int(adcPllRegisterValue) &amp; 31
        adc_end5 =  (int(adcPllRegisterValue) &gt;&gt; 8) &amp; 15
        adc_pllFreq = 24*(adc_end5 + 4*(adc_c+1))

        clkDeRegisterValue = self.regread(0x011A) # Read Clock DE register
        de_c = int(clkDeRegisterValue) &amp; 31
        de_end5 = (int(clkDeRegisterValue) &gt;&gt; 8) &amp; 15
        clk_de_div = de_end5 + 4*(de_c+1)

        return adc_pllFreq/clk_de_div

        return clks, DefaultValue, LockScale_Default

    def GenerateDumpEngineConfig(self, handles, ramStart):
        &#34;&#34;&#34;
        Generates DE config register address value pairs
        Inputs:
            handles 
            ramStart: RAM start address 

        Outputs:
            regAddValPairs: register address value pairs 
            ramBlob: sorted clksValue in DE RAM format 
            memoryUsedPercent: RAM memory percent used 
        &#34;&#34;&#34; 
        ramOffset = ramStart
        ramBlob = []
        regAddValPairs = []
        signalOrderIdx = np.argsort(handles[&#39;clks&#39;][&#39;DE_Addr&#39;])

        for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])): # Error prone ,not !
            # outputData = self.API.legacy_ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
            outputData = self.ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i], ramOffset))
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i], ramOffset + len(outputData)/4 -1))
            ramOffset = ramOffset + len(outputData)/4
            regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i], handles[&#39;mode&#39;][&#39;repeatCount&#39;][i]))
            ramBlob = np.append(ramBlob, outputData)

        memoryUsedPercent = (ramOffset/(1024-6))*100

        if memoryUsedPercent &gt; 100:
            raise Exception(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
            logging.error(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
        
        return regAddValPairs, ramBlob, memoryUsedPercent

    def ConvertDumpEngineRamFormatToWaves(self, RamVals):
        &#34;&#34;&#34;
        Convert DE RAM format to wave format
        Inputs:
            RamVals: RAM values 

        Outputs:
            clksValue: clocks values 
        &#34;&#34;&#34; 
        RamVals = np.squeeze(np.array(RamVals).astype(np.uint16))
        DE_Vectors = RamVals.view(np.uint64) &amp; ((2**48)-1) # signals [47:0]
        duration = RamVals[3::4] # bits [63:48]
        DE_VectorsExpanded = np.repeat(DE_Vectors, duration+1)
        if len(DE_VectorsExpanded) == 0:
            clksValue = np.array[[]]
        else:
            clksValue = np.zeros([48, len(DE_VectorsExpanded)])
            for i in range(len(DE_VectorsExpanded)):
                clksValue[:,i] = list(np.binary_repr(DE_VectorsExpanded[i],48))[::-1] 
                # Expand out individual bits, LSB first (convert to double)
        
        return np.array(clksValue)

    def ConvertWavesToDumpEngineRamFormat(self, clksValue):
        &#34;&#34;&#34;
        Convert wave format to DE RAM format
        Inputs:
            clksValue: clocks values 

        Outputs:
            RamVals: RAM values 
            
        &#34;&#34;&#34; 
        DE_Vectors = np.dot(np.transpose(clksValue),np.array((2**(np.arange(0,np.shape(clksValue)[0],dtype=np.uint64)))))
        # Least significant bit first! Matrix multiplication is not supported on integer classes, so
        # keep as double precision here and convert to uint64 before adding the repeat count bits.
        idx = np.where(np.diff(np.append(-1, DE_Vectors)) != 0) # Time index for each unique signal state
        duration = np.diff(np.append(idx, len(DE_Vectors))) - 1 # Duration of each state
        RAM_Data = np.uint64(duration * (2**48)) + np.uint64(DE_Vectors[idx]) # Repeat count [63:48], signals [47:0]
        RamVals = RAM_Data.view(np.uint16) # Output in 16bit chunks
        
        return RamVals

    # MZ: Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation
    def InvertLSMOD( self):
        &#34;&#34;&#34;
        Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation
        Inputs:
            none

        Outputs:
            none
            
        &#34;&#34;&#34; 
        lsmod_cfg1 = self.dev.readSPISingle( 0x0138,1)
        val = lsmod_cfg1[0]
        val = ((val &amp; 0x0F) &lt;&lt; 4) + ((lsmod_cfg1[0] &amp; 0xF0) &gt;&gt; 4)
        print (&#34;Swapped = &#34;+ hex(val))
        self.dev.writeSPISingle(0x0138, val)
        print(&#34;LSMOD1L Config = &#34;+ hex(val))

    #  MZ: Function to program Archer config registers (I2C only)
    def ConfigADSD3000( self,slaveID,cfg):
        &#34;&#34;&#34;
        Function to program Archer config registers (I2C only)
        Inputs:
            slaveID: I2C slave ID 
            cfg: configuration array 

        Outputs:
            none
            
        &#34;&#34;&#34; 
        for i in range(cfg.shape[0]):
            addr_hi = (cfg[i,0]&gt;&gt;8) &amp; 0xFF
            addr_lo = cfg[i,0] &amp; 0xFF
            data_hi = (cfg[i,1]&gt;&gt;8) &amp; 0xFF
            data_lo = cfg[i,1] &amp; 0xFF
            self.dev.writeI2C(I2C_MODULE, slaveID, [addr_hi, addr_lo, data_hi, data_lo]) 
    
    
    def GetLDTemp( self, skipPtrSet, driver):
        &#34;&#34;&#34;
        Function read LD temperature
        Inputs:
            skipPtrSet: skip pointer set 
            driver: driver name 

        Outputs: 
            TempOut: Temperature  
            
        &#34;&#34;&#34; 
        TempOut = 999
        # return TempOut
        if driver == ARCHER:
            if skipPtrSet == False:
                self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x07]) # TempSense No Burst
                #self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x01]) # TempSense during bursts
            rd_reg = self.dev.readI2C(I2C_MODULE, ADSD3000_ID, 2)
            print(&#39;DigTemp:&#39;,str(rd_reg[0]*0x100+rd_reg[1]))
            TempOut = (rd_reg[0]*0x100+rd_reg[1])*0.389214 - 1134.766
        if driver == INTERSIL:
            if skipPtrSet == False:
                self.dev.writeI2C(I2C_MODULE, TEMP_SENSE_ID, [TEMP_REG, 0, 0])
            #TempDig = [0,0]
            TempDig = self.dev.readI2C(I2C_MODULE, TEMP_SENSE_ID, 2)
            TempOut = (TempDig[0]*0x100 + TempDig[1])&gt;&gt;4
            if TempOut &gt; 0x7FF:
                TempOut = ((TempOut ^ 0xFFF) + 1)*-0.0625
            else:
                TempOut = TempOut*0.0625
        return TempOut</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="CalibAPI.CalibAPI.CamMeasureAnaTestVoltage"><code class="name flex">
<span>def <span class="ident">CamMeasureAnaTestVoltage</span></span>(<span>self, SOURCE, N_AVERAGES=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Measures a voltage from ADSD3100 Analog Test mux using on board ADC.
</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>
<p>source: Internal ADSD3100 voltage to measure.
Valid options are:
'DAC_TX1'
'DAC_TX2'
'DAC_AMPTEST1'
'DAC_BIAS1'
'DAC_BIAS2'
'DAC_SATREF'
'DAC_VREST'
'DAC_AMPTEST0'
'DAC_CMREF'
'DACwithSF_X-Y',
<br>
X,Y valid options are {AMPTEST0,AMPTEST1,CMREF,GND}
where X = adc_muxp_in/amp_testseln/ATP
and Y = adc_muxn_in/amp_testselp/ATN
'comp_vref0'
'comp_vref1'
'comp_vref2'
'amp_vcm'
<br>
'AnaTestMux_0' &hellip; 'AnaTestMux_31' </p>
</li>
<li>
<p>num_averages (optional). How many times to read the voltage and average </p>
</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li>voltage (optional). Measured voltage</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CamMeasureAnaTestVoltage(self, SOURCE, N_AVERAGES = 1):
    &#34;&#34;&#34;
    Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  
    Inputs:
        - source: Internal ADSD3100 voltage to measure.  Valid options are: 
           &#39;DAC_TX1&#39; 
           &#39;DAC_TX2&#39; 
           &#39;DAC_AMPTEST1&#39; 
           &#39;DAC_BIAS1&#39; 
           &#39;DAC_BIAS2&#39; 
           &#39;DAC_SATREF&#39; 
           &#39;DAC_VREST&#39; 
           &#39;DAC_AMPTEST0&#39; 
           &#39;DAC_CMREF&#39; 
           &#39;DACwithSF_X-Y&#39;,                       
             X,Y valid options are {AMPTEST0,AMPTEST1,CMREF,GND} 
             where X = adc_muxp_in/amp_testseln/ATP 
               and Y = adc_muxn_in/amp_testselp/ATN 
           &#39;comp_vref0&#39; 
           &#39;comp_vref1&#39; 
           &#39;comp_vref2&#39; 
           &#39;amp_vcm&#39;                              
           &#39;AnaTestMux_0&#39; ... &#39;AnaTestMux_31&#39; 
    
        - num_averages (optional). How many times to read the voltage and average 
    
    Outputs:
        - voltage (optional). Measured voltage 
    &#34;&#34;&#34;

    # voltage = CamMeasureAnaTestVoltage(source)
    # voltage = CamMeasureAnaTestVoltage(source, num_averages)
    
    # Measures a voltage from ADSD3100 Analog Test mux using on board ADC.  On ADSD3100
    # BUB this requires jumpers on J29 pins 2-3 (ATP_ADC) and J31 pins 2-3 (ATN_ADC)
    

    val = self.regread(0x0026)
    time.sleep(0.1)
    success = True
    val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running

    if(val!=0):
        time.sleep(1.0)
        val = self.regread(0x0026)
        print(&#34;Retry - val = &#34;, val)
        time.sleep(5.0)
        val = self.regread(0x0026)
        print(&#34;Retry - val = &#34;, val)
        time.sleep(0.1)
        val = int(val) &amp; 0x0800 #check bit 11 to see if useq is still running

    #self.error_assert(success, &#39;Cannot communicate with chip&#39;)
    self.error_assert(not(val), &#39;Must stop uSeq before calling&#39;)
    ADC_config = dict()

    ADC_config[&#39;mux&#39;] = &#39;AIN0-AIN1&#39;

    val = self.regread(0x017C)

    origSettingADC = dict()

    origSettingADC[&#39;xosc_ctrl&#39;] = int(val)
    origSettingADC[&#39;reg&#39;] = dict()
    origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = []
    origSettingADC[&#39;reg&#39;][&#39;val&#39;] = []

    val = int(val) | 0x0020
    s_ = self.regwrite(0x017C, val)
    # self.error_assert(success, &#39;Unable to write register 0x017C&#39;)

    val = self.regread(0x0146)
    origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], int(val))
    origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0146)
    val = int(val) &amp; 0xFF7F #power up bandgap
    success = success and self.regwrite(0x0146, val)
    self.error_assert(success, &#39;Unable to power up bandgap&#39;)

    val = self.regread(0x0160) # original state of ana_test_mux_s1
    #self.error_assert(success, &#39;Unable to read ana_test_mux_s1&#39;)
    origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0160)
    origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

    val = self.regread(0x0128) # original state of dac_ctrl2
    #self.error_assert(success, &#39;Unable to read dac_ctrl2&#39;)
    origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0128)
    origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

    val = self.regread(0x0014) # original state of digPwrDown
    #self.error_assert(success, &#39;Unable to read digPwrDown&#39;)
    origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x0014)
    origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

    if SOURCE.startswith(&#39;DAC_&#39;):
        dacNames = [&#39;DAC_TX1&#39;,&#39;DAC_TX2&#39;,&#39;DAC_AMPTEST1&#39;,&#39;DAC_BIAS1&#39;,&#39;DAC_BIAS2&#39;,&#39;DAC_SATREF&#39;,&#39;DAC_VREST&#39;,&#39;DAC_AMPTEST0&#39;,&#39;DAC_CMREF&#39;]
        try:
            dacIdx = dacNames.index(SOURCE)
        except:
            raise Exception(&#39;Cannot measure voltage. Unknown DAC value&#39;)

        success = self.regwrite(0x0128, 0x0000)
        self.error_assert(success, &#39;Unable to power up DACs&#39;)

        val = self.regread(0x012A)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], 0x012A)
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
        val = int(val) &amp; 0xFF00
        val = val | int(dacIdx + 1) # =1 due to difference in indexing
        success = success and self.regwrite(0x012A, val)
        success = success and self.regwrite(0x0160, 0x0013)
        self.error_assert(success, &#39;Unable to configuire test mux&#39;)

    elif SOURCE.startswith(&#39;amp_vcm&#39;):
        val = self.regread(0x0146)
        val = val &amp; 0xFFCF
        s = self.regwrite(0x0146, val)
        success = self.regwrite(0x0160, 0x001B)

    elif SOURCE.startswith(&#39;DACwithSF_&#39;):
        val = self.regread(0x0146)
        val = int(val) &amp; 0xFFFD
        success = success and self.regwrite(0x0146, val)
        success = success and self.regwrite(0x0128, 0x0000)
        self.error_assert(success, &#39;Unable to power up DACs and column currents&#39;)

        tmp = SOURCE.split(&#39;_&#39;)
        DAC1 = tmp[1].split(&#39;-&#39;)[0]
        try: # if there is no DAC2
            DAC2 = tmp[1].split(&#39;-&#39;)[1]
        except:
            ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
            DAC2 = DAC1

        if (DAC2 == &#39;GND&#39; and DAC1 != &#39;GND&#39;):
            ADC_config[&#39;mux&#39;] = &#39;AIN0-GND&#39;
            DAC2 = DAC1
        elif (DAC1 == &#39;GND&#39;):
            ADC_config[&#39;mux&#39;] = &#39;AIN1-GND&#39;
            DAC1 = DAC2

        if DAC1.upper() == &#39;AMPTEST0&#39;:
            amptestselOverrideVal = int(&#39;0x2000&#39;, 0)
        elif DAC1.upper() == &#39;AMPTEST1&#39;:
            amptestselOverrideVal = int(&#39;0x3000&#39;, 0)
        elif DAC1.upper() == &#39;CMREF&#39;:
            amptestselOverrideVal = int(&#39;0x4000&#39;, 0)
        else:
            raise Exception(&#39;Unknown source for DAC selection [0]&#39;)

        if DAC2.upper() == &#39;AMPTEST0&#39;:
            amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0400&#39;, 0)
        elif DAC2.upper() == &#39;AMPTEST1&#39;:
            amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0420&#39;, 0)
        elif DAC2.upper() == &#39;CMREF&#39;:
            amptestselOverrideVal = amptestselOverrideVal | int(&#39;0x0800&#39;, 0)
        else:
            raise Exception(&#39;Unknown source for DAC selection [1]&#39;)

        # val = self.regread(0x0E10)
        # print(&#39;regread 0x0E10&#39;, hex(val))
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # val = self.regread(0x0E18)
        # print(&#39;regread 0x0E18&#39;, hex(val))
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        # val = self.regread(0x0E00)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E00&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)


        # s = self.regrmw(0x0014,0x0000,0x0001)
        # s = self.regrmw(0x0E00,0x0002,0x0003)
        # s = self.regrmw(0x0E18,0x7C20,0x7C20)
        # s = self.regrmw(0x0E10,amptestselOverrideVal,0x7C20)
        
        val = self.regread(0x0E10)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E10&#39;, 0))
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
        val = int(val) &amp; int(&#39;0x83DF&#39; ,0)
        val = val | amptestselOverrideVal
        s_ = self.regwrite(0x0E10, val) # &gt;&gt;&gt;&gt;&gt; override
        #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

        val = self.regread(0x0E18)
        origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0E18&#39;, 0))
        origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)
        val = int(val) | int(&#39;0x7C20&#39; ,0)
        s_ = self.regwrite(0x0E18, val) # &gt;&gt;&gt;&gt;&gt; override
        #self.error_assert(success, &#39;Unable to overrideamp_testselp&#39;)

        success = success and self.regwrite(0x0014, 0x0000)
        s, origSettingADC[&#39;ampMuxOrig&#39;] = self.regreadburst(0x0E1C, 10, &#39;increment&#39;)
        ampMuxVal = [0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008, 0x0200, 0x0008]
        s = self.regwriteburst(0x0E1C, ampMuxVal, &#39;increment&#39;)

        # val = self.regread(0x0160)
        # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0160&#39;, 0))
        # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

        s = self.regwrite(0x0160, 0x0012)
        self.error_assert(success, &#39;Unable to configuire test mux&#39;)
        # s = self.regwrite(0x0150, 0x0105)

    elif SOURCE.startswith(&#39;comp_v&#39;):
        val = self.regread(0x0146)
        val = int(val) &amp; int(&#39;0xFFEF&#39;,0)
        success = success and self.regwrite(0x0146, val)
        self.error_assert(success, &#39;Unable to power up col_comparator&#39;)

        if SOURCE.lower() == &#39;comp_vref0&#39;:
            success = success and self.regwrite(0x0160, 0x0014)
        elif SOURCE.lower() == &#39;comp_vref1&#39;:
            success = success and self.regwrite(0x0160, 0x0015)
        elif SOURCE.lower() == &#39;comp_vref2&#39;:
            success = success and self.regwrite(0x0160, 0x0016)
        else:
            raise Exception(&#39;Unknown source&#39;)

    elif SOURCE == &#39;amp_vcm&#39;:
        val = self.regread(0x0146)
        val = int(val) &amp; int(&#39;0xFFCF&#39;,0)
        success = success and self.regwrite(0x0146, val)
        self.error_assert(success, &#39;Unable to power up col_comparator and AMP&#39;)

        success = success and self.regwrite(0x0160, 0x001B)

    elif SOURCE.startswith(&#39;AnaTestMux_&#39;):
        ana_test_mux = int(SOURCE.split(&#39;_&#39;)[1])

        if np.isnan(ana_test_mux) or ana_test_mux &gt; 31 or ana_test_mux &lt; 0:
            print(&#39;Unknown source. The AnaTestMux_ option must include a mux value between 0-31\n&#39;)

        success = self.regwrite(0x0160, ana_test_mux)

    else:
        raise Exception(&#34;Unknown source&#34;)

    # adding pause to avoid bogus readings given the sampling freq increased in the newer FW version
    # val = self.regread(0x0e16)
    # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e16&#39;, 0))
    # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

    # val = self.regread(0x0e14)
    # origSettingADC[&#39;reg&#39;][&#39;addr&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;addr&#39;], int(&#39;0x0e14&#39;, 0))
    # origSettingADC[&#39;reg&#39;][&#39;val&#39;] = np.append(origSettingADC[&#39;reg&#39;][&#39;val&#39;], val)

    # s = self.regwrite(0x0e16, 0x4000)
    # s = self.regwrite(0x0e14, 0x0100)
    muxOptions = np.array([&#39;ain0-ain1&#39;,&#39;ain0-ain3&#39;,&#39;ain1-ain3&#39;,&#39;ain2-ain3&#39;,&#39;ain0-gnd&#39;,&#39;ain1-gnd&#39;,&#39;ain2-gnd&#39;,&#39;ain3-gnd&#39;])
    tmp, = np.where(muxOptions == ADC_config[&#39;mux&#39;].lower())
    muxVal = tmp[0]

    # for i in range(N_AVERAGES-1, -1,-1):
    #   time.sleep(0.01)
    #   val = self.ReadBoardADC(muxVal)
    #   voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

    # voltage = voltage / 1000000 # in V

    vRepeat = True
    nIter = 3

    while(vRepeat and (nIter &gt;= 1)):
        # print(vRepeat,nIter)
        for i in range(N_AVERAGES-1, -1,-1):
            time.sleep(0.01)
            val = self.ReadBoardADC(muxVal)
            voltage = np.double(np.int16(val) / (2**15) * 4.096 * 1000000)

        voltage = voltage / 1000000 # in V

        if (self.prevVoltage != voltage) and (abs(voltage) &gt; 0.03) and (abs(voltage) &lt; 3.8):
            vRepeat = False
            self.prevVoltage = voltage
        else:
            time.sleep(0.1)
            nIter = nIter - 1

        # if nIter &lt; 1:
        #     print(&#39;\nONBOARD ADC ERROR\n&#39;)
        #     try:
        #         logging.info(&#39;\nONBOARD ADC ERROR\n&#39;)
        #     except:
        #         pass

    # clean up
    success = True
    keys = list(origSettingADC.keys())

    if &#39;ampMuxOrig&#39; in keys:
        success = self.regwriteburst(0x0E1C, np.array(origSettingADC[&#39;ampMuxOrig&#39;],dtype=np.uint16), &#39;increment&#39;)

    origADCAddr = np.array(origSettingADC[&#39;reg&#39;][&#39;addr&#39;],dtype=np.uint16)
    origADCVal = np.array(origSettingADC[&#39;reg&#39;][&#39;val&#39;],dtype=np.uint16)
    s = self.regwrite(origADCAddr, origADCVal)

    xosc_ctrl = origSettingADC[&#39;xosc_ctrl&#39;]

    if ((xosc_ctrl &gt;&gt; 6) &amp; 1) == 1: # if XIDLE_HOST originally was 1
        xosc_ctrl = xosc_ctrl | int(&#39;0x0010&#39;,0) # set XIDLE_HOST_set
        xosc_ctrl = xosc_ctrl &amp; int(&#39;0xFFDF&#39;,0) # dont set XIDLE_HOST_clear
        s = self.regwrite(0x017C, xosc_ctrl)
        # self.error_assert(success, &#39;Unable to restore register 0x017C&#39;)

    self.error_assert(success, &#39;Unable to restore original register settings&#39;)
    print(&#39;Analog test mux source:&#39;, SOURCE , &#39;measured voltage:&#39;, np.round(voltage, 4))
    try:
        logging.info(&#39;Analog test mux source: &#39; + str(SOURCE) +&#39; measured voltage: &#39; + str(np.round(voltage, 4)))
    except:
        pass

    return voltage</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.CaptureFramesP0"><code class="name flex">
<span>def <span class="ident">CaptureFramesP0</span></span>(<span>self, paramDict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Captures frames for P0 calibration</p>
<h2 id="inputs">Inputs</h2>
<p>paramDict: dictionary containing frame parameters </p>
<p>Outputs:
True
output: dictionary containing frames and header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CaptureFramesP0(self, paramDict = dict()):
    &#34;&#34;&#34;
    Captures frames for P0 calibration
    Inputs:
        paramDict: dictionary containing frame parameters 

    Outputs: 
        True 
        output: dictionary containing frames and header 
    &#34;&#34;&#34;

    keys = list(paramDict.keys())
    
    if &#39;mode&#39; in keys:
        mode = paramDict[&#39;mode&#39;]
    else:
        mode = 3

    if &#39;nFrames&#39; in keys:
        nFrames = paramDict[&#39;nFrames&#39;]
    else:
        nFrames = 5

    if &#39;nWarmupFrames&#39; in keys:   
        nWarmupFrames = paramDict[&#39;nWarmupFrames&#39;]
    else:
        nWarmupFrames = 5

    if &#39;OVERRIDE_LSDACS&#39; in keys:
        OVERRIDE_LSDACS = paramDict[&#39;OVERRIDE_LSDACS&#39;]
    else:
        OVERRIDE_LSDACS = False

    if &#39;LSDACValue&#39; in keys:
        LSDACValue = paramDict[&#39;LSDACValue&#39;]
    else:
        LSDACValue = -1 # default value

    if &#39;feedbackCap&#39; in keys:
        feedbackCap = paramDict[&#39;feedbackCap&#39;]
    else:
        feedbackCap = 0x8B42

    if &#39;samplingCap&#39; in keys:
        samplingCap = paramDict[&#39;samplingCap&#39;]
    else:
        samplingCap = 0x0333

    if &#39;fileName&#39; in keys:
        filename = paramDict[&#39;fileName&#39;]
    else:
        now = datetime.now()
        filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

    if &#39;enableSweep&#39; in keys:
        enableSweep = paramDict[&#39;enableSweep&#39;]
    else:
        enableSweep = False

    if &#39;outputFormat&#39; in keys:
        outputFormat = paramDict[&#39;outputFormat&#39;]
    else:
        outputFormat = &#39;pkl&#39;

    if &#39;also_save_image_as_bin&#39; in keys:
        also_save_image_as_bin = paramDict[&#39;also_save_image_as_bin&#39;]
    else:
        also_save_image_as_bin = False

    if &#39;displayFrame&#39; in keys:
        displayFrame = paramDict[&#39;displayFrame&#39;]
    else:
        displayFrame = False

    if &#39;displayDuration&#39; in keys:
        displayDuration = paramDict[&#39;displayDuration&#39;]
    else:
        displayDuration = 3


    if &#39;feedbackCap&#39; in keys:
        success = self.regwrite(0x10C, feedbackCap)
    if &#39;samplingCap&#39; in keys:
        success = self.regwrite(0x10E, samplingCap)

    # Disabling gain correction
    # success = self.regwrite(0x027C, 0x0000)

    if enableSweep:
        self.SetIndirectRegister(&#39;B_EN_PHASESWEEP&#39;, 1)

    Temp_sensor_offset = 1493.55 # From calibration
    Temp_sensor_slope = 5.45 # From calibration

    self.StartSensor()

    self.changeMode(mode)

    if OVERRIDE_LSDACS:
        success = self.SetLSDACValue(LSDACValue)


    # Warmup frames
    for i in range(nWarmupFrames):
        print(&#39;Warmup Frame #&#39;, i)
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        if( self.dev.validFrame != 1):
            tries = 2
            while((self.dev.validFrame != 1) and (tries &gt; 0)):
                print(&#39;Frame retry #&#39;, tries)
                time.sleep(0.5)
                tmp = self.dev.getFloatImage()
                time.sleep(0.5)
                tries = tries - 1
                if((self.dev.validFrame != 1) and (tries == 0)):
                    sys.exit()

    hdr_tmp = tmp[1]
    print(((hdr_tmp[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope)

    captures = self.subFrames
    # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
    #     captures = captures - 1

    Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
    Header_tmp = np.zeros(nFrames, dtype=object)
    RawImage = np.zeros(nFrames,dtype=object)
    Header = np.zeros([captures, nFrames],dtype=object)


    frm = 0
    count = 0
    while frm &lt; nFrames:
        print(&#39;Frame #&#39;, frm)
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        if( self.dev.validFrame != 1):
            print(&#39;skipped frame&#39;)
            pass
        else:
            RawImage[frm] = tmp[0]
            Header_tmp[frm] = tmp[1]
            frm = frm + 1
        print(&#39;count:&#39;, count)
        count = count + 1

    self.QuickStopSensor()
            
    Header_tmp_per_capture_size = 128

    for frm in range(nFrames):
        print(&#39;Restructuring frm #:&#39;, frm)
        for i in range(captures):
            Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
            subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
            # convert fractional raw image from camera to 16bit signed image
            image16 =  self.dev.ConvertFloat2LinearVal(subImage)
            image16 = np.resize( image16, (self.height, self.width))
            Img[:,:,i,frm] = image16.copy()
            Header[i][frm] = dict()
            Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
            Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
            Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
            Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
            Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
            Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
            Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
            Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
            Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
            Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
            Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
            Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
            Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
            Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
            Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF


    output = dict()
    output[&#39;Image&#39;] = Img
    output[&#39;Header&#39;] = Header

    if outputFormat == &#39;pkl&#39;:
        f = open(filename, &#39;wb&#39;)
        pickle.dump(output, f)
        f.close()
    elif outputFormat == &#39;bin&#39;:
        if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
            os.mkdir(filename[:-4]+&#39;_bin&#39;)

        frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

        for frm in range(nFrames):
            write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
            tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
            # tmp_flattened = np.zeros([],dtype=np.int16)
            for i in range(captures):
                if i == 0:
                    tmp_flattened = tmp[:,:,i].flatten()
                if i &gt; 0 :
                    tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
            tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

    elif outputFormat == &#39;none&#39;:
        pass # do not save frames
        
    else:
        raise Exception(&#39;Invalid output format for storing frames.&#39;)

    if also_save_image_as_bin and outputFormat != &#39;bin&#39;:
        if not os.path.exists(filename[:-4]+&#39;_bin&#39;):
            os.mkdir(filename[:-4]+&#39;_bin&#39;)

        frm_name = os.path.join(filename[:-4]+&#39;_bin&#39;, os.path.basename(filename[:-4]))

        for frm in range(nFrames):
            write_file = open(frm_name + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
            tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
            # tmp_flattened = np.zeros([],dtype=np.int16)
            for i in range(captures):
                if i == 0:
                    tmp_flattened = tmp[:,:,i].flatten()
                if i &gt; 0 :
                    tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
            tmp_flattened.tofile(write_file, format=&#39;%d&#39;)

    if displayFrame:
        plt.figure()
        plt.imshow(np.mean(Img, axis=3)[:,:,0])
        plt.show(block=False)
        plt.pause(displayDuration)
        plt.close()

    return True, output</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ConfigADSD3000"><code class="name flex">
<span>def <span class="ident">ConfigADSD3000</span></span>(<span>self, slaveID, cfg)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to program Archer config registers (I2C only)</p>
<h2 id="inputs">Inputs</h2>
<p>slaveID: I2C slave ID
cfg: configuration array </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConfigADSD3000( self,slaveID,cfg):
    &#34;&#34;&#34;
    Function to program Archer config registers (I2C only)
    Inputs:
        slaveID: I2C slave ID 
        cfg: configuration array 

    Outputs:
        none
        
    &#34;&#34;&#34; 
    for i in range(cfg.shape[0]):
        addr_hi = (cfg[i,0]&gt;&gt;8) &amp; 0xFF
        addr_lo = cfg[i,0] &amp; 0xFF
        data_hi = (cfg[i,1]&gt;&gt;8) &amp; 0xFF
        data_lo = cfg[i,1] &amp; 0xFF
        self.dev.writeI2C(I2C_MODULE, slaveID, [addr_hi, addr_lo, data_hi, data_lo]) </code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ConnectSensor"><code class="name flex">
<span>def <span class="ident">ConnectSensor</span></span>(<span>self, Mode=3, fps=10, cfg='')</span>
</code></dt>
<dd>
<div class="desc"><p>Command to connect to sensor - powerup the device, set mode, set fps,
and program cfg file</p>
<h2 id="inputs">Inputs</h2>
<p>mode: camera mode
fps: frames per second
cfg: location of .cfg file </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectSensor(self, Mode=3, fps=10, cfg = &#34;&#34;):
    &#34;&#34;&#34;
    Command to connect to sensor - powerup the device, set mode, set fps,
    and program cfg file
    Inputs:
        mode: camera mode 
        fps: frames per second 
        cfg: location of .cfg file 

    Outputs:
        none

    &#34;&#34;&#34;
    ret = self.dev.openDevice( Mode, -1)
    if( ret &lt; 0):
        print(&#34;Error opening the camera&#34;)
        return -2
    
    ret = self.sensorPowerUp()
    if( ret &lt; 0):
        print(&#34;Error during sensor power up. Please restart your system.&#34;)
        sys.exit()


    self.Mode = Mode
    self._setInternalClassMode()

    self.fps = fps
    self.dev.setCameraFrameRate( self.fps)

    # print(&#34;Config_1000.00_3p6A_66p_Ofilm.cfg&#34;)
    # time.sleep(3)

    
    print(cfg)
    logging.info(&#39;Loading cfg file: &#39; + cfg)
    time.sleep(0.5)
    self.dev.programCfg(cfg)
    # self.programCSV(&#34;process_data_Legacy_p.csv&#34;)

    if (self.module_class == &#39;Walden_R1&#39;):         # MZ: If Walden module then invert the LSMOD control register in ADSD3100
        self.InvertLSMOD()

    if( Mode != 3):
        #self.changeMode( self.Mode)
        self.dev.writeSPISingle( 0x0200, self.Mode)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ConvertDumpEngineRamFormatToWaves"><code class="name flex">
<span>def <span class="ident">ConvertDumpEngineRamFormatToWaves</span></span>(<span>self, RamVals)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert DE RAM format to wave format</p>
<h2 id="inputs">Inputs</h2>
<p>RamVals: RAM values </p>
<h2 id="outputs">Outputs</h2>
<p>clksValue: clocks values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConvertDumpEngineRamFormatToWaves(self, RamVals):
    &#34;&#34;&#34;
    Convert DE RAM format to wave format
    Inputs:
        RamVals: RAM values 

    Outputs:
        clksValue: clocks values 
    &#34;&#34;&#34; 
    RamVals = np.squeeze(np.array(RamVals).astype(np.uint16))
    DE_Vectors = RamVals.view(np.uint64) &amp; ((2**48)-1) # signals [47:0]
    duration = RamVals[3::4] # bits [63:48]
    DE_VectorsExpanded = np.repeat(DE_Vectors, duration+1)
    if len(DE_VectorsExpanded) == 0:
        clksValue = np.array[[]]
    else:
        clksValue = np.zeros([48, len(DE_VectorsExpanded)])
        for i in range(len(DE_VectorsExpanded)):
            clksValue[:,i] = list(np.binary_repr(DE_VectorsExpanded[i],48))[::-1] 
            # Expand out individual bits, LSB first (convert to double)
    
    return np.array(clksValue)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ConvertWavesToDumpEngineRamFormat"><code class="name flex">
<span>def <span class="ident">ConvertWavesToDumpEngineRamFormat</span></span>(<span>self, clksValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert wave format to DE RAM format</p>
<h2 id="inputs">Inputs</h2>
<p>clksValue: clocks values </p>
<h2 id="outputs">Outputs</h2>
<p>RamVals: RAM values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConvertWavesToDumpEngineRamFormat(self, clksValue):
    &#34;&#34;&#34;
    Convert wave format to DE RAM format
    Inputs:
        clksValue: clocks values 

    Outputs:
        RamVals: RAM values 
        
    &#34;&#34;&#34; 
    DE_Vectors = np.dot(np.transpose(clksValue),np.array((2**(np.arange(0,np.shape(clksValue)[0],dtype=np.uint64)))))
    # Least significant bit first! Matrix multiplication is not supported on integer classes, so
    # keep as double precision here and convert to uint64 before adding the repeat count bits.
    idx = np.where(np.diff(np.append(-1, DE_Vectors)) != 0) # Time index for each unique signal state
    duration = np.diff(np.append(idx, len(DE_Vectors))) - 1 # Duration of each state
    RAM_Data = np.uint64(duration * (2**48)) + np.uint64(DE_Vectors[idx]) # Repeat count [63:48], signals [47:0]
    RamVals = RAM_Data.view(np.uint16) # Output in 16bit chunks
    
    return RamVals</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.DisconnectSensor"><code class="name flex">
<span>def <span class="ident">DisconnectSensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to disconnect sensor. Stop camera and powerdown.</p>
<h2 id="inputs">Inputs</h2>
<p>none
</p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DisconnectSensor(self):
    &#34;&#34;&#34;
    Command to disconnect sensor. Stop camera and powerdown.
    Inputs:
        none  

    Outputs:
        none  

    &#34;&#34;&#34;
    i = 0
    if( self.bProgrammed == True):
        # safely stop the camera
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        
        while( regData[0] != 0x0 and i&lt;20):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)
            i = i + 1
    if( i == 20):
        print(&#34;Error stoping camera&#34;)
    print(&#34;CAMERA STOPPED&#34;)
    ret = self.sensorPowerDown()
    if( ret &lt; 0):
        print(&#34;Error during sensor power down. Please restart your system&#34;)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.DumpTimingTool"><code class="name flex">
<span>def <span class="ident">DumpTimingTool</span></span>(<span>self, var1, var2=0, handles={})</span>
</code></dt>
<dd>
<div class="desc"><p>Read / write dump engine timing</p>
<h2 id="inputs">Inputs</h2>
<p>var1: read or write to chip
var2: 0-&gt; initialize Dump Engine Structure
handles: contains handles to add data to </p>
<h2 id="outputs">Outputs</h2>
<p>handles: Updates handles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DumpTimingTool(self, var1, var2 = 0, handles = dict()):
    &#34;&#34;&#34;
    Read / write dump engine timing
    Inputs:
        var1: read or write to chip 
        var2: 0-&gt; initialize Dump Engine Structure 
        handles: contains handles to add data to 

    Outputs:
        handles: Updates handles 
    &#34;&#34;&#34; 
    if var1 == &#39;ReadfromChip&#39;:
        if var2 == 0:
            handles = self.InitDE_Struct()

        chipID = self.regread(0x112)

        digPwrDownOrigState = self.regread(0x0014, handles[&#39;dispStr&#39;])
        success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; int(&#39;0xFFFE&#39;,0), handles[&#39;dispStr&#39;])
        self.error_assert(success, &#34;Failed to un-clock gate DE&#34;)

        handles[&#39;DEclkFreq&#39;] = self.ReadDEclkFreqFromChip()

        for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])):
            RamStart = self.regread(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i]) # Read dump engine settings from chip
            RamEnd = self.regread(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i])
            handles[&#39;mode&#39;][&#39;repeatCount&#39;][i] = self.regread(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i])
            success = self.regwrite(0x0E04, 0x0001)
            success = success and self.regwrite(0x0E06, RamStart)
            self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
            success, RamVals = self.regreadburst(0x0E0A, (RamEnd-RamStart+1)*4)
            success = success and self.regwrite(0x0E04, 0x0000)
            self.error_assert(success,&#39;Failed to read dump engine settings from chip&#39;)
            # clksValue = self.API.legacy_ConvertDumpEngineRamFormatToWaves(RamVals)
            # clksValue = np.array(clksValue) # convert to numpy array
            clksValue = self.ConvertDumpEngineRamFormatToWaves(RamVals)
            handles[&#39;mode&#39;][&#39;clksValue&#39;][i] = clksValue[(handles[&#39;clks&#39;][&#39;DE_Addr&#39;]).astype(&#39;int&#39;), :]

        success = success and self.regwrite(0x0014, digPwrDownOrigState)
        self.error_assert(success, &#39;Failed to restore original DE clock gate state&#39;)

        return handles
    
    elif var1 == &#39;WriteToChip&#39;:
        StartAddr = 0
        [regAddValPairs, ramBlob, memoryUsedPercent] = self.GenerateDumpEngineConfig(handles, StartAddr)
        print(&#39;Using&#39;, np.round(memoryUsedPercent), &#39;%&#39;, &#39;of dump engine RAM&#39;)
        logging.info(&#39;Using &#39; + str(np.round(memoryUsedPercent)) + &#39; %&#39; + &#39; of dump engine RAM&#39;)
        digPwrDownOrigState = self.regread(0x0014) # Load digPwrDown state
        success = self.regwrite(0x0014, int(digPwrDownOrigState) &amp; 0xFFFE)
        self.error_assert(success, &#39;Failed to un-clock gate DE&#39;)
        success = success and self.regwrite(regAddValPairs[::2], regAddValPairs[1::2]) # Start/End/Repeat values
        success = success and self.regwrite(0x0E04, 0x0001) # Enable configuration of the Dump Engine RAM
        success = success and self.regwrite(0x0E06, StartAddr) # dump engine ia_addr_reg is 0x0E06
        success = success and self.regwriteburst(0x0E08, ramBlob) # Write to RAM
        success = success and self.regwrite(0x0E04, 0x0000) # Disable configuration of the Dump Engine RAM

        success = success and self.regwrite(0x0014, digPwrDownOrigState) # Restore original DE clock gate state
    else:

        return False</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.DumpTimingTransformation"><code class="name flex">
<span>def <span class="ident">DumpTimingTransformation</span></span>(<span>self, *argv)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Dump Engine transformations</p>
<h2 id="inputs">Inputs</h2>
<p>variable arguments as below
DE_struct: Dump Engine structure dictionary
mode: sensor mode such as native, binned etc
transformtion </p>
<h2 id="outputs">Outputs</h2>
<p>DE_struct: updated DE_struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DumpTimingTransformation(self, *argv):
    &#34;&#34;&#34;
    Perform Dump Engine transformations
    Inputs:
        variable arguments as below
        DE_struct: Dump Engine structure dictionary 
        mode: sensor mode such as native, binned etc 
        transformtion 

    Outputs:
        DE_struct: updated DE_struct
    &#34;&#34;&#34; 
    DE_Struct = argv[0]
    mode = argv[1]
    signalName = argv[2]
    transformation_tmp = argv[3]
    DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;])

    tmp = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == mode)
    modeIdx = tmp[0][0]

    if len(signalName) &gt; 0: # is array
        signalIdx = np.zeros(len(signalName))
        for i in range(len(signalName)):
            if transformation_tmp.startswith(&#39;ampTestSel_&#39;):
                signalIdx[i] = 0
            else:
                tmp = np.where(DE_Struct[&#39;clks&#39;][&#39;Name&#39;] == signalName[i])
                signalIdx[i] = tmp[0][0]
    
    elif len(signalName) == 0:
        signalIdx = np.zeros(1)
        signalIdx[0] = 0

    transformation = np.zeros(len(signalIdx),dtype=object)
    for i in range(len(signalIdx)):
        transformation[i] = transformation_tmp

    # Perform transformations
    for signalCnt in range(len(signalIdx)):
        clkData = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt]),:]

        if transformation[signalCnt].startswith(&#39;ampTestSel_&#39;):
            MUX_TRANSITION_DELAY = 1
            idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 24)[0][0] # DR_Addr = 24 is amp_clk0
            ampclk = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
            idx = np.where(np.array(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;],dtype=&#39;int&#39;) == 25)[0][0] # DR_Addr = 25 is amp_clk1
            ampclk = ampclk + 2 * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][idx,:]
            tmp1 = ampclk == 1
            tmp2 = ampclk == 3
            integrateSample = tmp1 | tmp2
            integrateSample = np.roll(integrateSample, MUX_TRANSITION_DELAY)
            amp_testsel_name = np.array([&#39;ATP&#39;,&#39;ATN&#39;,&#39;DACAMPTEST0&#39;,&#39;DACAMPTEST1&#39;,&#39;DACCMREF&#39;])
            amp_testsel_mux = np.array([[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1]])
            inputList = transformation[0].split(&#39;_&#39;)

            amp_testselp_reset_val = amp_testsel_mux[(np.where(inputList[1].upper() == amp_testsel_name))[0][0],:]
            amp_testseln_reset_val = amp_testsel_mux[(np.where(inputList[2].upper() == amp_testsel_name))[0][0],:]
            amp_testselp_int_val = amp_testsel_mux[(np.where(inputList[3].upper() == amp_testsel_name))[0][0],:]
            amp_testseln_int_val = amp_testsel_mux[(np.where(inputList[4].upper() == amp_testsel_name))[0][0],:]

            amp_testselp_idx = np.zeros(3, dtype=int)
            amp_testseln_idx = np.zeros(3, dtype=int)
            amp_testselp_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 37))[0][0]) # DR_Addr = 37 is amp_testselp[0] (ADSD3100)
            amp_testselp_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 42))[0][0]) # DR_Addr = 42 is amp_testselp[1] (ADSD3100)
            amp_testselp_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 43))[0][0]) # DR_Addr = 43 is amp_testselp[2] (ADSD3100)
            amp_testseln_idx[0] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 44))[0][0]) # DR_Addr = 44 is amp_testseln[0] (ADSD3100)
            amp_testseln_idx[1] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 45))[0][0]) # DR_Addr = 45 is amp_testselp[1] (ADSD3100)
            amp_testseln_idx[2] = int((np.where(DE_Struct[&#39;clks&#39;][&#39;DE_Addr&#39;] == 46))[0][0]) # DR_Addr = 46 is amp_testselp[2] (ADSD3100)

            for k in range(3):
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k],:] = 0 # default all amp_testsel signals low
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k],:] = 0

                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], np.invert(integrateSample)] = amp_testselp_reset_val[k] # amp_testselp reset
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], np.invert(integrateSample)] = amp_testseln_reset_val[k] # amp_testseln reset

                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testselp_idx[k], integrateSample] = amp_testselp_int_val[k] # amp_testselp integer
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][amp_testseln_idx[k], integrateSample] = amp_testseln_int_val[k] # amp_testseln integer

        else:
            if transformation[signalCnt].startswith(&#39;copyTo&#39;):
                destMode = transformation[signalCnt][6:]
                destModeIdx = np.where(DE_Struct[&#39;mode&#39;][&#39;name&#39;] == destMode.lower())[0][0] #+ 1

                sourceLength = list(np.shape(clkData))[0]
                destLength = list(np.shape(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]))[1]
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:]

                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = list(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])


                if sourceLength &gt; destLength:
                    for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                        append_bits = np.ones(sourceLength-destLength) * DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][-1]
                        DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = np.append(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i], append_bits)
                elif sourceLength &lt; destLength:
                    for i in range(len(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])):
                        DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][i][0:sourceLength]

                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx]  = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx])
                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx] = np.array(DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx])

                DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][destModeIdx][(signalIdx).astype(int),:] = DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][(signalIdx).astype(int),:]

            else:
                print(&#39;Unknown tranformation&#39;)
                logging.error(&#39;Unknown transformation&#39; + str(transformation[signalCnt]))

        if transformation[signalCnt] != &#39;stretchshrink&#39;:
            DE_Struct[&#39;mode&#39;][&#39;clksValue&#39;][modeIdx][int(signalIdx[signalCnt])] = clkData

    return DE_Struct</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GenerateDumpEngineConfig"><code class="name flex">
<span>def <span class="ident">GenerateDumpEngineConfig</span></span>(<span>self, handles, ramStart)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates DE config register address value pairs</p>
<h2 id="inputs">Inputs</h2>
<p>handles
ramStart: RAM start address </p>
<h2 id="outputs">Outputs</h2>
<p>regAddValPairs: register address value pairs
ramBlob: sorted clksValue in DE RAM format
memoryUsedPercent: RAM memory percent used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateDumpEngineConfig(self, handles, ramStart):
    &#34;&#34;&#34;
    Generates DE config register address value pairs
    Inputs:
        handles 
        ramStart: RAM start address 

    Outputs:
        regAddValPairs: register address value pairs 
        ramBlob: sorted clksValue in DE RAM format 
        memoryUsedPercent: RAM memory percent used 
    &#34;&#34;&#34; 
    ramOffset = ramStart
    ramBlob = []
    regAddValPairs = []
    signalOrderIdx = np.argsort(handles[&#39;clks&#39;][&#39;DE_Addr&#39;])

    for i in range(len(handles[&#39;mode&#39;][&#39;name&#39;])): # Error prone ,not !
        # outputData = self.API.legacy_ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
        outputData = self.ConvertWavesToDumpEngineRamFormat((np.array(handles[&#39;mode&#39;][&#39;clksValue&#39;][i])[signalOrderIdx.astype(&#39;int&#39;),:]).astype(&#39;double&#39;))
        regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrStart&#39;][i], ramOffset))
        regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrEnd&#39;][i], ramOffset + len(outputData)/4 -1))
        ramOffset = ramOffset + len(outputData)/4
        regAddValPairs = np.append(regAddValPairs, np.append(handles[&#39;mode&#39;][&#39;regAddrRepeat&#39;][i], handles[&#39;mode&#39;][&#39;repeatCount&#39;][i]))
        ramBlob = np.append(ramBlob, outputData)

    memoryUsedPercent = (ramOffset/(1024-6))*100

    if memoryUsedPercent &gt; 100:
        raise Exception(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
        logging.error(&#39;Error using &gt;100 percent of dump engine RAM&#39;)
    
    return regAddValPairs, ramBlob, memoryUsedPercent</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetFramesADCCalib"><code class="name flex">
<span>def <span class="ident">GetFramesADCCalib</span></span>(<span>self, nFrames=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Captures frames for ADC calibration</p>
<h2 id="inputs">Inputs</h2>
<p>nFrames: number of frames to capture </p>
<h2 id="outputs">Outputs</h2>
<p>success: status of capture
frames: frames in a 3D array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetFramesADCCalib(self, nFrames=1):
    &#34;&#34;&#34;
    Captures frames for ADC calibration
    Inputs:
        nFrames: number of frames to capture 

    Outputs:
        success: status of capture 
        frames: frames in a 3D array 

    &#34;&#34;&#34;
    self.QuickStartSensor()

    time.sleep(0.5)

    frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
    for frm in range(nFrames):
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        RawImage = tmp[0]

        if self.dev.validFrame !=1:
            raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
            return -1
        else:
            subImage = RawImage[0 : self.width*self.height]
            image16 = np.resize(subImage, (self.height, self.width))
            frames[:,:,frm] = image16.copy()
            success = True

    print(&#39;Frame captured - ADC Calib&#39;)
    logging.info(&#39;Frame captured - ADC Calib&#39;)
    # self.QuickStopSensor()
    #self.dev.stopSensor()
    self.QuickStopSensor()
    

    return success, frames</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetFramesCompDACalib"><code class="name flex">
<span>def <span class="ident">GetFramesCompDACalib</span></span>(<span>self, nFrames=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Captures frames for comparator DAC calibratiom</p>
<h2 id="inputs">Inputs</h2>
<p>nFrames: number of frames to capture </p>
<h2 id="outputs">Outputs</h2>
<p>GT: gain tag values
ADC: ADC values
Sat: Saturation status values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetFramesCompDACalib(self, nFrames=1):
    &#34;&#34;&#34;
    Captures frames for comparator DAC calibratiom
    Inputs:
        nFrames: number of frames to capture 

    Outputs:
        GT: gain tag values 
        ADC: ADC values 
        Sat: Saturation status values 

    &#34;&#34;&#34;
    # self.QuickStartSensor()
    self.Start()

    time.sleep(0.5)
    
    frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
    for frm in range(nFrames):
        #RawImage = self.dev.getFloatImage()
        tmp = tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        RawImage = tmp[0]
        subImage = RawImage[0 : self.width*self.height]
        image16 = np.resize(subImage, (self.height, self.width))
        frames[:,:,0,frm] = image16.copy()

        if self.dev.validFrame !=1:
            raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
            return -1
        else:
            success = True

    print(&#39;Frame captured - CompDAC Calib&#39;)
    logging.info(&#39;Frame captured - CompDAC Calib&#39;)

    self.Stop()
    
    imgRaw = frames[2:,:,:,:]
    GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
    ADC = imgRaw.astype(np.uint16) &amp; 1023
    SAT = ADC &lt; 3

    if np.any(SAT == True):
        print(&#39;Saturation detected in comparator calibration frame!&#39;)
        logging.warning(&#39;Saturation detected in comparator calibration frame!&#39;)

    print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
    logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
    print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
    logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
    print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
    logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


    return GT,ADC,SAT</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetFramesPCGO"><code class="name flex">
<span>def <span class="ident">GetFramesPCGO</span></span>(<span>self, nFrames=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Captures frames for per column gain and offset</p>
<h2 id="inputs">Inputs</h2>
<p>nFrames: number of frames to capture </p>
<h2 id="outputs">Outputs</h2>
<p>GT: gain tag values
ADC: ADC values
Sat: Saturation status values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetFramesPCGO(self, nFrames=1):
    &#34;&#34;&#34;
    Captures frames for per column gain and offset
    Inputs:
        nFrames: number of frames to capture 

    Outputs:
        GT: gain tag values 
        ADC: ADC values 
        Sat: Saturation status values 

    &#34;&#34;&#34;
    self.QuickStartSensor()

    time.sleep(0.5)
    
    frames = np.zeros([self.height, self.width, 1, nFrames],dtype=np.int16)
    for frm in range(nFrames):
        #RawImage = self.dev.getFloatImage()
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        RawImage = tmp[0]

        if self.dev.validFrame !=1:
            raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
            return -1
        else:
            subImage = RawImage[0 : self.width*self.height]
            image16 = np.resize(subImage, (self.height, self.width))
            frames[:,:,0,frm] = image16.copy()
            success = True

    print(&#39;Frame captured - perColumn Calib&#39;)
    logging.info(&#39;Frame captured - perColumn Calib&#39;)
    # self.QuickStopSensor()
    #self.dev.stopSensor()
    self.QuickStopSensor()
    # time.sleep(0.1)
    
    imgRaw = frames[20:,:,:,:]
    GT = ((imgRaw.astype(np.uint16) &amp; 3072) &gt;&gt; 10).astype(np.uint8)
    ADC = imgRaw.astype(np.uint16) &amp; 1023
    SAT = ADC &lt; 3

    if np.any(SAT == True):
        print(&#39;Saturation detected in Per Col GO calibration frame!&#39;)

    print(np.nanmean(ADC[:,:,0,0]),&#39;ADC mean&#39;)
    logging.info(str(np.nanmean(ADC[:,:,0,0])) + &#39; ADC mean&#39;)
    print(np.nanmin(ADC[:,:,0,0]),&#39;ADC min&#39;)
    logging.info(str(np.nanmin(ADC[:,:,0,0])) + &#39; ADC min&#39;)
    print(np.nanmax(ADC[:,:,0,0]),&#39;ADC max&#39;)
    logging.info(str(np.nanmax(ADC[:,:,0,0])) + &#39; ADC max&#39;)


    return GT,ADC,SAT</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetFramesPixVoltage"><code class="name flex">
<span>def <span class="ident">GetFramesPixVoltage</span></span>(<span>self, nFrames=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Captures frames for pixel voltage test</p>
<h2 id="inputs">Inputs</h2>
<p>nFrames: number of frames to capture </p>
<h2 id="outputs">Outputs</h2>
<p>success: status of capture<br>
frames: frames in a 3D array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetFramesPixVoltage(self, nFrames=1):
    &#34;&#34;&#34;
    Captures frames for pixel voltage test
    Inputs:
        nFrames: number of frames to capture 

    Outputs:
        success: status of capture  
        frames: frames in a 3D array  

    &#34;&#34;&#34;
    self.QuickStartSensor()

    time.sleep(0.5)

    frames = np.zeros([self.height, self.width, nFrames],dtype=np.int16)
    for frm in range(nFrames):
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        RawImage = tmp[0]

        if self.dev.validFrame !=1:
            raise Exception(&#39;Error capturing frames! - invalid frame&#39;)
            return -1
        else:
            subImage = RawImage[0 : self.width*self.height]
            image16 =  self.dev.ConvertFloat2LinearVal(subImage)
            image16 = np.resize(image16, (self.height, self.width))
            frames[:,:,frm] = image16.copy()
            success = True

    print(&#39;Frame captured - ADC Calib&#39;)
    logging.info(&#39;Frame captured - ADC Calib&#39;)
    # self.QuickStopSensor()
    #self.dev.stopSensor()
    self.QuickStopSensor()
    
    return success, frames</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetIndirectRegister"><code class="name flex">
<span>def <span class="ident">GetIndirectRegister</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Read indirect registers</p>
<h2 id="inputs">Inputs</h2>
<p>name: register name </p>
<h2 id="outputs">Outputs</h2>
<p>status
value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetIndirectRegister(self, name):
    &#34;&#34;&#34;
    Read indirect registers
    Inputs:
        name: register name 

    Outputs:
        status
        value

    &#34;&#34;&#34;
    if name == &#39;N_OVRD_ANAMODE&#39;:
        addr = 0x1fc1
        s = self.regwrite(0x0004, addr)
        return s, self.regread(0x0006)

    elif name == &#39;WAVE_FUNCTION_0&#39;:
        addr = 0x1fc5
        s = self.regwrite(0x0004, addr)
        return s, self.regread(0x0006)

    elif name == &#39;WAVE_FUNCTION_1&#39;:
        addr = 0x1fc9
        s = self.regwrite(0x0004, addr)
        return s, self.regread(0x0006)

    elif name == &#39;WAVE_FUNCTION_2&#39;:
        addr = 0x1fcd
        s = self.regwrite(0x0004, addr)
        return s, self.regread(0x0006)

    elif name == &#39;LASER_CONTROL&#39;:
        addr = 0x1fd1
        s = self.regwrite(0x0004, addr)
        return s, self.regread(0x0006)

    elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
        addr = 0x1fb1
        s = self.regwrite(0x0004, addr)
        val = self.regread(0x0006)
        if name == &#39;B_USE_LASER&#39;:
            return val &amp; 0xFF
        else:
            return val &gt;&gt; 8

    elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
        addr = 0x1fb5
        s = self.regwrite(0x0004, addr)
        val = self.regread(0x0006)
        if name == &#39;B_OVRD_ANAMODE&#39;:
            return s, val &amp; 0xFF
        else:
            return s, val &gt;&gt; 8

    elif name == &#39;B_LVDS_PD&#39;:
        addr = 0x1fb9
        s = self.regwrite(0x0004, addr)
        return self.regread(0x0006)

    elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
        addr = 0x1fbd
        s = self.regwrite(0x0004, addr)
        val = self.regread(0x0006)
        if name == &#39;B_EN_PHASESWEEP&#39;:
            return s, val &amp; 0xFF
        else:
            return s, val &gt;&gt; 8

    else:
        raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))
        return  0, -1</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.GetLDTemp"><code class="name flex">
<span>def <span class="ident">GetLDTemp</span></span>(<span>self, skipPtrSet, driver)</span>
</code></dt>
<dd>
<div class="desc"><p>Function read LD temperature</p>
<h2 id="inputs">Inputs</h2>
<p>skipPtrSet: skip pointer set
driver: driver name </p>
<p>Outputs:
TempOut: Temperature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetLDTemp( self, skipPtrSet, driver):
    &#34;&#34;&#34;
    Function read LD temperature
    Inputs:
        skipPtrSet: skip pointer set 
        driver: driver name 

    Outputs: 
        TempOut: Temperature  
        
    &#34;&#34;&#34; 
    TempOut = 999
    # return TempOut
    if driver == ARCHER:
        if skipPtrSet == False:
            self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x07]) # TempSense No Burst
            #self.dev.writeI2C(I2C_MODULE, ADSD3000_ID, [0x1, 0x01]) # TempSense during bursts
        rd_reg = self.dev.readI2C(I2C_MODULE, ADSD3000_ID, 2)
        print(&#39;DigTemp:&#39;,str(rd_reg[0]*0x100+rd_reg[1]))
        TempOut = (rd_reg[0]*0x100+rd_reg[1])*0.389214 - 1134.766
    if driver == INTERSIL:
        if skipPtrSet == False:
            self.dev.writeI2C(I2C_MODULE, TEMP_SENSE_ID, [TEMP_REG, 0, 0])
        #TempDig = [0,0]
        TempDig = self.dev.readI2C(I2C_MODULE, TEMP_SENSE_ID, 2)
        TempOut = (TempDig[0]*0x100 + TempDig[1])&gt;&gt;4
        if TempOut &gt; 0x7FF:
            TempOut = ((TempOut ^ 0xFFF) + 1)*-0.0625
        else:
            TempOut = TempOut*0.0625
    return TempOut</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ICQSensorPowerUp"><code class="name flex">
<span>def <span class="ident">ICQSensorPowerUp</span></span>(<span>self, tests_failed, limits=None, ICQ_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements ICQ + sensor initialization sequence enabling the power regulators
and making functional checks.</p>
<h2 id="inputs">Inputs</h2>
<p>tests_failed: number of tests failed before the startup
limits: minimum and maximum thresholds
ICQ_dist: results of the tests done prior </p>
<h2 id="outputs">Outputs</h2>
<p>0
ICQ_dict: result of the powerup
tests_failed: number of tests failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ICQSensorPowerUp(self, tests_failed, limits = None, ICQ_dict=None):
    &#34;&#34;&#34;
    Implements ICQ + sensor initialization sequence enabling the power regulators 
        and making functional checks.
    Inputs:
        tests_failed: number of tests failed before the startup 
        limits: minimum and maximum thresholds 
        ICQ_dist: results of the tests done prior 

    Outputs:
        0
        ICQ_dict: result of the powerup 
        tests_failed: number of tests failed 

    &#34;&#34;&#34;
    global Vmain_pre_test
    global Vmain_static_test
    global Vmain_on_test
    global Vsys_pre_test
    global Vsys_static_test
    global Vsys_on_test
    global Vdepth_pre_test
    global Vdepth_static_test
    global Vdepth_on_test
    global Vaux_pre_test
    global Vaux_static_test
    global Vaux_on_test
    global Imain_pre_test
    global Imain_static_test
    global Imain_on_test
    global Isys_pre_test
    global Isys_static_test
    global Isys_on_test
    global Idepth_pre_test
    global Idepth_static_test
    global Idepth_on_test
    global Iaux_pre_test
    global Iaux_static_test
    global Iaux_on_test

    Vmain_pre_min = limits[&#39;Vmain_pre&#39;][0] #Vmain can&#39;t be disabled currently
    Vmain_pre_max = limits[&#39;Vmain_pre&#39;][1]
    Imain_pre_min = limits[&#39;Imain_pre&#39;][0]
    Imain_pre_max = limits[&#39;Imain_pre&#39;][1]
    Vsys_pre_min = limits[&#39;Vsys_pre&#39;][0]
    Vsys_pre_max = limits[&#39;Vsys_pre&#39;][1]
    Isys_pre_min = limits[&#39;Isys_pre&#39;][0]
    Isys_pre_max = limits[&#39;Isys_pre&#39;][1]
    Vdepth_pre_min = limits[&#39;Vdepth_pre&#39;][0]
    Vdepth_pre_max = limits[&#39;Vdepth_pre&#39;][1]
    Idepth_pre_min = limits[&#39;Idepth_pre&#39;][0]
    Idepth_pre_max = limits[&#39;Idepth_pre&#39;][1]
    Vaux_pre_min = limits[&#39;Vaux_pre&#39;][0]
    Vaux_pre_max = limits[&#39;Vaux_pre&#39;][1]
    Iaux_pre_min = limits[&#39;Iaux_pre&#39;][0]
    Iaux_pre_max = limits[&#39;Iaux_pre&#39;][1]

    Vmain_static_min = limits[&#39;Vmain_static&#39;][0]
    Vmain_static_max = limits[&#39;Vmain_static&#39;][1]
    Imain_static_min = limits[&#39;Imain_static&#39;][0]
    Imain_static_max = limits[&#39;Imain_static&#39;][1]
    Vsys_static_min = limits[&#39;Vsys_static&#39;][0]
    Vsys_static_max = limits[&#39;Vsys_static&#39;][1]
    Isys_static_min = limits[&#39;Isys_static&#39;][0]
    Isys_static_max = limits[&#39;Isys_static&#39;][1]
    Vdepth_static_min = limits[&#39;Vdepth_static&#39;][0]
    Vdepth_static_max = limits[&#39;Vdepth_static&#39;][1]
    Idepth_static_min = limits[&#39;Idepth_static&#39;][0]
    Idepth_static_max = limits[&#39;Idepth_static&#39;][1]
    Vaux_static_min = limits[&#39;Vaux_static&#39;][0]
    Vaux_static_max = limits[&#39;Vaux_static&#39;][1]
    Iaux_static_min = limits[&#39;Iaux_static&#39;][0]
    Iaux_static_max = limits[&#39;Iaux_static&#39;][1]

    self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  

    self.dev.setGpio( CAM_RESET_N, 0) # reset camera
    self.dev.setGpio( LMZ_EN, 0) # disable Vmain
    time.sleep(0.004) # wait 4 ms
    [ Vmain_pre, Imain_pre, Pmain_pre] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain before enabled
    Imain_pre = Imain_pre * 1000 #Convert to mA

    Vmain_pre_pass, fail = ICQtest(Vmain_pre, Vmain_pre_min, Vmain_pre_max)
    tests_failed = tests_failed + fail
    Imain_pre_pass, fail = ICQtest(Imain_pre, Imain_pre_min, Imain_pre_max)
    tests_failed = tests_failed + fail

    print(&#34; Vmain_pre = &#34; + str(Vmain_pre), Vmain_pre_pass)
    print(&#34; Imain_pre = &#34; + str(Imain_pre), Imain_pre_pass)

    self.dev.setGpio( CAM_RESET_N, 0) # reset camera
    self.dev.setGpio( LMZ_EN, 1) # enable Vmain
    time.sleep(0.01) # wait 10 ms
    [ Vmain_static, Imain_static, Pmain_static] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
    Imain_static = Imain_static * 1000 #Convert to mA

    Vmain_static_pass, fail = ICQtest(Vmain_static, Vmain_static_min, Vmain_static_max)
    tests_failed = tests_failed + fail
    Imain_static_pass, fail = ICQtest(Imain_static, Imain_static_min, Imain_static_max)
    tests_failed = tests_failed + fail

    print(&#34; Vmain_static = &#34; + str(Vmain_static), Vmain_static_pass)
    print(&#34; Imain_static = &#34; + str(Imain_static), Imain_static_pass)
    #print(&#34; Pmain_static = &#34; + str(Pmain_static))

    time.sleep(0.1) # wait 100 ms
    [ Vdepth_pre, Idepth_pre, Pdepth_pre] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth before enabled
    Idepth_pre = Idepth_pre * 1000 #Convert to mA

    Vdepth_pre_pass, fail = ICQtest(Vdepth_pre, Vdepth_pre_min, Vdepth_pre_max)
    tests_failed = tests_failed + fail
    Idepth_pre_pass, fail = ICQtest(Idepth_pre, Idepth_pre_min, Idepth_pre_max)
    tests_failed = tests_failed + fail

    print(&#34; Vdepth_pre = &#34; + str(Vdepth_pre), Vdepth_pre_pass)
    print(&#34; Idepth_pre = &#34; + str(Idepth_pre), Idepth_pre_pass)

    self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
    [ Vdepth_static, Idepth_static, Pdepth_static] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
    Idepth_static = Idepth_static * 1000 #Convert to mA

    Vdepth_static_pass, fail = ICQtest(Vdepth_static, Vdepth_static_min, Vdepth_static_max)
    tests_failed = tests_failed + fail
    Idepth_static_pass, fail = ICQtest(Idepth_static, Idepth_static_min, Idepth_static_max)
    tests_failed = tests_failed + fail

    print(&#34; Vdepth_static = &#34; + str(Vdepth_static), Vdepth_static_pass)
    print(&#34; Idepth_static = &#34; + str(Idepth_static), Idepth_static_pass)
    #print(&#34; Pdepth_static = &#34; + str(Pdepth_static))

    self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth

    time.sleep(0.1) # wait 100 ms
    [ Vsys_pre, Isys_pre, Psys_pre] = self.PowerMonitor( VSYS_DEV_ID)
    Isys_pre = Isys_pre * 1000 #Convert to mA

    Vsys_pre_pass, fail = ICQtest(Vsys_pre, Vsys_pre_min, Vsys_pre_max)
    tests_failed = tests_failed + fail
    Isys_pre_pass, fail = ICQtest(Isys_pre, Isys_pre_min, Isys_pre_max)
    tests_failed = tests_failed + fail

    print(&#34; Vsys_pre = &#34; + str(Vsys_pre), Vsys_pre_pass)
    print(&#34; Isys_pre = &#34; + str(Isys_pre), Isys_pre_pass)

    self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
    self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
    time.sleep( 0.004) # wait 4 ms
    [ Vsys_static, Isys_static, Psys_static] = self.PowerMonitor( VSYS_DEV_ID)
    Isys_static = Isys_static * 1000 #Convert to mA

    Vsys_static_pass, fail = ICQtest(Vsys_static, Vsys_static_min, Vsys_static_max)
    tests_failed = tests_failed + fail
    Isys_static_pass, fail = ICQtest(Isys_static, Isys_static_min, Isys_static_max)
    tests_failed = tests_failed + fail

    print(&#34; Vsys_static = &#34; + str(Vsys_static), Vsys_static_pass)
    print(&#34; Isys_static = &#34; + str(Isys_static), Isys_static_pass)
    #print(&#34; Psys_static = &#34; + str(Psys_static))
    time.sleep(0.01) # wait 10 ms

    self.dev.setGpio( DEPTH_VAUX_RUN, 0)
    self.dev.setGpio( PS_VAUXVPS1, 0)
    time.sleep(0.1) # wait 100 ms
    [ Vaux_pre, Iaux_pre, Paux_pre] = self.PowerMonitor( VAUX_DEV_ID)
    Iaux_pre = Iaux_pre * 1000 #Convert to mA

    Vaux_pre_pass, fail = ICQtest(Vaux_pre, Vaux_pre_min, Vaux_pre_max)
    tests_failed = tests_failed + fail
    Iaux_pre_pass, fail = ICQtest(Iaux_pre, Iaux_pre_min, Iaux_pre_max)
    tests_failed = tests_failed + fail
    
    print(&#34; Vaux_pre = &#34; + str( Vaux_pre), Vaux_pre_pass)
    print(&#34; Iaux_pre = &#34; + str( Iaux_pre), Iaux_pre_pass)

    self.dev.setGpio( PS_VAUXVPS1, 1)
    self.dev.setGpio( DEPTH_VAUX_RUN, 1)
    time.sleep(0.0001) # wait 100 us
    [ Vaux_static, Iaux_static, Paux_static] = self.PowerMonitor( VAUX_DEV_ID)
    Iaux_static = Iaux_static * 1000 #Convert to mA

    Vaux_static_pass, fail = ICQtest(Vaux_static, Vaux_static_min, Vaux_static_max)
    tests_failed = tests_failed + fail
    Iaux_static_pass, fail = ICQtest(Iaux_static, Iaux_static_min, Iaux_static_max)  
    tests_failed = tests_failed + fail

    print(&#34; Vaux_static = &#34; + str( Vaux_static), Vaux_static_pass)
    print(&#34; Iaux_static = &#34; + str( Iaux_static), Iaux_static_pass)
    #print(&#34; Paux = &#34; + str( Paux))      

    Vmain_pre_test = [&#39;Vmain_pre_V&#39;, Vmain_pre, str(Vmain_pre_pass), Vmain_pre_min, Vmain_pre_max]
    ICQ_dict[&#39;Vmain_pre_V&#39;] = Vmain_pre_test[1:]
    Imain_pre_test = [&#39;Imain_pre_mA&#39;, Imain_pre, str(Imain_pre_pass), Imain_pre_min, Imain_pre_max]
    ICQ_dict[&#39;Imain_pre_mA&#39;] = Imain_pre_test[1:]
    Vsys_pre_test = [&#39;Vsys_pre_V&#39;, Vsys_pre, str(Vsys_pre_pass), Vsys_pre_min, Vsys_pre_max]
    ICQ_dict[&#39;Vsys_pre_V&#39;] = Vsys_pre_test[1:]
    Isys_pre_test = [&#39;Isys_pre_mA&#39;, Isys_pre, str(Isys_pre_pass), Isys_pre_min, Isys_pre_max]
    ICQ_dict[&#39;Isys_pre_mA&#39;] = Isys_pre_test[1:]
    Vdepth_pre_test = [&#39;Vdepth_pre_V&#39;, Vdepth_pre, str(Vdepth_pre_pass), Vdepth_pre_min, Vdepth_pre_max]
    ICQ_dict[&#39;Vdepth_pre_V&#39;] = Vdepth_pre_test[1:]
    Idepth_pre_test = [&#39;Idepth_pre_mA&#39;, Idepth_pre, str(Idepth_pre_pass), Idepth_pre_min, Idepth_pre_max]
    ICQ_dict[&#39;Idepth_pre_mA&#39;] = Idepth_pre_test[1:]
    Vaux_pre_test = [&#39;Vaux_pre_V&#39;, Vaux_pre, str(Vaux_pre_pass), Vaux_pre_min, Vaux_pre_max]
    ICQ_dict[&#39;Vaux_pre_V&#39;] = Vaux_pre_test[1:]
    Iaux_pre_test = [&#39;Iaux_pre_mA&#39;, Iaux_pre, str(Iaux_pre_pass), Iaux_pre_min, Iaux_pre_max]
    ICQ_dict[&#39;Iaux_pre_mA&#39;] = Iaux_pre_test[1:]
    
    Vmain_static_test = [&#39;Vmain_static_V&#39;, Vmain_static, str(Vmain_static_pass), Vmain_static_min, Vmain_static_max]
    ICQ_dict[&#39;Vmain_static_V&#39;] = Vmain_static_test[1:]
    Imain_static_test = [&#39;Imain_static_mA&#39;, Imain_static, str(Imain_static_pass), Imain_static_min, Imain_static_max]
    ICQ_dict[&#39;Imain_static_mA&#39;] = Imain_static_test[1:]
    Vsys_static_test = [&#39;Vsys_static_V&#39;, Vsys_static, str(Vsys_static_pass), Vsys_static_min, Vsys_static_max]
    ICQ_dict[&#39;Vsys_static_V&#39;] = Vsys_static_test[1:]
    Isys_static_test = [&#39;Isys_static_mA&#39;, Isys_static, str(Isys_static_pass), Isys_static_min, Isys_static_max]
    ICQ_dict[&#39;Isys_static_mA&#39;] = Isys_static_test[1:]
    Vdepth_static_test = [&#39;Vdepth_static_V&#39;, Vdepth_static, str(Vdepth_static_pass), Vdepth_static_min, Vdepth_static_max]
    ICQ_dict[&#39;Vdepth_static_V&#39;] = Vdepth_static_test[1:]
    Idepth_static_test = [&#39;Idepth_static_mA&#39;, Idepth_static, str(Idepth_static_pass), Idepth_static_min, Idepth_static_max]
    ICQ_dict[&#39;Idepth_static_mA&#39;] = Idepth_static_test[1:]
    Vaux_static_test = [&#39;Vaux_static_V&#39;, Vaux_static, str(Vaux_static_pass), Vaux_static_min, Vaux_static_max]
    ICQ_dict[&#39;Vaux_static_V&#39;] = Vaux_static_test[1:]
    Iaux_static_test = [&#39;Iaux_static_mA&#39;, Iaux_static, str(Iaux_static_pass), Iaux_static_min, Iaux_static_max]
    ICQ_dict[&#39;Iaux_static_mA&#39;] = Iaux_static_test[1:]

    if(tests_failed == 0):
        print(&#34;Static Malka Supplies PASSED&#34;)
        ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 1 
    else:
        print(&#34;Static Malka Supplies FAILED&#34;)
        ICQ_dict[&#39;info&#39;][&#39;Malka_pass&#39;] = 0 

    # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
    retries = 10
    while( retries &gt; 0):
        if (self.module_class == &#39;Walden_R1&#39;):
            cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
        else:
            cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
        if( cam_shutdown == 1):
            break
        else:
            retries = retries - 1

    # if( retries == 0):
    #     print( &#34;Error during camera initialization&#34;)
    #     self.dev.setGpio( DEPTH_VAUX_RUN, 0)
    #     self.dev.setGpio( PS_VAUXVPS2, 0)
    #     self.dev.setGpio( PS_VAUXVPS1, 0)
    #     self.dev.setGpio( PS_V5VVPS3, 0)
    #     self.dev.setGpio( LMZ_EN, 0)
    #     return -1

    # wait 2 ms
    time.sleep( 0.002)
    self.dev.setGpio( CAM_RESET_N, 1)       

    return [0, ICQ_dict, tests_failed]</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ICQSensorStart"><code class="name flex">
<span>def <span class="ident">ICQSensorStart</span></span>(<span>self, Mode=3, fps=10, cfg='', file_name='', limits=None, ICQ_dict=None, ICQ_mode='no_laser')</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the sensor, performs ICQ and saves it to csv file</p>
<h2 id="inputs">Inputs</h2>
<p>mode: camera mode
fps: frequency per second
cfg: name of cfg file
file_name: name of csv file to store the results
limits: minimum and maximum thresholds
ICQ_dict: dictionary containing the results of prior tests
ICQ_mode: whether to enable laser or not </p>
<h2 id="outputs">Outputs</h2>
<p>0
ICQ_dict: result in a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ICQSensorStart(self, Mode=3, fps=10, cfg = &#34;&#34;, file_name = &#34;&#34;, 
                    limits = None, ICQ_dict=None, ICQ_mode = &#39;no_laser&#39;):
    &#34;&#34;&#34;
    Starts the sensor, performs ICQ and saves it to csv file
    Inputs:
        mode: camera mode 
        fps: frequency per second 
        cfg: name of cfg file 
        file_name: name of csv file to store the results 
        limits: minimum and maximum thresholds 
        ICQ_dict: dictionary containing the results of prior tests 
        ICQ_mode: whether to enable laser or not 

    Outputs:
        0 
        ICQ_dict: result in a dictionary 

    &#34;&#34;&#34;

    tests_failed = 0
    global Vmain_on_test
    global Vsys_on_test
    global Vdepth_on_test
    global Vaux_on_test
    global Imain_on_test
    global Isys_on_test
    global Idepth_on_test
    global Iaux_on_test

    ret = self.dev.openDevice( Mode, -1)
    if( ret &lt; 0):
        print(&#34;Error opening the camera&#34;)
        return -2
    #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x98, 0xBB]) # MZ1: Added VAUX DAC set for 25V
    # self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xCE]) # DAC set for 27V
    #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x4B]) # DAC set for 28V
    #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0x09]) # DAC set for 28.5V
    #self.dev.writeI2C(AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0x13]) # DAC set for ~13.8V

    [ret, ICQ_dict, tests_failed] = self.ICQSensorPowerUp(tests_failed, limits = limits, ICQ_dict=ICQ_dict)
    if( ret &lt; 0):
        print(&#34;Error during sensor power up. Please restart your system.&#34;)
        sys.exit()
    self.Mode = Mode
    self._setInternalClassMode()

    self.fps = fps
    self.dev.setCameraFrameRate(fps)

    self.dev.programCfg(cfg)
    #self.programCSV(&#34;process_data_Legacy.csv&#34;)

    
    if( Mode != 3):
        #self.changeMode( self.Mode)
        self.dev.writeSPISingle( 0x0200, self.Mode)
    
    self.dev.startSensor()
    print(&#34; Camera running... &#34;)

    # Send start command to camera
    self.dev.writeSPISingle( 0x000C, 0x00C5)

    Vmain_on_min = limits[&#39;Vmain_on&#39;][0]
    Vmain_on_max = limits[&#39;Vmain_on&#39;][1]
    Imain_on_min = limits[&#39;Imain_on&#39;][0]
    Imain_on_max = limits[&#39;Imain_on&#39;][1]
    Vsys_on_min = limits[&#39;Vsys_on&#39;][0]
    Vsys_on_max = limits[&#39;Vsys_on&#39;][1]
    Isys_on_min = limits[&#39;Isys_on&#39;][0]
    Isys_on_max = limits[&#39;Isys_on&#39;][1]
    Vdepth_on_min = limits[&#39;Vdepth_on&#39;][0]
    Vdepth_on_max = limits[&#39;Vdepth_on&#39;][1]
    Idepth_on_min = limits[&#39;Idepth_on&#39;][0]
    Idepth_on_max = limits[&#39;Idepth_on&#39;][1]
    Vaux_on_min = limits[&#39;Vaux_on&#39;][0]
    Vaux_on_max = limits[&#39;Vaux_on&#39;][1]
    Iaux_on_min = limits[&#39;Iaux_on&#39;][0]
    Iaux_on_max = limits[&#39;Iaux_on&#39;][1]

    #Measure supply rails after enabling camera
    [ Vmain_on, Imain_on, Pmain_on] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
    Imain_on = Imain_on * 1000 #Convert to mA
    
    Vmain_on_pass, fail = ICQtest(Vmain_on, Vmain_on_min, Vmain_on_max)
    tests_failed = tests_failed + fail
    Imain_on_pass, fail = ICQtest(Imain_on, Imain_on_min, Imain_on_max)
    tests_failed = tests_failed + fail

    print(&#34; Vmain-on = &#34; + str(Vmain_on), Vmain_on_pass)
    print(&#34; Imain-on = &#34; + str(Imain_on), Imain_on_pass)
    #print(&#34; Pmain_on = &#34; + str(Pmain_on))

    [ Vdepth_on, Idepth_on, Pdepth_on] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vdepth
    Idepth_on = Idepth_on * 1000 #Convert to mA

    Vdepth_on_pass, fail = ICQtest(Vdepth_on, Vdepth_on_min, Vdepth_on_max)
    tests_failed = tests_failed + fail
    Idepth_on_pass, fail = ICQtest(Idepth_on, Idepth_on_min, Idepth_on_max)
    tests_failed = tests_failed + fail

    print(&#34; Vdepth-on = &#34; + str(Vdepth_on), Vdepth_on_pass)
    print(&#34; Idepth-on = &#34; + str(Idepth_on), Idepth_on_pass)
    #print(&#34; Pdepth_on = &#34; + str(Pdepth_on))

    [ Vsys_on, Isys_on, Psys_on] = self.PowerMonitor( VSYS_DEV_ID)
    Isys_on = Isys_on * 1000 #Convert to mA

    Vsys_on_pass, fail = ICQtest(Vsys_on, Vsys_on_min, Vsys_on_max)
    tests_failed = tests_failed + fail
    Isys_on_pass, fail = ICQtest(Isys_on, Isys_on_min, Isys_on_max)
    tests_failed = tests_failed + fail

    print(&#34; Vsys-on = &#34; + str(Vsys_on), Vsys_on_pass)
    print(&#34; Isys-on = &#34; + str(Isys_on), Isys_on_pass)
    #print(&#34; Psys_on = &#34; + str(Psys_on))
    time.sleep( 0.004) # wait 4 ms

    [ Vaux_on, Iaux_on, Paux_on] = self.PowerMonitor( VAUX_DEV_ID)
    Iaux_on = Iaux_on * 1000 #Convert to mA

    Vaux_on_pass, fail = ICQtest(Vaux_on, Vaux_on_min, Vaux_on_max)
    tests_failed = tests_failed + fail
    Iaux_on_pass, fail = ICQtest(Iaux_on, Iaux_on_min, Iaux_on_max)
    tests_failed = tests_failed + fail

    print(&#34; Vaux-on = &#34; + str( Vaux_on), Vaux_on_pass)
    print(&#34; Iaux-on = &#34; + str( Iaux_on), Iaux_on_pass)
    #print(&#34; Paux_on = &#34; + str( Paux_on))

    
    Vmain_on_test = [&#39;Vmain-on_V&#39;, Vmain_on, str(Vmain_on_pass), Vmain_on_min, Vmain_on_max]
    ICQ_dict[&#39;Vmain-on_V&#39;] = Vmain_on_test[1:]
    Imain_on_test = [&#39;Imain-on_mA&#39;, Imain_on, str(Imain_on_pass), Imain_on_min, Imain_on_max]
    ICQ_dict[&#39;Imain-on_mA&#39;] = Imain_on_test[1:]
    Vsys_on_test = [&#39;Vsys-on_V&#39;, Vsys_on, str(Vsys_on_pass), Vsys_on_min, Vsys_on_max]
    ICQ_dict[&#39;Vsys-on_V&#39;] = Vsys_on_test[1:]
    Isys_on_test = [&#39;Isys-on_mA&#39;, Isys_on, str(Isys_on_pass), Isys_on_min, Isys_on_max]
    ICQ_dict[&#39;Isys-on_mA&#39;] = Isys_on_test[1:]
    Vdepth_on_test = [&#39;Vdepth-on_V&#39;, Vdepth_on, str(Vdepth_on_pass), Vdepth_on_min, Vdepth_on_max]
    ICQ_dict[&#39;Vdepth-on_V&#39;] = Vdepth_on_test[1:]
    Idepth_on_test = [&#39;Idepth-on_mA&#39;, Idepth_on, str(Idepth_on_pass), Idepth_on_min, Idepth_on_max]
    ICQ_dict[&#39;Idepth-on_mA&#39;] = Idepth_on_test[1:]
    Vaux_on_test = [&#39;Vaux-on_V&#39;, Vaux_on, str(Vaux_on_pass), Vaux_on_min, Vaux_on_max]
    ICQ_dict[&#39;Vaux-on_V&#39;] = Vaux_on_test[1:]
    Iaux_on_test = [&#39;Iaux-on_mA&#39;, Iaux_on, str(Iaux_on_pass), Iaux_on_min, Iaux_on_max]
    ICQ_dict[&#39;Iaux-on_mA&#39;] = Iaux_on_test[1:]

    
    # check if useq works
    errorCode = 0
    for i in range(10):
        data = self.dev.readSPISingle( 0x0256,1 )
        data = data[0]
        print(&#34;data = &#34; + hex(data))

        ADC_LSB = 0.000125
        ADC_REF = 2.5 #Vref
        ADC_BITS = 2**12 #12 bit ADC

        VDDA1_min = limits[&#39;VDDA1&#39;][0]
        VDDA1_max = limits[&#39;VDDA1&#39;][1]
        VHIGH_min = limits[&#39;VHIGH&#39;][0]
        VHIGH_max = limits[&#39;VHIGH&#39;][1]
        VLOW_min = limits[&#39;VLOW&#39;][0]
        VLOW_max = limits[&#39;VLOW&#39;][1]
        VLD_min = limits[&#39;VLD&#39;][0]
        VLD_max = limits[&#39;VLD&#39;][1]

        time.sleep(0.1)
        self.dev.writeSPISingle( 0x0160, 0x0007) #Diff V1p2
        time.sleep(0.1)
        ADC_code = self.dev.getADCvalue(0)
        ADC_code = self.dev.getADCvalue(0)
        VDDA1 = ADC_code * ADC_LSB
        VDDA1_pass, fail = ICQtest(VDDA1, VDDA1_min, VDDA1_max)
        tests_failed = tests_failed + fail
        print(&#34; VDDA1 = &#34; + str(VDDA1), VDDA1_pass)

        self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vhigh
        time.sleep(0.1)
        ADC_code = self.dev.getADCvalue(4)
        VHIGH = ADC_code * ADC_LSB
        VHIGH_pass, fail = ICQtest(VHIGH, VHIGH_min, VHIGH_max)
        tests_failed = tests_failed + fail
        print(&#34; VHIGH = &#34; + str(VHIGH), VHIGH_pass)

        self.dev.writeSPISingle( 0x0160, 0x0008) #SE Vlow
        time.sleep(0.1)
        ADC_code = self.dev.getADCvalue(5)
        VLOW = ADC_code * ADC_LSB
        VLOW_pass, fail = ICQtest(VLOW, VLOW_min, VLOW_max)
        tests_failed = tests_failed + fail
        print(&#34; VLOW = &#34; + str(VLOW), VLOW_pass)

        VDDA1_test = [&#39;VDDA1_V&#39;, VDDA1, str(VDDA1_pass), VDDA1_min, VDDA1_max]
        ICQ_dict[&#39;VDDA1_V&#39;] = VDDA1_test[1:]
        VHIGH_test = [&#39;VHIGH_V&#39;, VHIGH, str(VHIGH_pass), VHIGH_min, VHIGH_max]
        ICQ_dict[&#39;VHIGH_V&#39;] = VHIGH_test[1:]
        VLOW_test = [&#39;VLOW_V&#39;, VLOW, str(VLOW_pass), VLOW_min, VLOW_max]
        ICQ_dict[&#39;VLOW_V&#39;] = VLOW_test[1:]

        if ICQ_mode == &#39;laser&#39;:
            self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x04, 0x00, 0x10])
            self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x02, 0x00, 0x10])
            self.dev.writeI2C(I2C_MALKA, AD5593R_ID, [0x40])
            VLD = self.dev.readI2C(I2C_MALKA, AD5593R_ID, 2)
            VLD[0] = VLD[0] &amp; 0x0F #ADC conversion is 12 LSBs (bits 13-15 = ADC channel info) 
            VLD = VLD[0] *256 + VLD[1] #unpack bytes
            VLD = VLD * (ADC_REF / ADC_BITS) #convert ADC code to voltage
            VLD = VLD * 5 #Resistor divider schematic - needs to be corrected
            VLD_pass, fail = ICQtest(VLD, VLD_min, VLD_max)
            tests_failed = tests_failed + fail
            print(&#34; VLD = &#34; + str(VLD), VLD_pass)
            VLD_test = [&#39;VLD_V&#39;, VLD, str(VLD_pass), VLD_min, VLD_max]
            ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

        elif ICQ_mode == &#39;no_laser&#39;:
            VLD_test = [&#39;VLD_V&#39;, 0, &#39;NA&#39;, -0.1, 0.1]
            ICQ_dict[&#39;VLD_V&#39;] = VLD_test[1:]

        else:
            raise Exception(&#34;\n\nERROR: Invalid ICQ mode\n\n&#34;)
              

        if(tests_failed == 0):
            print(&#34;Device PASSED&#34;)
            device_passed = &#34;PASSED&#34;
            ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 1
        else:
            print(&#34;Device FAILED&#34;)
            device_passed = &#34;FAILED&#34;
            print(&#34;Number of tests failed = &#34;, tests_failed)
            ICQ_dict[&#39;info&#39;][&#39;Pass&#39;] = 0


        Device_test = [&#39;Pass/Fail&#39;, tests_failed, str(device_passed), 0, 0]

        # #data directory path
        # DATA_PATH = &#39;./datalogs&#39;
        # #data file name
        # DATA_NAME = &#39;IQC_log&#39;
        # #todays date
        

        time.sleep(0.1)
        if( data == 0x02):
            print(&#34;uSeq running&#34;)
            break
        else:
            errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
            print( &#34;Error = &#34; + hex(errorCode))
            
    if( errorCode != 0x0 or data == 0x00):
        sys.exit()
        
    # Kick-off camera stream
    self.bProgrammed = True
    print(&#34;camera programmed&#34;)

    self.QuickStopSensor()

    now = datetime.now()
    date_string = now.date().strftime(&#34;%Y_%m_%d&#34;)
    time_string = now.time().strftime(&#34;_%H_%M_%S&#34;)

    #create total file path (with date)
    # file_name = DATA_PATH + &#39;/&#39; + date_string + time_string + &#39;_&#39; + DATA_NAME + &#34;.csv&#34;      
    file_name = file_name + &#39;.csv&#39;          

    if not os.path.isfile(file_name):
        csv_headers = [&#39;Test&#39;, &#39;Value&#39;, &#39;Result&#39;, &#39;Min Limit&#39;, &#39;Max Limit&#39;]

    with open(file_name, &#39;w&#39;, newline=&#39;&#39;) as new_data_file:
        datawriter = csv.writer(new_data_file)
        datawriter.writerow(csv_headers)
        datawriter.writerow(Device_test)
        datawriter.writerow(Vmain_pre_test)
        datawriter.writerow(Imain_pre_test)
        datawriter.writerow(Vmain_static_test)
        datawriter.writerow(Imain_static_test)
        datawriter.writerow(Vmain_on_test)
        datawriter.writerow(Imain_on_test)

        datawriter.writerow(Vsys_pre_test)
        datawriter.writerow(Isys_pre_test)
        datawriter.writerow(Vsys_static_test)
        datawriter.writerow(Isys_static_test)
        datawriter.writerow(Vsys_on_test)
        datawriter.writerow(Isys_on_test)

        datawriter.writerow(Vdepth_pre_test)
        datawriter.writerow(Idepth_pre_test)
        datawriter.writerow(Vdepth_static_test)
        datawriter.writerow(Idepth_static_test)
        datawriter.writerow(Vdepth_on_test)
        datawriter.writerow(Idepth_on_test)

        datawriter.writerow(Vaux_pre_test)
        datawriter.writerow(Iaux_pre_test)
        datawriter.writerow(Vaux_static_test)
        datawriter.writerow(Iaux_static_test)
        datawriter.writerow(Vaux_on_test)
        datawriter.writerow(Iaux_on_test)

        datawriter.writerow(VDDA1_test)
        datawriter.writerow(VHIGH_test)
        datawriter.writerow(VLOW_test)
        datawriter.writerow(VLD_test)

    return [tests_failed, ICQ_dict]</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.Init"><code class="name flex">
<span>def <span class="ident">Init</span></span>(<span>self, Mode=3, fps=30, cfg='')</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the image sensor.</p>
<h2 id="inputs">Inputs</h2>
<p>Mode: sensor mode (0-10)
fps: maximum fps of the image stream
cfg: path to .cfg file </p>
<h2 id="outputs">Outputs</h2>
<p>0 if successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Init( self, Mode=3, fps=30, cfg = &#34;&#34;):
    &#34;&#34;&#34;
    Initializes the image sensor.
    
    Inputs:
        Mode: sensor mode (0-10) 
        fps: maximum fps of the image stream 
        cfg: path to .cfg file 

    Outputs:
        0 if successful
    &#34;&#34;&#34;
    ret = self.dev.openDevice( Mode, -1)
    if( ret &lt; 0):
        print(&#34;Error opening the camera&#34;)
        return -2
    
    &#39;&#39;
    # 
    # self.dev.setGpio( MPSOC_SYNC_SEL0, 1)
    # self.dev.setGpio( MPSOC_SYNC_SEL1, 1)
    
    # SyncMaster = 1
    # SyncSlave = 0
    # syncSel = SyncMaster
    # self.dev.setGpio( 171, syncSel) # mux2 sel signal : external (0) / internal (1) sync source
    # self.dev.setGpio( MPSOC_SYNC_DIR, syncSel) # snl74 direction signal: external (0) / internal (1) sync source

    # #self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # timer (0) / GPIO (1) internal sync
    # #self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
    # 
    self.dev.setSyncMode( 0, 0) # external , external sync 1v8

    #self.dev.setSyncMode( 0, 0)

    ret = self.sensorPowerUp()
    if( ret &lt; 0):
        print(&#34;Error during sensor power up. Please restart your system.&#34;)
        sys.exit()


    self.Mode = Mode
    self._setInternalClassMode()

    self.fps = fps
    self.dev.setCameraFrameRate( self.fps)

    print(cfg)
    time.sleep(1)
    self.dev.programCfg(cfg)

    if( Mode != 3):
        #self.changeMode( self.Mode)
        self.dev.writeSPISingle( 0x0200, self.Mode)

    self.Start()

    return 0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.InitDE_Struct"><code class="name flex">
<span>def <span class="ident">InitDE_Struct</span></span>(<span>self, *argv)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a dump engine structure</p>
<h2 id="inputs">Inputs</h2>
<p>variable arguments </p>
<h2 id="outputs">Outputs</h2>
<p>DE_struct:
Dump engine structure dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitDE_Struct(self, *argv):
    &#34;&#34;&#34;
    Initialize a dump engine structure
    Inputs:
        variable arguments 

    Outputs:
        DE_struct:  Dump engine structure dictionary 
    &#34;&#34;&#34; 
    NCLKS_INIT = 8
    DE_Struct = dict()
    if len(argv) &gt; 0:
        DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = argv[0]
    else:
        DE_Struct[&#39;bypassWaveformErrorCheck&#39;] = False

    if len(argv) &gt; 1:
        DE_Struct[&#39;dispStr&#39;] = argv[1]
    else:
        DE_Struct[&#39;dispStr&#39;] = &#39;&#39;

    DE_Struct[&#39;clks&#39;], clksValue, LockScale = self.ReadConfigFile(&#39;./config/DumpTimingToolConfig_ADSD3100.csv&#39;)
    clksValue = np.transpose(np.reshape(clksValue, [1, len(clksValue)]))
    clksValue = clksValue * np.ones([1, NCLKS_INIT])

    DE_Struct[&#39;mode&#39;] = self.InitModes(clksValue, LockScale)

    return DE_Struct</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.InitModes"><code class="name flex">
<span>def <span class="ident">InitModes</span></span>(<span>self, clksValue_0, LockScale_0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize sensor mode</p>
<h2 id="inputs">Inputs</h2>
<p>clksValue_0
LockScale_0 </p>
<h2 id="outputs">Outputs</h2>
<p>mode: returns information of the mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitModes(self, clksValue_0, LockScale_0):
    &#34;&#34;&#34;
    Initialize sensor mode
    Inputs:
        clksValue_0 
        LockScale_0 

    Outputs:
        mode: returns information of the mode
    &#34;&#34;&#34; 
    name = [&#39;native_resolution&#39;, &#39;sub_sampled_2x&#39;, &#39;sub_sampled_4x&#39;, &#39;binned&#39;, &#39;dark&#39;, &#39;preamble&#39;, &#39;postamble&#39;]
    tmp = int(&#39;0x0E30&#39;, 0) + 6* np.arange(0,len(name))
    regAddrStart = tmp
    regAddrEnd = tmp + 2
    regAddrRepeat = tmp + 4

    name = np.append(name, &#39;binned_1x2&#39;)
    regAddrStart = np.append(regAddrStart, int(&#39;0x0E12&#39;, 0))
    regAddrEnd = np.append(regAddrEnd, int(&#39;0x0E1A&#39;, 0))
    regAddrRepeat = np.append(regAddrRepeat, int(&#39;0x0E02&#39;, 0))

    repeatCount = np.zeros(len(name))
    clksValue = np.zeros(len(name), dtype=object)
    LockScale = np.zeros(len(name), dtype=object)
    for i in range(len(name)):
        clksValue[i] = clksValue_0 
        LockScale[i] = LockScale

    mode = dict(
                name = name,
                repeatCount = repeatCount,
                regAddrStart = regAddrStart,
                regAddrEnd = regAddrEnd,
                regAddrRepeat = regAddrRepeat,
                clksValue = clksValue,
                LockScale = LockScale
                )
    return mode</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.InvertLSMOD"><code class="name flex">
<span>def <span class="ident">InvertLSMOD</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation</p>
<h2 id="inputs">Inputs</h2>
<p>none</p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InvertLSMOD( self):
    &#34;&#34;&#34;
    Function to invert LSMOD control register in the ADSD3100, to address Tinker Intersil driver implementation
    Inputs:
        none

    Outputs:
        none
        
    &#34;&#34;&#34; 
    lsmod_cfg1 = self.dev.readSPISingle( 0x0138,1)
    val = lsmod_cfg1[0]
    val = ((val &amp; 0x0F) &lt;&lt; 4) + ((lsmod_cfg1[0] &amp; 0xF0) &gt;&gt; 4)
    print (&#34;Swapped = &#34;+ hex(val))
    self.dev.writeSPISingle(0x0138, val)
    print(&#34;LSMOD1L Config = &#34;+ hex(val))</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.LoadGainOffsetCalib"><code class="name flex">
<span>def <span class="ident">LoadGainOffsetCalib</span></span>(<span>self, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads gain and offset to memory</p>
<h2 id="inputs">Inputs</h2>
<p>fname: location of csv file </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LoadGainOffsetCalib(self, fname):
    &#34;&#34;&#34;
    Loads gain and offset to memory
    Inputs:
        fname: location of csv file 

    Outputs:
        none

    &#34;&#34;&#34;
    fin = open(fname, &#39;r&#39;)
    csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)
    arr = np.array([],dtype=np.uint16)
    for row in csv_reader:
        arr = np.append(arr, np.uint16(int(str(row[0]),0)))
    
    ADC_updnoffset = arr[0]
    ADC_iramp = arr[1]

    Vref1DAC = arr[2]
    Vref1Set = arr[3]
    Vref2DAC = arr[4]
    Vref2Set = arr[5]
    Vref3DAC = arr[6]
    Vref3Set = arr[7]
    VCMDAC = arr[8]
    VCMSet = arr[9]
    inverseGlobalADCGain = np.zeros(4,dtype=np.uint16)
    inverseGlobalADCGain[0] = arr[10]
    inverseGlobalADCGain[1] = arr[11]
    inverseGlobalADCGain[2] = arr[12]
    inverseGlobalADCGain[3] = arr[13]
    perColGain = arr[14:12814]
    perColOffset = arr[12814:25614]

    dac_ctrl2_s1 = Vref1DAC | (Vref2DAC &lt;&lt; 8)
    dac_ctrl3_s1 = Vref3DAC

    if &#39;VCMDAC&#39; != 0:
        dac_ctrl3_s1 = dac_ctrl3_s1| (VCMDAC &lt;&lt; 8)

    dac_ctrl2_s1_mask = 0x003F * (Vref1Set != 0) + 0x3F00 * (Vref2Set != 0)
    dac_ctrl3_s1_mask = 0x003F * (Vref3Set != 0)

    if VCMSet != 0 and VCMDAC != 0:
        dac_ctrl3_s1_mask = dac_ctrl3_s1_mask + 0x3F00 * (VCMSet != 0)

    val = self.regread(0x0112)
    if val != 22833:
        raise Exception(&#39;Cannot Communicate with chip / incorrect chipId&#39;)

    digPwrDown = self.regread(0x0014)
    s = self.regwrite(0x0014, 0x0000)

    s = self.regwrite(0x0102, ADC_updnoffset)
    s = s and self.regwrite(0x0104, ADC_iramp)
    s = s and self.regwriteburst(0x0520, inverseGlobalADCGain, &#39;increment&#39;)
    s = s and self.regrmw(0x012E, dac_ctrl2_s1, dac_ctrl2_s1_mask)
    s = s and self.regrmw(0x0130, dac_ctrl3_s1, dac_ctrl3_s1_mask)

    # perColGain
    s = s and self.regwrite(0x0500, 0x0008)
    s = s and self.regwrite(0x0502, 0x0000)
    s = s and self.regwriteburst(0x0504, perColGain)
    s = s and self.regrmw(0x0528, 0x0000, 0x0004)

    # perColOffset
    s = s and self.regwrite(0x0500, 0x0004)
    s = s and self.regwrite(0x0502, 0x0000)
    s = s and self.regwriteburst(0x0504, perColOffset)
    s = s and self.regrmw(0x0528, 0x0000, 0x0002)

    s = self.regwrite(0x0014, digPwrDown)
    if s:
        print(&#39;Gain and Offset calibration data loaded!&#39;)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.PowerMonitor"><code class="name flex">
<span>def <span class="ident">PowerMonitor</span></span>(<span>self, PMId)</span>
</code></dt>
<dd>
<div class="desc"><p>This function reads the voltage, current and power measured by a given
power monitor in the Malka board.</p>
<p>:param dev: Ardacho camera pointer.
:type dev: Ardacho IOLib device class.
:param PMId: Power Monitor id. Use any of the ids defined at the top of the application script.
:type PMId: int
<br>
:returns: returns a list with the measured parameters [ Voltage, Current, Power]
:rtype: [ float, float, float]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PowerMonitor( self,PMId):
    &#34;&#34;&#34;This function reads the voltage, current and power measured by a given
    power monitor in the Malka board.

    :param dev: Ardacho camera pointer. 
    :type dev: Ardacho IOLib device class. 
    :param PMId: Power Monitor id. Use any of the ids defined at the top of the application script. 
    :type PMId: int      
    :returns: returns a list with the measured parameters [ Voltage, Current, Power] 
    :rtype: [ float, float, float] 
    &#34;&#34;&#34;

    CONF_REG = 0x00
    VBUS_REG = 0x02
    POWER_REG = 0x03
    SHUNT_REG = 0x01
    CURR_REG = 0x04
    CAL_REG = 0x05
    
    self.dev.writePowerMonReg( PMId, CONF_REG, 0x4007 | 2 &lt;&lt; 9 | 4 &lt;&lt; 6 | 4 &lt;&lt; 3 )
    time.sleep(0.1)
    Vbus =  self.dev.readPowerMonReg( PMId, VBUS_REG)
    Cal = self.dev.readPowerMonReg( PMId, CAL_REG)
    CUR = self.dev.readPowerMonReg( PMId, CURR_REG)
    SHUNT = self.dev.readPowerMonReg( PMId, SHUNT_REG)
    PWR = self.dev.readPowerMonReg( PMId, POWER_REG)


    Volt = round(Vbus * 1.25/1000, 3)
    if( PMId == VMAIN_DEV_ID):
        Imax = (0.00512/0.01)*((32768)/Cal) # Vmain uses 0.01 shunt resistor
    else:
        Imax = (0.00512/0.02)*((32768)/Cal) # Vaux, Vdepth and Vsys uses 0.02 shunt resistor

    ILSB = (Imax/(32768))
    Curr =  round(CUR* ILSB,6)
    PwrLSB = 25*ILSB
    Power = round(PWR * PwrLSB, 6)
    return [ Volt, Curr, Power ]</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.QuickStartSensor"><code class="name flex">
<span>def <span class="ident">QuickStartSensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to start sensor without checks</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def QuickStartSensor(self):
    &#34;&#34;&#34;
    Command to start sensor without checks
    Inputs:
        none 
    Outputs:
        none 

    &#34;&#34;&#34;
    self.dev.startSensor()
    if self.firstStart == True:
        self.dev.writeSPISingle( 0x000C, 0x00C5)
        self.firstStart = False
    else:
        self.dev.writeSPISingle( 0x000C, 0x0001)
    val = 1
    i = 0
    while (val != 0 and i &lt; 10):
        time.sleep(0.01)
        val = self.dev.readSPISingle(0x000C, 1)
        i = i + 1
    
    self.bProgrammed = True</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.QuickStopSensor"><code class="name flex">
<span>def <span class="ident">QuickStopSensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to stop sensor without checks </p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def QuickStopSensor(self):
    &#34;&#34;&#34;
    Command to stop sensor without checks 
    Inputs:
        none 

    Outputs:
        none 

    &#34;&#34;&#34;
    # self.dev.stopSensor()
    self.dev.writeSPISingle( 0x000C, 0x0002)
    regData = self.dev.readSPISingle( 0x000C, 1)
    i=0
        
    while( regData[0] != 0x0 and i&lt;20):
        time.sleep(0.01)
        regData = self.dev.readSPISingle( 0x000C, 1)
        i = i + 1
    if( i == 20):
        print(&#34;Error stopping camera&#34;)

    self.dev.stopSensor()</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ReadAmpGainSetting"><code class="name flex">
<span>def <span class="ident">ReadAmpGainSetting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads amplifier gain setting</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>amp gain setting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadAmpGainSetting(self):
    &#34;&#34;&#34;
    Reads amplifier gain setting
    Inputs:
        none 

    Outputs:
        amp gain setting 
    &#34;&#34;&#34; 
    val = self.regread(0x014E) # Analog NCDS mode bit
    # self.error_assert(success, &#39;Cannot read Analog NCDS mode bit&#39;)
    ncds_mode = self.bitget(int(val), 3)

    if ncds_mode:
        Cin = np.array([160,80,80]) # For ADSD3100, Cin is different between analog and digital CDS modes
    else:
        Cin = np.array([320,160,80])

    Cfb = np.array([4*25.88,2*20.24,2*6.76,2*5.17,2*3.57]) # gain= (160*cin1+80*cin0+80)/(2*3.57+2*5.17*cfb0+2*6.76*cfb1+2*20.24*cfb2+4*25.88*cfb3)

    tmp1 = np.sum(np.array(self.generate_truthtable(2)) * Cin[0:2], axis=1) + Cin[2]
    tmp2 = np.sum(np.array(self.generate_truthtable(4)) * Cfb[0:4], axis=1) + Cfb[4]
    ampgainTable = np.transpose(np.reshape(tmp1,[1,len(tmp1)])) / tmp2

    # plt.plot(ampgainTable[0,:], label=&#34;Cin=0&#34;)
    # plt.plot(ampgainTable[1,:], label=&#34;Cin=1&#34;)
    # plt.plot(ampgainTable[2,:], label=&#34;Cin=2&#34;)
    # plt.plot(ampgainTable[3,:], label=&#34;Cin=3&#34;)
    # plt.legend()
    # plt.ylabel(&#39;Gain&#39;)
    # plt.xlabel(&#39;Cfb&#39;)
    # plt.title(&#39;ampgainTable&#39;)
    # plt.show()

    # Manually update table with gains measured on ADSD3100
    ampgainTable[3,1] = 16.75
    ampgainTable[3,2] = 14.7
    ampgainTable[3,4] = 6.8
    ampgainTable[3,11] = 2.35
    ampgainTable[0,8] = 0.72


    RegisterValueCin = self.regread(0x010E) # AMP Cin register
    # self.error_assert(success, &#39;Cannot read AMP Cin register&#39;)
    RegisterValueCfb = self.regread(0x010C) # AMP Cfb register
    # self.error_assert(success, &#39;Cannot read AMP Cfb register&#39;)

    ampgain = np.zeros(4)

    for i in range(4):
        Cfb = (int(RegisterValueCfb) &gt;&gt; i*4) &amp; 15
        Cin = (int(RegisterValueCin) &gt;&gt; i*4) &amp; 3
        ampgain[i] = ampgainTable[Cin, Cfb]

    return ampgain</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ReadBoardADC"><code class="name flex">
<span>def <span class="ident">ReadBoardADC</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Read onboard ADC value</p>
<h2 id="inputs">Inputs</h2>
<p>val: value </p>
<h2 id="outputs">Outputs</h2>
<p>ADC value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadBoardADC(self, val):
    &#34;&#34;&#34;
    Read onboard ADC value
    Inputs:
        val: value 

    Outputs:
        ADC value 

    &#34;&#34;&#34;
    return self.dev.getADCvalue(val)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ReadConfigFile"><code class="name flex">
<span>def <span class="ident">ReadConfigFile</span></span>(<span>self, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Read dump engine configuration file (.csv)</p>
<h2 id="inputs">Inputs</h2>
<p>fname: csv filename </p>
<h2 id="outputs">Outputs</h2>
<p>DE_struct: updated DE_struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadConfigFile(self, fname):
    &#34;&#34;&#34;
    Read dump engine configuration file (.csv)
    Inputs:
        fname: csv filename 

    Outputs:
        DE_struct: updated DE_struct 
    &#34;&#34;&#34; 
    clks = dict()
    clks[&#39;DE_Addr&#39;] = []
    clks[&#39;Name&#39;] = []
    clks[&#39;View&#39;] = []
    DefaultValue = []
    LockScale_Default = []
    clks[&#39;ToolTip&#39;] = []

    # path = os.path.dirname(os.path.abspath(__file__))
    # with open(os.path.join(path,fname)) as csv_file:
    with open(fname) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
        line_count = 0
        for row in csv_reader:
            if line_count == 0:
                line_count += 1
            else:
                clks[&#39;DE_Addr&#39;] = np.append(clks[&#39;DE_Addr&#39;], int(row[0]))
                clks[&#39;Name&#39;]  = np.append(clks[&#39;Name&#39;] , row[1])
                clks[&#39;View&#39;] = np.append(clks[&#39;View&#39;], bool(row[2]))
                DefaultValue = np.append(DefaultValue, int(row[3]))
                LockScale_Default = np.append(LockScale_Default, int(row[4]))
                clks[&#39;ToolTip&#39;] = np.append(clks[&#39;ToolTip&#39;], row[5])
    csv_file.close()

    return clks, DefaultValue, LockScale_Default</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.ReadDEclkFreqFromChip"><code class="name flex">
<span>def <span class="ident">ReadDEclkFreqFromChip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read dump engine clock frequency</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>adc_pllFreq/clk_de_div : adc pll frequency divied by DE clock division</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadDEclkFreqFromChip(self):
    &#34;&#34;&#34;
    Read dump engine clock frequency
    Inputs:
        none 

    Outputs:
        adc_pllFreq/clk_de_div : adc pll frequency divied by DE clock division 
    &#34;&#34;&#34; 
    adcPllRegisterValue = self.regread(0x010A) # Read ADC PLL register
    adc_c = int(adcPllRegisterValue) &amp; 31
    adc_end5 =  (int(adcPllRegisterValue) &gt;&gt; 8) &amp; 15
    adc_pllFreq = 24*(adc_end5 + 4*(adc_c+1))

    clkDeRegisterValue = self.regread(0x011A) # Read Clock DE register
    de_c = int(clkDeRegisterValue) &amp; 31
    de_end5 = (int(clkDeRegisterValue) &gt;&gt; 8) &amp; 15
    clk_de_div = de_end5 + 4*(de_c+1)

    return adc_pllFreq/clk_de_div

    return clks, DefaultValue, LockScale_Default</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.SetDiffDacSfVoltage"><code class="name flex">
<span>def <span class="ident">SetDiffDacSfVoltage</span></span>(<span>self, DacCal, DacSel, TargetDiff, CMwindow, DacCal_folderName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Sets differential DAC voltage</p>
<h2 id="inputs">Inputs</h2>
<p>DacCal: DAC calibration values
DacSel: DAC selection ex: AMPTEST0 etc
TargetDiff: Voltage difference
CMWindow: CommonMode window
DacCal_folderName: location of file to store DacCal values </p>
<h2 id="outputs">Outputs</h2>
<p>DacCal : DAC calibration values
AMPTEST0, AMPTEST1, CMREF values
diff_meas_out: measured differential voltage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDiffDacSfVoltage(self, DacCal, DacSel, TargetDiff, CMwindow, DacCal_folderName=&#34;&#34;):
    &#34;&#34;&#34;
    Sets differential DAC voltage
    Inputs:
        DacCal: DAC calibration values 
        DacSel: DAC selection ex: AMPTEST0 etc 
        TargetDiff: Voltage difference 
        CMWindow: CommonMode window 
        DacCal_folderName: location of file to store DacCal values 

    Outputs:
        DacCal : DAC calibration values 
        AMPTEST0, AMPTEST1, CMREF values 
        diff_meas_out: measured differential voltage 

    &#34;&#34;&#34; 
    #s, valArr = self.regreadburst(0x0E00, 80,&#39;increment&#39;)
    self.regwrite(0x0014,0x0000)
    #print(valArr)
    NUM_ITERATIONS = 1
    MAX_ERROR = [5e-3, 15e-3]

    if len(list(DacCal.keys())) == 0:
        CMREF_Samples = [150, 203, 255]
        AMPTEST_Samples = [150, 176, 203, 229, 255]
        CMREF_meas = np.zeros(len(CMREF_Samples))
        AMPTEST0_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
        AMPTEST1_meas = np.zeros([len(CMREF_Samples), len(AMPTEST_Samples)])
        for j in range(len(CMREF_Samples)-1, -1,-1):
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF_Samples[j]))
            success = self.dac_cmref_set(np.uint8(CMREF_Samples[j]))
            self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
            CMREF_meas[j] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF&#39;)
            for k in range(len(AMPTEST_Samples)-1,-1,-1):
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                success = self.dac_amptest0_set(np.uint8(AMPTEST_Samples[k]))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
                # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST_Samples[k]))
                success = self.dac_amptest1_set(np.uint8(AMPTEST_Samples[k]))
                self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)
                AMPTEST0_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST0&#39;)
                AMPTEST1_meas[j,k] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1&#39;)
        y,x = np.meshgrid(AMPTEST_Samples,CMREF_Samples)
        Xmeas = [[np.ones([len(CMREF_Samples)*len(AMPTEST_Samples)])], [np.transpose(x).flatten()],
                [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
        Xmeas = np.squeeze(np.transpose(Xmeas))
        M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST0_meas).flatten(), rcond=None)[0] # Matrix left division

        [y,x] = np.meshgrid(range(0,256), range(0,256))
        Xfit = [[np.ones([np.size(y)])], [np.transpose(x).flatten()],
                [np.transpose(y).flatten()], [np.transpose(y).flatten()**2]]
        Xfit = np.squeeze(np.transpose(Xfit))
        DacCal[&#39;AMPTEST0_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

        M = np.linalg.lstsq(Xmeas, np.transpose(AMPTEST1_meas).flatten(), rcond=None)[0] # Matrix left division
        DacCal[&#39;AMPTEST1_pred&#39;] = np.reshape(np.dot(Xfit,M), np.shape(y))

        # Dacs are non-linear at low code values, so remove these points from the predicted data
        DacCal[&#39;AMPTEST0_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
        DacCal[&#39;AMPTEST0_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan
        DacCal[&#39;AMPTEST1_pred&#39;][:,0:np.min(CMREF_Samples)] = np.nan
        DacCal[&#39;AMPTEST1_pred&#39;][0:np.min(AMPTEST_Samples),:] = np.nan

        DacCal[&#39;CMREF_pred&#39;] = np.polyval(np.polyfit(CMREF_Samples, CMREF_meas, 1),range(0,256))
        DacCal[&#39;CMREF_pred&#39;][0:np.min(CMREF_Samples)] = np.nan # Remove CMREF values below min sampled DAC code

        DacCal[&#39;RangeCMREF&#39;] = np.array([CMREF_meas[-1], CMREF_meas[0]])
        DacCal[&#39;RangeAMPTEST0&#39;] = np.array([np.max(AMPTEST0_meas[:,0]), np.min(AMPTEST0_meas[:,-1])])
        DacCal[&#39;RangeAMPTEST1&#39;] = np.array([np.max(AMPTEST1_meas[:,0]), np.min(AMPTEST1_meas[:,-1])])
        if(DacCal_folderName != &#34;&#34;):
            f = open(os.path.join(DacCal_folderName, &#39;DacCal.pkl&#39;), &#39;wb&#39;)
            pickle.dump(DacCal, f)
            f.close()


    if DacSel.upper() == &#39;CMREF-AMPTEST0&#39;:
        # Sanity check inputs
        if (np.max(CMwindow) + TargetDiff/2) &lt; DacCal[&#39;RangeCMREF&#39;][0]:
            raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0]))
            logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeCMREF&#39;][0])))
    
        if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
            raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
            logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of CMRef DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

        diff = -(-np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;]).astype(np.float)
        cm = 0.5 * (np.reshape(DacCal[&#39;CMREF_pred&#39;],[1,len(DacCal[&#39;CMREF_pred&#39;])]) + DacCal[&#39;AMPTEST0_pred&#39;])

        diff = diff.astype(np.float)
        cond1 = ~np.isnan(cm)
        cond2 = ~np.isnan(cm)
        cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
        cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
        diff[cond1] = np.nan
        diff[cond2] = np.nan

        x,y = np.shape(diff)

        tmp = (abs(diff - TargetDiff)).flatten()
        error_pred = np.sort(tmp)
        idx = np.argsort(tmp)

        if error_pred[0] &gt; MAX_ERROR[1]:
            print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
            logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

        if NUM_ITERATIONS &gt; 1:
            diff_meas = np.zeros(NUM_ITERATIONS)

        for i in range(NUM_ITERATIONS):
            CMREF = int(idx[i] % x)
            AMPTEST0 = int(np.floor(idx[i] / x))

            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
            success = self.dac_cmref_set(np.uint8(CMREF))
            self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
            success = self.dac_amptest0_set(np.uint8(AMPTEST0))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

            if NUM_ITERATIONS &gt; 1:
                diff_meas[i] = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)

        if NUM_ITERATIONS &gt; 1:
            idxMinErr = np.argmin(np.abs(TargetDiff - diff_meas))
            CMREF = int(idxMinErr[i] % x)
            AMPTEST0 = int(np.floor(idxMinErr[i] / x))
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], CMREF)
            success = self.dac_cmref_set(np.uint8(CMREF))
            self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)
            # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
            success = self.dac_amptest0_set(np.uint8(AMPTEST0))
            self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)

        cmSetpoint = cm[AMPTEST0-1, CMREF-1] # get predicted CM voltage
        AMPTEST1 = np.nanargmin(np.abs(cmSetpoint - DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF-1]))
        # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], int(AMPTEST1))
        success = self.dac_amptest1_set(np.uint8(AMPTEST1))
        self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

        if NUM_ITERATIONS &gt; 1:
            diff_meas_out = diff_meas[idxMinErr]
        else:
            diff_meas_out = -self.CamMeasureAnaTestVoltage(&#39;DACwithSF_CMREF-AMPTEST0&#39;)            

    elif DacSel.upper() == &#39;AMPTEST1-AMPTEST0&#39;:
        # Sanity check inputs
        if (np.min(CMwindow) + TargetDiff/2) &gt; DacCal[&#39;RangeAMPTEST0&#39;][1]:
            raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1]))
            logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][1])))

        if (np.max(CMwindow) - TargetDiff/2) &lt; DacCal[&#39;RangeAMPTEST0&#39;][0]:
            raise Exception(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0]))
            logging.error(str(&#39;CMWindow [%.3f,%.3f] V and TargetDiff %.3f V exceed range of AMPTEST DAC (%.3fV)&#39; %(CMwindow,TargetDiff,DacCal[&#39;RangeAMPTEST0&#39;][0])))


        CMREF = np.nanargmin(np.abs(np.mean(CMwindow) - DacCal[&#39;CMREF_pred&#39;]))

        # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_cmref&#39;][&#39;set&#39;], int(CMREF))
        success = self.dac_cmref_set(np.uint8(CMREF))
        self.error_assert(success, &#39;Unable to set DAC CMREF&#39;)

        diff = -np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1])
        cm = 0.5 * (np.reshape(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF],[1,len(DacCal[&#39;AMPTEST1_pred&#39;][:,CMREF])]) + np.reshape(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF],[len(DacCal[&#39;AMPTEST0_pred&#39;][:,CMREF]),1]))

        diff = -diff.astype(np.float)
        cond1 = ~np.isnan(cm)
        cond2 = ~np.isnan(cm)
        cond1[cond1] = cm[cond1] &lt; CMwindow[0] # equivalent of cond1 = cm &lt; CMwindow[0]
        cond2[cond2] = cm[cond2] &gt; CMwindow[1] # equivalent of cond2 = cm &gt; CMwindow[1]
        diff[cond1] = np.nan
        diff[cond2] = np.nan

        x,y = np.shape(diff)

        tmp = (abs(diff - TargetDiff)).flatten()
        error_pred = np.sort(tmp)
        idx = np.argsort(tmp)

        if error_pred[0] &gt; MAX_ERROR[1]:
            print(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3))
            logging.warning(str(&#39;Predicted error of %.1fmV exceeds DAC error threshold\n&#39; %(error_pred[0]*1e3)))

        AMPTEST1 = int(idx[0] % x)
        AMPTEST0 = int(np.floor(idx[0] / x))

        # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest0&#39;][&#39;set&#39;], AMPTEST0)
        success = self.dac_amptest0_set(np.uint8(AMPTEST0))
        self.error_assert(success, &#39;Unable to set DAC AMPTEST0&#39;)
        # success = self.API.APIComm(1, self.API.API[&#39;main&#39;][&#39;ioctrl&#39;], self.API.API[&#39;IO&#39;][&#39;dac_amptest1&#39;][&#39;set&#39;], AMPTEST1)
        success = self.dac_amptest1_set(np.uint8(AMPTEST1))
        self.error_assert(success, &#39;Unable to set DAC AMPTEST1&#39;)

        diff_meas_out = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)

    # print(self.regreadburst(0x0E00, 80,&#39;increment&#39;))
    # s = self.regwriteburst(0x0E00, valArr, &#39;increment&#39;)
    self.regwrite(0x0014,0x0000)

    return DacCal, {&#39;CMREF&#39;: CMREF, &#39;AMPTEST0&#39;: AMPTEST0, &#39;AMPTEST1&#39;: AMPTEST1}, diff_meas_out</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.SetIndirectRegister"><code class="name flex">
<span>def <span class="ident">SetIndirectRegister</span></span>(<span>self, name, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set indirect registers</p>
<h2 id="inputs">Inputs</h2>
<p>name: register name
val: register value </p>
<h2 id="outputs">Outputs</h2>
<p>status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetIndirectRegister(self, name, val):
    &#34;&#34;&#34;
    Set indirect registers
    Inputs:
        name: register name 
        val: register value 

    Outputs:
        status

    &#34;&#34;&#34;
    if name == &#39;N_OVRD_ANAMODE&#39;:
        addr = 0x1fc1
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;WAVE_FUNCTION_0&#39;:
        addr = 0x1fc5
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;WAVE_FUNCTION_1&#39;:
        addr = 0x1fc9
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;WAVE_FUNCTION_2&#39;:
        addr = 0x1fcd
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;LASER_CONTROL&#39;:
        addr = 0x1fd1
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;B_USE_LASER&#39; or name == &#39;N_MSI_ID&#39;:
        addr = 0x1fb1
        s = self.regwrite(0x0004, addr)
        prevVal = self.regread(0x0006)
        s = self.regwrite(0x0000, addr)
        if name == &#39;B_USE_LASER&#39;:
            s_  = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
        else:
            s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

    elif name == &#39;B_OVRD_ANAMODE&#39; or name == &#39;B_NO_FSYNCVEC&#39;:
        addr = 0x1fb5
        s = self.regwrite(0x0004, addr)
        prevVal = self.regread(0x0006)
        s = self.regwrite(0x0000, addr)
        if name == &#39;B_OVRD_ANAMODE&#39;:
            s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
        else:
            s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

    elif name == &#39;B_LVDS_PD&#39;:
        addr = 0x1fb9
        s = self.regwrite(0x0000, addr)
        s_ = self.regwrite(0x0002, np.uint16(val))

    elif name == &#39;B_EN_PHASESWEEP&#39; or name == &#39;B_LFSR&#39;:
        addr = 0x1fbd
        s = self.regwrite(0x0004, addr)
        prevVal = self.regread(0x0006)
        s = self.regwrite(0x0000, addr)
        if name == &#39;B_EN_PHASESWEEP&#39;:
            s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0xFF00) | (val &amp; 0x00FF)))
        else:
            s_ = self.regwrite(0x0002, np.uint16((prevVal &amp; 0x00FF) | ((val &lt;&lt; 8) &amp; 0xFF00)))

    else:
        raise Exception(&#34;Incorrect indirect register name: &#34; + str(name))

    s = self.regwrite(0x000C, 0x00C4)
    val = self.regread(0x0012)
    return s and self.regwrite(0x0012, np.uint16(val + 1)) # update sequence</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.SetLSDACValue"><code class="name flex">
<span>def <span class="ident">SetLSDACValue</span></span>(<span>self, LSDAC_VALUE)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets LSDAC value. This function encrypts the LSDAC values
before writing to memory</p>
<h2 id="inputs">Inputs</h2>
<p>LSDAC_VALUE: 2D array of LSDAC value (unencrypted) </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetLSDACValue(self, LSDAC_VALUE):
    &#34;&#34;&#34;
    Sets LSDAC value. This function encrypts the LSDAC values
    before writing to memory
    Inputs:
        LSDAC_VALUE: 2D array of LSDAC value (unencrypted) 

    Outputs:
        none

    &#34;&#34;&#34;

    #Stop execution before configuring LSDAC
    self.dev.writeSPISingle( 0x000C, 0x0002)
    regData = self.dev.readSPISingle( 0x000C, 1)
    while( regData[0] != 0x0):
        time.sleep(0.1)
        regData = self.dev.readSPISingle( 0x000C, 1)

    address, value = LSDAC.GenerateLSDACBlock(LSDAC_VALUE, self.n_modes_cfg)
    numel = len(address)
    newAddresses = np.array([])
    newValues = np.zeros(numel*2,dtype=object)
    for i in range(numel):
        newAddresses = np.append(newAddresses, np.array([0x0000,0x0002]))
    newValues[::2] = address
    newValues[1::2] = value
    print(&#39;Addr&#39;, newAddresses)
    print(&#39;Val&#39;, newValues)
    self.regwrite( np.asarray(newAddresses, dtype=np.uint16), np.asarray(newValues, dtype=np.uint16))

    #Start execution again after configuring LSDAC
    self.dev.writeSPISingle( 0x000C, 0x0001)

    print(&#39;LSDAC value set to&#39;, LSDAC_VALUE)
    try:
        logging.info(&#39;LSDAC value set to&#39; + str(LSDAC_VALUE))
    except:
        pass</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.Start"><code class="name flex">
<span>def <span class="ident">Start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to start the camera. First checks if the microsequencer
has started.</p>
<h2 id="inputs">Inputs</h2>
<p>none
</p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Start( self):
    &#34;&#34;&#34;
    Command to start the camera. First checks if the microsequencer
    has started.
    Inputs:
        none  

    Outputs:
        none  

    &#34;&#34;&#34;
    self.dev.writeSPISingle( 0x000C, 0x00C5)
    time.sleep(0.1) #Delay required for useq
    
    # check if useq works
    errorCode = 0
    for i in range(10):
        data = self.dev.readSPISingle( 0x0256,1 )
        data = data[0]
        print(&#34;data = &#34; + hex(data))
        time.sleep(0.1)
        if( data == 0x02):
            print(&#34;uSeq running&#34;)
            break
        else:
            time.sleep(0.5)
            data = self.dev.readSPISingle( 0x0256,1 )
            data = data[0]
            print(&#34;data retry = &#34; + hex(data))
            if( data == 0x02):
                print(&#34;uSeq running&#34;)
                break
            else:
                errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
                print( &#34;Error = &#34; + hex(errorCode))
            
    if( errorCode != 0x0 or data == 0x00):
        sys.exit()
    
    self.dev.startSensor()
  
    # Kick-off camera stream
    self.bProgrammed = True
    print(&#34;camera programmed&#34;)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.StartSensor"><code class="name flex">
<span>def <span class="ident">StartSensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to start sensor. Needs ConnectSensor() to be run before.
Starts capturing of raw data.</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartSensor(self):
    &#34;&#34;&#34;
    Command to start sensor. Needs ConnectSensor() to be run before.
    Starts capturing of raw data.
    Inputs:
        none 

    Outputs:
        none 

    &#34;&#34;&#34;

    # Send start command to camera
    self.dev.writeSPISingle( 0x000C, 0x00C5)

    # check if useq works
    errorCode = 0
    for i in range(10):
        data = self.dev.readSPISingle( 0x0256,1 )
        data = data[0]
        print(&#34;data = &#34; + hex(data))
        time.sleep(0.1)
        if( data == 0x02):
            print(&#34;uSeq running&#34;)
            break
        else:
            errorCode = self.dev.readSPISingle( 0x0032, 1)[0]
            print( &#34;Error = &#34; + hex(errorCode))

    if( errorCode != 0x0 or data == 0x00):
        sys.exit()

    # Kick-off camera stream
    self.bProgrammed = True
    print(&#34;camera programmed&#34;)
    self.dev.startSensor()

    return 0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.Stop"><code class="name flex">
<span>def <span class="ident">Stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to stop the camera</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Stop(self):
    &#34;&#34;&#34;
    Command to stop the camera
    Inputs:
        none 

    Outputs:
        none 

    &#34;&#34;&#34;
    i = 0
    
    # self.dev.setGpio( MPSOC_SYNC_SEL0, 0)
    # self.dev.setGpio( MPSOC_SYNC_SEL1, 0)
    # self.dev.setGpio( MPSOC_SYNC_DIR, 0)
    # self.dev.setGpio( 171, 0) # external (0) / internal (1) sync source

    # self.dev.setGpio( MPSOC_SYNC_DIR1, 0) # Gpio manual control
    # self.dev.setGpio( GPIO_CAM_FSYNC, 0) # Gpio manual control 
    

    if( self.bProgrammed == True):
        # safely stop the camera
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        
        while( regData[0] != 0x0 and i&lt;20):
            time.sleep(0.1)
            regData = self.dev.readSPISingle( 0x000C, 1)
            i = i + 1
    if( i == 20):
        print(&#34;Error stoping camera&#34;)
    print(&#34;CAMERA STOPPED&#34;)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.StopSensor"><code class="name flex">
<span>def <span class="ident">StopSensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Command to stop sensor.</p>
<h2 id="inputs">Inputs</h2>
<p>none</p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StopSensor(self):
    &#34;&#34;&#34;
    Command to stop sensor.
    Inputs:
        none

    Outputs:
        none

    &#34;&#34;&#34;
    i = 0
    if( self.bProgrammed == True):
        # safely stop the camera
        self.dev.writeSPISingle( 0x000C, 0x0002)
        regData = self.dev.readSPISingle( 0x000C, 1)
        
        while( regData[0] != 0x0 and i&lt;20):
            time.sleep(0.01)
            regData = self.dev.readSPISingle( 0x000C, 1)
            i = i + 1
    if( i == 20):
        print(&#34;Error stopping camera&#34;)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.StreamAndCapturePCM"><code class="name flex">
<span>def <span class="ident">StreamAndCapturePCM</span></span>(<span>self, paramDict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Streams and captures PCM image</p>
<h2 id="inputs">Inputs</h2>
<p>paramDict: dictionary containing frame parameters </p>
<h2 id="outputs">Outputs</h2>
<p>True
frames_dict: dictionary containing frames and header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StreamAndCapturePCM(self, paramDict = dict()):
    &#34;&#34;&#34;
    Streams and captures PCM image
    Inputs:
        paramDict: dictionary containing frame parameters 

    Outputs:
        True 
        frames_dict: dictionary containing frames and header 
    &#34;&#34;&#34;
     # Header Info

    keys = list(paramDict.keys())
    
    mode = 3

    if &#39;nFrames&#39; in keys:
        nFrames = paramDict[&#39;nFrames&#39;]
    else:
        nFrames = 5

    if &#39;fileName&#39; in keys:
        filename = paramDict[&#39;fileName&#39;]
    else:
        now = datetime.now()
        filename = &#39;mode_&#39; + str(mode) + &#39;_&#39; + now.strftime(&#34;%Y%m%d_%H%M%S&#34;)

    if &#39;outputFormat&#39; in keys:
        outputFormat = paramDict[&#39;outputFormat&#39;]
    else:
        outputFormat = &#39;pkl&#39;


    self.StartSensor()
    Temp_sensor_offset = 1493.55 # From calibration
    Temp_sensor_slope = 5.45 # From calibration
    self.changeMode(mode)


    while(True):

        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        #RawImage = self.dev.getImage8U()
        if( self.dev.validFrame != 1):
        #if( self.dev.IO.validFrame != 1):
            print(&#39;Invalid frame&#39;)
            pass

        else:
            RawImage = tmp[0]
            #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
            RAW = RawImage
            RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
            subImage = RawImage[0:self.width*self.height]
            # convert fractional raw image from camera to 16bit signed image
            image16 =  self.dev.ConvertFloat2LinearVal( subImage)
            image16 = np.resize( image16, (self.height, self.width))
            orig_image = np.copy(image16)
            image16 = image16 + np.amin( image16)*-1
            image16 = np.array( image16, dtype=np.uint16)

            # process image for visualization        
            mImg = np.uint8( (image16/np.amax(image16)*(255)))
            max_x, max_y = self.block_max(mImg)
            mImg = cv2.applyColorMap( mImg, cv2.COLORMAP_BONE)
            Imgstr = &#34;Relative PCM Image&#34;
            text1 = &#34;Press &#39;d&#39; to save and stop steaming&#34;
            text2 = &#34;Brightest 32x32 ROI mean = &#34; + str(np.round(np.mean(orig_image[max_y-16:max_y+16,max_x-16:max_x+16]),3))

            font = cv2.FONT_HERSHEY_SIMPLEX
            fontScale = 1
            fontColor = (255,0,255) #BGR
            thickness = 2
            org1 = (50, 50)
            org2 = (50, 1000)

            mImg = cv2.putText(mImg, text1, org1, font, fontScale, fontColor, thickness, cv2.LINE_AA)
            mImg = cv2.putText(mImg, text2, org2, font, fontScale, fontColor, thickness, cv2.LINE_AA)

            mImg = cv2.rectangle(mImg, (max_x-16, max_y-16), (max_x+16, max_y+16), (0,0,255), 2)

            #cv2.putText( mImg, str(j), ( 200, 200), cv2.FONT_HERSHEY_SIMPLEX, .5, ( 0, 0, 0), 2, cv2.LINE_AA)
            cv2.imshow( Imgstr, mImg)

        c = cv2.waitKey(50) &amp; 0xFF
        if (c == ord(&#39;d&#39;)) :
            cv2.destroyAllWindows()
            break
            


    captures = self.subFrames
    print(captures)
    # if self.freqPerPhase[-1] == 134: # Ignore pcm capture
    #     captures = captures - 1

    Img = np.zeros([self.height, self.width, captures, nFrames], dtype=np.int16)
    Header_tmp = np.zeros(nFrames, dtype=object)
    RawImage = np.zeros(nFrames,dtype=object)
    Header = np.zeros([captures, nFrames],dtype=object)

    frm = 0
    count = 0
    while frm &lt; nFrames:
        print(&#39;Frame #&#39;, frm)
        tmp = self.dev.getFloatImage()
        time.sleep(debug_delay)
        if( self.dev.validFrame != 1):
            print(&#39;skipped frame&#39;)
            pass
        else:
            RawImage[frm] = tmp[0]
            Header_tmp[frm] = tmp[1]
            frm = frm + 1
        print(&#39;count:&#39;, count)
        count = count + 1

    self.QuickStopSensor()
            
    Header_tmp_per_capture_size = 128

    for frm in range(nFrames):
        print(&#39;Restructuring frm #:&#39;, frm)
        for i in range(captures):
            Header_tmp_per_capture = Header_tmp[frm][i*Header_tmp_per_capture_size : (i+1)*Header_tmp_per_capture_size]
            subImage = RawImage[frm][i*self.width*self.height: (i+1)*self.width*self.height]
            # convert fractional raw image from camera to 16bit signed image
            image16 =  self.dev.ConvertFloat2LinearVal(subImage)
            image16 = np.resize( image16, (self.height, self.width))
            Img[:,:,i,frm] = image16.copy()
            Header[i][frm] = dict()
            Header[i][frm][&#39;mode&#39;] = Header_tmp_per_capture[48] &amp; 0x7
            Header[i][frm][&#39;Frame_number&#39;] = Header_tmp_per_capture[4]
            Header[i][frm][&#39;height&#39;] = Header_tmp_per_capture[7]
            Header[i][frm][&#39;width&#39;] = Header_tmp_per_capture[6]
            Header[i][frm][&#39;nPhases&#39;] = (Header_tmp_per_capture[50] &amp; 0xF0) &gt;&gt; 4 #self.nPhases
            Header[i][frm][&#39;phaseNo&#39;] = Header_tmp_per_capture[50] &amp; 0xF
            Header[i][frm][&#39;nCaptures&#39;] = (Header_tmp_per_capture[49] &amp; 0xFC0) &gt;&gt; 6
            Header[i][frm][&#39;captureNo&#39;] = Header_tmp_per_capture[49] &amp; 0x3F
            Header[i][frm][&#39;nFreqs&#39;] = (Header_tmp_per_capture[49] &amp; 0xF000) &gt;&gt; 12
            Header[i][frm][&#39;Temp_sensor_DegC&#39;] = ((Header_tmp_per_capture[28] &amp; 0xFFF) - Temp_sensor_offset) / Temp_sensor_slope
            Header[i][frm][&#39;freqVal&#39;] = Header_tmp_per_capture[53]
            Header[i][frm][&#39;clkgenDenom&#39;] = (Header_tmp_per_capture[52] &amp; 0xFE00) &gt;&gt; 9
            Header[i][frm][&#39;clkgenNumerator&#39;] = Header_tmp_per_capture[52] &amp; 0x1FF
            Header[i][frm][&#39;LSDAC_port&#39;] = Header_tmp_per_capture[57] &gt;&gt; 8
            Header[i][frm][&#39;LSDAC_starboard&#39;] = Header_tmp_per_capture[57] &amp; 0x00FF

    if outputFormat == &#39;pkl&#39;:
        output = dict()
        output[&#39;Image&#39;] = Img
        output[&#39;Header&#39;] = Header
        f = open(filename, &#39;wb&#39;)
        pickle.dump(output, f)
        f.close()
    elif outputFormat == &#39;bin&#39;:
        for frm in range(nFrames):
            write_file = open(filename[:-4] + str(frm) + &#39;.bin&#39;, &#34;wb&#34;)
            tmp = np.array(Img[:,:,:,frm],dtype=np.int16)
            # tmp_flattened = np.zeros([],dtype=np.int16)
            for i in range(captures):
                if i == 0:
                    tmp_flattened = tmp[:,:,i].flatten()
                if i &gt; 0 :
                    tmp_flattened = np.append(tmp_flattened, tmp[:,:,i].flatten())
            tmp_flattened.tofile(write_file, format=&#39;%d&#39;)
    else:
        raise Exception(&#39;Invalid output format for storing frames.&#39;)

    frames_dict = dict()
    frames_dict[&#39;Image&#39;] = Img
    frames_dict[&#39;Header&#39;] = Header

    return True, frames_dict</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.UpdateUseCaseFrameSetting"><code class="name flex">
<span>def <span class="ident">UpdateUseCaseFrameSetting</span></span>(<span>self, usecaseId, fieldname, fieldVal)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates use case frame setting</p>
<h2 id="inputs">Inputs</h2>
<p>usecaseId
fieldname
fieldVal </p>
<h2 id="outputs">Outputs</h2>
<p>success: status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateUseCaseFrameSetting(self, usecaseId, fieldname, fieldVal):
    &#34;&#34;&#34;
    Updates use case frame setting
    Inputs:
        usecaseId 
        fieldname 
        fieldVal 

    Outputs:
        success: status 
    &#34;&#34;&#34; 

    status = 0
    prevVal = 0

    if (usecaseId &lt; 0 or usecaseId &gt; 15):
        return False, False

    if fieldname == &#39;DRAINSTYLE&#39;:
        fieldIndex = 7
    else:
        return False, False

    # Offset 7 is where the use case entries start in
    # DMEM1, there are Frame Details and 3 ROIs per use case (4)
    ADDR = 7 + usecaseId * 4

    # Using Bank Addressing Scheme instead of auto bank addressing using LSBs
    # of the address due to bug in addressing the entire address space
    #
    # Separate out Bank ID and Bank Address
    # (2 LSBs indicate Bank ID)

    BANK_ID = int(ADDR) &amp; 3
    BANK_ADDR = ADDR &gt;&gt; 2
    IA_SELECT_VAL = (BANK_ID &lt;&lt; 8) + 2

    status = self.regwrite(0x0500, IA_SELECT_VAL)
    status = status and (self.regwrite(0x0502, BANK_ADDR))

    if status:
        status, usecaseVals = self.regreadburst(0x0506, 32)
        if status:
            usecaseVals = np.squeeze(usecaseVals)
            prevVal = usecaseVals[fieldIndex - 1]

            usecaseVals[fieldIndex - 1] = fieldVal

            status = self.regwrite(0x502, BANK_ADDR)
            status = status and self.regwriteburst(0x0504, usecaseVals)

    return status, prevVal</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.WriteOrigSettings"><code class="name flex">
<span>def <span class="ident">WriteOrigSettings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes back original settings to the registers based on tregwrite</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteOrigSettings(self):
    &#34;&#34;&#34;
    Writes back original settings to the registers based on tregwrite
    Inputs:
        none 

    Outputs:
        none 
    &#34;&#34;&#34; 
    rs = True
    for ns in range(len(self.origSetting[&#39;reg&#39;][&#39;addr&#39;])-1,-1,-1):
        # if len(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]) &gt; 1:
        #   rs = rs and self.regwriteburst(1, 
        #                                       str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]),
        #                                       self.convert2matlabArray(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns]),
        #                                       &#39;increment&#39;)
        # else:
        # rs = rs and self.regwrite(1, str(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns]), int(float(self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])))
        rs = rs and self.regwrite(self.origSetting[&#39;reg&#39;][&#39;addr&#39;][ns], self.origSetting[&#39;reg&#39;][&#39;val&#39;][ns])</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.bitget"><code class="name flex">
<span>def <span class="ident">bitget</span></span>(<span>self, var, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns bit in a position</p>
<h2 id="inputs">Inputs</h2>
<p>var: hex or decimal
pos: position </p>
<h2 id="outputs">Outputs</h2>
<p>bit in the position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitget(self, var, pos): # !Python indexing!
    &#34;&#34;&#34;
    Returns bit in a position
    Inputs:
        var: hex or decimal 
        pos: position 

    Outputs:
        bit in the position 
    &#34;&#34;&#34; 
    return(var &gt;&gt; pos) &amp; 1</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.block_max"><code class="name flex">
<span>def <span class="ident">block_max</span></span>(<span>self, img)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes x and y coordinates of the brightest spot
in the image</p>
<h2 id="inputs">Inputs</h2>
<p>img: image array </p>
<h2 id="outputs">Outputs</h2>
<p>max_x: x coordinate of maximum brightness
max_y: y coordinate of maximum brightness</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_max(self, img):
    &#34;&#34;&#34;
    Computes x and y coordinates of the brightest spot
    in the image
    Inputs:
        img: image array 

    Outputs:
        max_x: x coordinate of maximum brightness 
        max_y: y coordinate of maximum brightness 
    &#34;&#34;&#34;
    res = ndimage.interpolation.zoom(img,0.125)
    max_blk = np.where(res == np.amax(res))
    max_x = np.clip(max_blk[1][0] * 8 + 4, 16, 1007)
    max_y = np.clip(max_blk[0][0] * 8 + 4, 16, 1007)
    return max_x, max_y</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.changeMode"><code class="name flex">
<span>def <span class="ident">changeMode</span></span>(<span>self, Mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes image sensor mode. This function will not change the camera resolution.</p>
<p>:param Mode: image sensor mode.
:type Mode: int
:returns: None
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeMode( self, Mode):
    &#34;&#34;&#34;Changes image sensor mode. This function will not change the camera resolution.
    
    :param Mode: image sensor mode. 
    :type Mode: int 
    :returns: None 
    :rtype: None 
    &#34;&#34;&#34;
    self.Mode = Mode
    self._setInternalClassMode()

    self.dev.writeSPISingle( 0x000C, 0x0002)
    regData = self.dev.readSPISingle( 0x000C, 1)
    while( regData[0] != 0x0):
        time.sleep(0.1)
        regData = self.dev.readSPISingle( 0x000C, 1)
    self.dev.writeSPISingle( 0x0200, self.Mode)
    self.dev.writeSPISingle( 0x000C, 0x0001)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_amptest0_get"><code class="name flex">
<span>def <span class="ident">dac_amptest0_get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get amptest0 value </p>
<h2 id="inputs">Inputs</h2>
<p>none</p>
<h2 id="outputs">Outputs</h2>
<p>value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_amptest0_get(self):
    &#34;&#34;&#34;
    Get amptest0 value 
    Inputs:
        none

    Outputs:
        value

    &#34;&#34;&#34;
    return self.dac_amptest0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_amptest0_set"><code class="name flex">
<span>def <span class="ident">dac_amptest0_set</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set amptest0 value </p>
<h2 id="inputs">Inputs</h2>
<p>val: amptest0 value </p>
<h2 id="outputs">Outputs</h2>
<p>s: status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_amptest0_set(self, val):
    &#34;&#34;&#34;
    Set amptest0 value 
    Inputs:
        val: amptest0 value 

    Outputs:
        s: status

    &#34;&#34;&#34;
    s = self.regwrite(0x0132, np.uint16(val))
    s_ = self.regwrite(0x0126, 0x0080) # Latch DAC_AMPTEST0
    # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
    # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
    if s:
        self.dac_amptest0 = val
    return s</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_amptest1_get"><code class="name flex">
<span>def <span class="ident">dac_amptest1_get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get amptest1 value</p>
<h2 id="inputs">Inputs</h2>
<p>none</p>
<h2 id="outputs">Outputs</h2>
<p>value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_amptest1_get(self):
    &#34;&#34;&#34;
    Get amptest1 value
    Inputs:
        none

    Outputs:
        value

    &#34;&#34;&#34;
    return self.dac_amptest1</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_amptest1_set"><code class="name flex">
<span>def <span class="ident">dac_amptest1_set</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set amptest1 value</p>
<h2 id="inputs">Inputs</h2>
<p>val: amptest1 value</p>
<h2 id="outputs">Outputs</h2>
<p>s: status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_amptest1_set(self, val):
    &#34;&#34;&#34;
    Set amptest1 value
    Inputs:
        val: amptest1 value

    Outputs:
        s: status

    &#34;&#34;&#34;
    s = self.regwrite(0x0132, np.uint16(val))
    s_ = self.regwrite(0x0126, 0x0004) # Latch DAC_AMPTEST0
    # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
    # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
    if s:
        self.dac_amptest1 = val
    return s</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_cmref_get"><code class="name flex">
<span>def <span class="ident">dac_cmref_get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cmref value</p>
<h2 id="inputs">Inputs</h2>
<p>none</p>
<h2 id="outputs">Outputs</h2>
<p>value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_cmref_get(self):
    &#34;&#34;&#34;
    Get cmref value
    Inputs:
        none

    Outputs:
        value

    &#34;&#34;&#34;
    return self.dac_cmref</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.dac_cmref_set"><code class="name flex">
<span>def <span class="ident">dac_cmref_set</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set cmref value</p>
<h2 id="inputs">Inputs</h2>
<p>val: cmref value </p>
<h2 id="outputs">Outputs</h2>
<p>s: status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dac_cmref_set(self, val):
    &#34;&#34;&#34;
    Set cmref value
    Inputs:
        val: cmref value 

    Outputs:
        s: status

    &#34;&#34;&#34;
    s = self.regwrite(0x0132, np.uint16(val))
    s_ = self.regwrite(0x0126, 0x0100) # Latch DAC_AMPTEST0
    # s = s and self.regrmw(0x0146, 0x0000, 0x0080) # Power up analog bandgap reference
    # s = s and self.regrmw(0x0128, 0x0000, 0x8184) # Power up DAC_AMPTEST0, DAC_AMPTEST1 and DAC_CMREF
    if s:
        self.dac_cmref = val
    return s</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.error_assert"><code class="name flex">
<span>def <span class="ident">error_assert</span></span>(<span>self, var, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises error if the test has failed with a message</p>
<h2 id="inputs">Inputs</h2>
<p>var: status of test<br>
message: error message to display
</p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_assert(self, var, message):
    &#34;&#34;&#34;
    Raises error if the test has failed with a message
    Inputs:
        var: status of test  
        message: error message to display  
    Outputs:
        none  

    &#34;&#34;&#34;
    if var == False:
        raise Exception(message)
        try:
            logging.error(message)
        except:
            pass</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.generate_truthtable"><code class="name flex">
<span>def <span class="ident">generate_truthtable</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a 'truth table' of n variables</p>
<h2 id="inputs">Inputs</h2>
<p>n: variable length </p>
<h2 id="outputs">Outputs</h2>
<p>truth table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_truthtable(self, n):
    &#34;&#34;&#34;
    Generates a &#39;truth table&#39; of n variables
    Inputs:
        n: variable length 

    Outputs:
        truth table 
    &#34;&#34;&#34;
    if n &lt; 1:
        return [[]]
    subtable = self.generate_truthtable(n - 1)
    return [ row + [v] for row in subtable for v in [0,1] ]</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.get_addr_hex2dec"><code class="name flex">
<span>def <span class="ident">get_addr_hex2dec</span></span>(<span>self, addr, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeats decimal as a hex with padding</p>
<h2 id="inputs">Inputs</h2>
<p>addr: address
k: repeat count </p>
<h2 id="outputs">Outputs</h2>
<p>hex output with padding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_addr_hex2dec(self, addr, k):
    &#34;&#34;&#34;
    Repeats decimal as a hex with padding
    Inputs:
        addr: address 
        k: repeat count 

    Outputs:
        hex output with padding 
    &#34;&#34;&#34; 
    dec = int(addr,0) + k*2
    hex_raw = hex(dec).split(&#39;x&#39;)[-1]
    pad_zero = 4 - len(hex_raw)
    return (&#39;0x&#39; + &#39;0&#39;*pad_zero + hex_raw)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.print_regreadburst"><code class="name flex">
<span>def <span class="ident">print_regreadburst</span></span>(<span>self, addr, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Print register read burst
Inputs:
addr: Address
length: length to read </p>
<h2 id="outputs">Outputs</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_regreadburst(self, addr, length):
    &#34;&#34;&#34;
    Print register read burst 
    Inputs: 
        addr: Address 
        length: length to read 

    Outputs:
        None 

    &#34;&#34;&#34;
    for i in range(length):
        val = self.regread(addr + 2*i)
        print(hex(addr + 2*i),&#39;--&gt;&#39;,hex(val))</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.procFrame"><code class="name flex">
<span>def <span class="ident">procFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a frame from the camera and process the frame data filling the internal buffers and processing the
raw data from the camera.</p>
<p>:returns: None
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def procFrame( self):
    &#34;&#34;&#34;Retrieves a frame from the camera and process the frame data filling the internal buffers and processing the
    raw data from the camera.
    
    :returns: None 
    :rtype: None 
    &#34;&#34;&#34;

    RawImage = self.dev.getFloatImage()
    time.sleep(debug_delay)
    #RawImage = self.dev.getImage8U()
    if( self.dev.validFrame != 1):
    #if( self.dev.IO.validFrame != 1):
        return -1
    else:
        RawImage = RawImage[0]
        #RAW = self.dev.ConvertFloat2LinearVal( RawImage)
        RAW = RawImage
        RAW = np.resize( RAW, (self.height  * self.subFrames, self.width))
        self.pRAW = RAW.copy()

        for i in range( self.subFrames):
            subImage = RawImage[ i*self.width*self.height: (i+1)*self.width*self.height]
            # convert fractional raw image from camera to 16bit signed image
            image16 =  self.dev.ConvertFloat2LinearVal( subImage)
            image16 = np.resize( image16, (self.height, self.width))
            
            self.rawImage[:,:,i] = image16.copy()

        for i in range( len(self.freqs)):                
            f = self.freqs[i]
            depth = self.visualize_map( self.rawImage[:,:,i*self.nPhases:(i+1)*self.nPhases], f)[0]

            self.unwrappedDepth[:,:,i] = depth.copy()

    return 0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.programCSV"><code class="name flex">
<span>def <span class="ident">programCSV</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Programs the sensor with csv</p>
<h2 id="inputs">Inputs</h2>
<p>filename: csv filename </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def programCSV( self, filename):
    &#34;&#34;&#34;
    Programs the sensor with csv
    Inputs:
        filename: csv filename 

    Outputs:
        none 
    &#34;&#34;&#34; 
    fin = open(filename)
    csv_reader = csv.reader( fin, delimiter=&#34;,&#34;)

    if( self._debug):
        fname = &#34;firmware0.bin&#34;
        fwrite = open( fname, &#34;w+b&#34;)
        fdebug = open( &#34;debug.txt&#34;, &#34;w&#34;)

    regAddr = 0x0000
    regData = 0x0000
    RAMAddr = 0x0000
    Data = []
    rData = []
    rAddr = []
    i = 0
    j = 0
    k = 0
    z = 0
    TxLen = 0
    prevTxLen = 0
    bProgram = 0
    bProgramRAM = 0

    for row in csv_reader:
        bProgram = 0
        bProgramRAM = 0

        try:
            TxLen = int( row[4])
        except:
            print( &#34;error parsing len&#34; + str(row))
            sys.exit()
        try:
            regAddr = int( row[0], 16)
        except:
            #print( &#34;error parsing reg addr&#34; + str(row))
            regAddr = -1

        try:
            regData = int( row[1], 16)
        except:
            print( &#34;error parsing reg data&#34; + str(row))
            regData = -1

        if( TxLen &gt; 2):
            if( regAddr != -1):
                Data.append( regAddr)                    
            if( regData != -1):
                Data.append( regData)  
            if( len(rAddr) &gt; 0):
                bProgram = 1
        else:
            if( self._debug):
                fwrite.write( regAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                fwrite.write( regData.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
            
            i = i + 1
            rAddr.append( regAddr)
            rData.append( regData)

            if( len( Data) &gt; 0):
                bProgramRAM = 1

        if( bProgram):
            print( &#34;programming &#34; + str( len(rAddr)) + &#34; single registers&#34;)
            i = 0            
            j = j + 1
            
            if( self.dev != None):
                self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
                #time.sleep(2)
                pass

            if( self._debug):
                fwrite.close()
                fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                fwrite = open( fname, &#34;w+b&#34;)
                for i in range( len( rAddr)):
                    fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)

            rData = []
            rAddr = []

        if( bProgramRAM):
            print( &#34;programming RAM &#34; + str( len(Data)*2-2) + &#34; registers&#34;)
            i = 0
            RAMAddr = []
            RAMAddr = int(Data[0])
            #Data.remove(0)
            #Data = Data[1:-1]
            del Data[0]
            if( self._debug):                
                fwrite.write( RAMAddr.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                for dat in Data:
                    fwrite.write( dat.to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

                fwrite.close()
                j = j + 1
                fname = &#34;firmware&#34;+str(j)+&#34;.bin&#34;
                fwrite = open( fname, &#34;w+b&#34;)

            if( self.dev != None):
                RAMData = np.zeros( (len( Data)*2), dtype = np.uint8)                
                for i in range( len(Data)):
                    RAMData[2*i] = Data[i] &gt;&gt; 8
                    RAMData[2*i+1] = Data[i] &amp; 0xFF
                self.dev.writeSPIBurst( RAMAddr, RAMData)

            if( self._debug):
                k = 0
                for dat in Data:
                    if k == 0:
                        fdebug.write( hex(RAMAddr) + &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                    else:
                        if( k%2 == 0):
                            fdebug.write( &#34;, &#34; + hex(dat) + &#34;\n&#34;)
                        else:
                            fdebug.write( hex(dat))
                    k = k + 1

                if( k%2 ==0):
                    fdebug.write(&#34;\n&#34;)
            Data = []
        k = k + 1

    if( len( rAddr) &gt; 0):
        print( &#34;programming &#34; + str( len( rAddr)) + &#34; final registers&#34;)
        i = 0
        j = j + 1

        if( self._debug):
            fwrite.close()
            fname = &#34;firmware_final.bin&#34;
            fwrite = open( fname, &#34;w+b&#34;)
            for i in range( len( rAddr)):
                fwrite.write( rAddr[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))
                fwrite.write( rData[i].to_bytes( 2, byteorder=&#34;big&#34;, signed=False))

        if( self.dev != None):
            self.dev.writeSPISingle( np.asarray( rAddr, dtype=np.uint16), np.asarray( rData, dtype=np.uint16))
            pass

        if( self._debug):
            for i in range( len( rAddr)):
                fdebug.write( hex(rAddr[i]) + &#34;, &#34; + hex( rData[i]) + &#34;\n&#34;)
    if( self._debug):
        fdebug.close()</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regread"><code class="name flex">
<span>def <span class="ident">regread</span></span>(<span>self, addr, length=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a register. If address lies between 0x0E00 and 0x0EFE,
writes 0x0000 to 0x0014 beforehand.</p>
<h2 id="inputs">Inputs</h2>
<p>addr: register address in hex or decimal
length: number of registers to read </p>
<h2 id="outputs">Outputs</h2>
<p>register value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regread(self, addr, length=1):
    &#34;&#34;&#34;
    Read a register. If address lies between 0x0E00 and 0x0EFE,
    writes 0x0000 to 0x0014 beforehand.
    Inputs:
        addr: register address in hex or decimal 
        length: number of registers to read 

    Outputs:
        register value 

    &#34;&#34;&#34;
    if addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
        self.dev.writeSPISingle(0x0014, 0x0000)
        # print(&#39;did 0014&lt;-0000&#39;)

    if length == 1 or length == &#39;&#39;:
        return self.dev.readSPISingle(addr, 1)[0]
    else:
        return self.dev.readSPISingle(addr, length)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regreadburst"><code class="name flex">
<span>def <span class="ident">regreadburst</span></span>(<span>self, addr, length, mode='')</span>
</code></dt>
<dd>
<div class="desc"><p>Register read burst (from RAM or multiple registers)</p>
<h2 id="inputs">Inputs</h2>
<p>addr: Address
length: length to read
mode: RAM read or 'increament' to read multiple registers </p>
<h2 id="outputs">Outputs</h2>
<p>True
val: read value in array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regreadburst(self, addr, length, mode = &#39;&#39;):
    &#34;&#34;&#34;
    Register read burst (from RAM or multiple registers)
    Inputs:
        addr: Address 
        length: length to read 
        mode: RAM read or &#39;increament&#39; to read multiple registers 

    Outputs:
        True 
        val: read value in array 

    &#34;&#34;&#34;
    if mode == &#39;&#39;:
        s, tmp =  self.dev.readSPIBurst(addr, length*2+4) # Temporory workaround
        val = np.zeros(length)
        val = 256*tmp[::2] + tmp[1::2]
        return np.all(s), val[0:-2]
    elif mode == &#39;increment&#39;:
        val = np.zeros(length,dtype=np.uint16)
        for i in range(length):
            val[i] = self.regread(addr + 2*i)
        return True, val</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regrmw"><code class="name flex">
<span>def <span class="ident">regrmw</span></span>(<span>self, addr, val, mask=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Register read-modify-write </p>
<h2 id="inputs">Inputs</h2>
<p>addr: address in hex or decimal
val: value in hex or decimal
mask: mask in hex or decimal </p>
<h2 id="outputs">Outputs</h2>
<p>success: status of rmw</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regrmw(self, addr, val, mask=np.uint16(0x0000)):
    &#34;&#34;&#34;
    Register read-modify-write 
    Inputs:
        addr: address in hex or decimal 
        val: value in hex or decimal 
        mask: mask in hex or decimal 

    Outputs:
        success: status of rmw 

    &#34;&#34;&#34;
    addr = np.uint16(addr)
    val = np.uint16(val)
    mask = np.uint16(mask)
    prevVal = np.uint16(self.regread(addr))
    newVal = (prevVal &amp; ~mask) | (val &amp; mask)
    success = self.regwrite(addr, newVal)
    return success</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regwrite"><code class="name flex">
<span>def <span class="ident">regwrite</span></span>(<span>self, addr, val, mode='')</span>
</code></dt>
<dd>
<div class="desc"><p>Write to a register. If address lies between 0x0E00 and 0x0EFE,
writes 0x0000 to 0x0014 beforehand.</p>
<h2 id="inputs">Inputs</h2>
<p>addr: register address in hex or decimal
val: register value in hex or decimal </p>
<h2 id="outputs">Outputs</h2>
<p>status of write</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regwrite(self, addr, val, mode = &#39;&#39;):
    &#34;&#34;&#34;
    Write to a register. If address lies between 0x0E00 and 0x0EFE,
    writes 0x0000 to 0x0014 beforehand.
    Inputs:
        addr: register address in hex or decimal 
        val: register value in hex or decimal 

    Outputs:
        status of write 

    &#34;&#34;&#34;
    #print(val , &#39;writing to&#39;, addr)
    if mode == &#39;&#39;:
        if isinstance(val, np.uint16) or isinstance(val, int):
            #print(&#39;stage1&#39;)
            if (addr in s1) or (addr in s2): # Analog registers
                status = 0xFFFF
                i = 10
                while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                    status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                    #print(&#39;status1--&gt;&#39;,status)
                    i = i - 1
                self.dev.writeSPISingle(addr, val)
                if addr in s1:
                    self.dev.writeSPISingle(0x0150, 0x0105)
                    #print(&#39;sdsdsdf&#39;)
                else:
                    self.dev.writeSPISingle(0x0150, 0x0501)
                status = 0xFFFF
                i = 10
                while (((status &gt;&gt; 3) &amp; 1 == 1) or ((status &gt;&gt; 11) &amp; 1 == 1))and i &gt; 0:
                    status = self.dev.readSPISingle(0x0150, 1) # Check if regif is busy
                    #print(&#39;status2--&gt;&#39;,status)
                    i = i - 1
            
            elif addr &gt;= 0x0E00 and addr &lt;= 0x0EFE:
                self.dev.writeSPISingle(0x0014, 0x0000)
                #print(&#39;did 0014&lt;-0000&#39;)
                self.dev.writeSPISingle(addr, val)

            else:
                self.dev.writeSPISingle(addr, val)
            # ret_val = self.dev.readSPISingle(addr, 1)[0]
            return True
        else:
            self.dev.writeSPISingle(addr, val)
            return True

    elif mode == &#39;ignore&#39;:
        self.dev.writeSPISingle(addr, val)
        return True

    else:
        return False</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regwriteburst"><code class="name flex">
<span>def <span class="ident">regwriteburst</span></span>(<span>self, addr, data, mode='')</span>
</code></dt>
<dd>
<div class="desc"><p>Register write burst (to RAM or multiple registers)</p>
<h2 id="inputs">Inputs</h2>
<p>addr: Address array
data: Data array
mode: RAM read or 'increament' to read multiple registers </p>
<h2 id="outputs">Outputs</h2>
<p>status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regwriteburst(self, addr, data, mode = &#39;&#39;):
    &#34;&#34;&#34;
    Register write burst (to RAM or multiple registers)
    Inputs:
        addr: Address array 
        data: Data array 
        mode: RAM read or &#39;increament&#39; to read multiple registers 

    Outputs:
        status 

    &#34;&#34;&#34;
    addr = np.uint16(addr)
    data = np.uint16(data)
    if mode == &#39;&#39;:
        RAMData = np.zeros( (len(data)*2), dtype = np.uint8)
        for i in range( len(data)):
            RAMData[2*i] = data[i] &gt;&gt; 8
            RAMData[2*i+1] = data[i] &amp; 0xFF
        return self.dev.writeSPIBurst(addr, RAMData)

    elif mode == &#39;increment&#39;:
        if isinstance(addr, np.uint16):
            for i in range(len(data)):
                success = self.regwrite(addr + i*2, data[i])
        else:
            for i in range(len(data)):
                success = self.regwrite(addr[i], data[i])

    return success</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.regwritemultiple"><code class="name flex">
<span>def <span class="ident">regwritemultiple</span></span>(<span>self, addr, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Write multiple registers </p>
<h2 id="inputs">Inputs</h2>
<p>addr: address array
val: value array </p>
<h2 id="outputs">Outputs</h2>
<p>status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regwritemultiple(self, addr, val):
    &#34;&#34;&#34;
    Write multiple registers 
    Inputs:
        addr: address array 
        val: value array 

    Outputs:
        status 

    &#34;&#34;&#34;
    self.dev.writeSPISingle(addr, val)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.repmatdec2Hex"><code class="name flex">
<span>def <span class="ident">repmatdec2Hex</span></span>(<span>self, dec, rep)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeats decimal as a hex</p>
<h2 id="inputs">Inputs</h2>
<p>dec: decimal input
rep: repeat count </p>
<h2 id="outputs">Outputs</h2>
<p>hex output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repmatdec2Hex(self, dec, rep):
    &#34;&#34;&#34;
    Repeats decimal as a hex
    Inputs:
        dec: decimal input 
        rep: repeat count 

    Outputs:
        hex output 
    &#34;&#34;&#34; 
    hexval = hex(dec).split(&#39;x&#39;)[-1]
    out = &#39;&#39;
    for _ in range(rep):
        out = out + hexval
    return int(&#39;0x&#39; + out.upper(),0)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.sensorPowerDown"><code class="name flex">
<span>def <span class="ident">sensorPowerDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>De-initialize camera</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensorPowerDown( self):
    &#34;&#34;&#34;
    De-initialize camera
    Inputs:
        none 

    Outputs:
        0
    &#34;&#34;&#34; 
    # De-Initialize the camera
    self.dev.setGpio( CAM_RESET_N, 0)
    self.dev.setGpio( DEPTH_VAUX_RUN, 0)
    self.dev.setGpio( PS_VAUXVPS1, 0)
    self.dev.setGpio( PS_VAUXVPS2, 0)
    self.dev.setGpio( PS_V5VVPS3, 0)
    self.dev.setGpio( LMZ_EN, 0)
    self.dev.setGpio( CAM_RESET_N, 0)

    # Wait for CAM_SHUTDOWN_N to go low indicating that everything is ok
    retries = 10
    while( retries &gt; 0):
        if (self.module_class == &#39;Walden_R1&#39;):
            cam_shutdown = 0    # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
        else:
            cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
        time.sleep(0.1)
        if( cam_shutdown == 0):
            break
        else:
            retries = retries - 1

    if( retries == 0):
        print( &#34;Error during camera de-initialization&#34;)
        self.dev.setGpio( DEPTH_VAUX_RUN, 0)
        self.dev.setGpio( PS_VAUXVPS2, 0)
        self.dev.setGpio( PS_VAUXVPS1, 0)
        self.dev.setGpio( PS_V5VVPS3, 0)
        self.dev.setGpio( LMZ_EN, 0)
        return -1

    return 0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.sensorPowerUp"><code class="name flex">
<span>def <span class="ident">sensorPowerUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements sensor initialization sequence enabling the power regulators and making functional checks.</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensorPowerUp( self):
    &#34;&#34;&#34;
    Implements sensor initialization sequence enabling the power regulators and making functional checks.
    Inputs:
        none 

    Outputs:
        0 
    &#34;&#34;&#34; 
    #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9E, 0xF8]) # MZ1: Added VAUX DAC set for 12V 
    self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9C, 0x17]) # MZ1: Added VAUX DAC set for 18V  
    #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x9A, 0x2C]) # MZ1: Added VAUX DAC set for 22V       
    #self.dev.writeI2C(I2C_MALKA, AD5593R_ID,[AD5593R_DAC_SET|VAUX_ADJ,0x97, 0xDE]) # MZ1: Added VAUX DAC set for 27V 

    self.dev.setGpio( CAM_RESET_N, 0) # reset camera
    self.dev.setGpio( LMZ_EN, 1) # enable Vmain
    [ Vmain, Imain, Pmain] = self.PowerMonitor( VMAIN_DEV_ID) # Check Vmain
    # MZ: Added current and voltage measurements
    print(&#39;Vmain: &#39; + str(Vmain) + &#39;, Imain: &#39; + str(Imain) + &#39;, Pmain: &#39; + str(Pmain))

    self.dev.setGpio( PS_V5VVPS3, 1) # enable TPS61230A producint 5V2 to drive Vdepth
    [ Vdepth, Idepth, Pdepth] = self.PowerMonitor( VDEPTH_DEV_ID) # Check Vmain
    # MZ: Added current and voltage measurements
    print(&#39;Vdepth: &#39; + str(Vdepth) + &#39;, Idepth: &#39; + str(Idepth) + &#39;, Pdepth: &#39; + str(Pdepth))
    
    self.dev.setGpio( PP_DEPTH, 1) # enable XC6222 and Vdepth
    time.sleep( 0.004) # wait 4 ms

    self.dev.setGpio( PS_VAUXVPS1, 1) # enable ADP196
    self.dev.setGpio( PS_VAUXVPS2, 1) # enable Vsys
    [ Vsys, Isys, Psys] = self.PowerMonitor( VSYS_DEV_ID)
    # MZ: Added current and voltage measurements
    print(&#34;Vsys: &#34; + str(Vsys) + &#34;, Isys: &#34; + str(Isys)+&#34;, Psys: &#34; + str(Psys))
    
    time.sleep( 0.004) # wait 4 ms

    self.dev.setGpio( DEPTH_VAUX_RUN, 1)
    time.sleep(0.0001) # wait 100 us
    [ Vaux, Iaux, Paux] = self.PowerMonitor( VAUX_DEV_ID)
    # MZ: Added current and voltage measurements
    print(&#39;Vaux: &#39; + str(Vaux) +&#39;, Iaux: &#39; + str(Iaux) +&#39;, Paux: &#39; + str(Paux))

    # Wait for CAM_SHUTDOWN_N to go high indicating that everything is ok
    retries = 10
    while( retries &gt; 0):
        if (self.module_class == &#39;Walden_R1&#39;):
            cam_shutdown = 1 # MZ: Walden does not have shutdown output to controller (connector pin left floating in rev.1)
        else:
            cam_shutdown = self.dev.getGpio( CAM_SHUTDOWN_N)
        if( cam_shutdown == 1):
            break
        else:
            retries = retries - 1


    # wait 2 ms
    time.sleep( 0.002)
    self.dev.setGpio( CAM_RESET_N, 1)        

    return 0</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.setFPS"><code class="name flex">
<span>def <span class="ident">setFPS</span></span>(<span>self, fps)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes camera framerate</p>
<p>:param fps: Camera framerate
:type fps: int
:returns: None<br>
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setFPS( self, fps):
    &#34;&#34;&#34;Changes camera framerate
    
    :param fps: Camera framerate 
    :type fps: int 
    :returns: None  
    :rtype: None 
    &#34;&#34;&#34;
    self.dev.setCAMFps(fps)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.testBoardADC"><code class="name flex">
<span>def <span class="ident">testBoardADC</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check if the onboard ADC is functioning correctly</p>
<h2 id="inputs">Inputs</h2>
<p>none </p>
<h2 id="outputs">Outputs</h2>
<p>status: staus of the test</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testBoardADC(self):
    &#34;&#34;&#34;
    Function to check if the onboard ADC is functioning correctly
    Inputs:
        none 

    Outputs:
        status: staus of the test 

    &#34;&#34;&#34;
    print(&#39;Testing Board ADC...&#39;)
    try:
        logging.info(&#39;Testing Board ADC...&#39;)
    except:
        pass

    success = self.dac_amptest0_set(158)
    self.error_assert(success, &#34;Cannot set dac_amptest0&#34;)
    success = self.dac_amptest1_set(205)
    self.error_assert(success, &#34;Cannot set dac_amptest1&#34;)
    success = self.dac_cmref_set(255)
    self.error_assert(success, &#34;Cannot set dac_cmref&#34;)
    loop = 1
    status = False
    while(not(status) and loop &lt;= 10):
        b1 = self.CamMeasureAnaTestVoltage(&#39;DACwithSF_AMPTEST1-AMPTEST0&#39;)
        print(&#34;Attempt&#34;, loop)
        print(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
        try:
            logging.info(&#34;Attempt &#34; + str(loop))
            logginh.info(&#34;Set voltage: 0.48V. Measured voltage:&#34;, str(np.round(b1,4)) + &#39;V&#39;)
        except:
            pass

        if b1 &gt; 0.35 and b1 &lt; 0.6:
            status = True
        loop = loop + 1

    if status:
        print(&#39;Board ADC working correctly&#39;)
        try:
            logging.info(&#39;Board ADC working correctly&#39;)
        except:
            pass

    if status == False:
        raise Exception(&#34;ERROR: Either DACwithSF_AMPTEST1-AMPTEST0 or onboard ADC is incorrect&#34;)

    return status</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.testtestwrite"><code class="name flex">
<span>def <span class="ident">testtestwrite</span></span>(<span>self, addr, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Test a register write</p>
<h2 id="inputs">Inputs</h2>
<p>addr: address in hex or decimal
val: value in hex or decimal </p>
<h2 id="outputs">Outputs</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testtestwrite(self,addr,val):
    &#34;&#34;&#34;
    Test a register write
    Inputs:
        addr: address in hex or decimal 
        val: value in hex or decimal 

    Outputs:
        none

    &#34;&#34;&#34;
    self.dev.writeSPISingle(addr, val)</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.tregwrite"><code class="name flex">
<span>def <span class="ident">tregwrite</span></span>(<span>self, regaddr, regval, regmask=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write to register while saving original value</p>
<h2 id="inputs">Inputs</h2>
<p>regaddr: register address
regval: register value
regmask: register mask </p>
<h2 id="outputs">Outputs</h2>
<p>success: status of write</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tregwrite(self, regaddr, regval, regmask = 0):
    &#34;&#34;&#34;
    Write to register while saving original value
    Inputs:
        regaddr: register address 
        regval: register value 
        regmask: register mask 

    Outputs:
        success: status of write 
    &#34;&#34;&#34; 
    if regmask == 0:
        origVal = self.regread(regaddr)
        success = self.regwrite(regaddr, regval)
    else:
        # if regmask == &#39;increment&#39;:
        #   origVal, success = self.regreadburst(regaddr, len(regval), &#39;increment&#39;)
        #   success = success and self.regwriteburst(regaddr, regval, &#39;increment&#39;)
        # else:
        origVal = self.regread(regaddr)
        success = self.regrmw(regaddr, regval, regmask)

    if (regaddr in self.origSetting[&#39;reg&#39;][&#39;addr&#39;]) == False:
        self.origSetting[&#39;reg&#39;][&#39;addr&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;addr&#39;], regaddr)
        self.origSetting[&#39;reg&#39;][&#39;val&#39;] = np.append(self.origSetting[&#39;reg&#39;][&#39;val&#39;], origVal)

    return success</code></pre>
</details>
</dd>
<dt id="CalibAPI.CalibAPI.visualize_map"><code class="name flex">
<span>def <span class="ident">visualize_map</span></span>(<span>self, pixout, f_mhz)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualizes map</p>
<h2 id="inputs">Inputs</h2>
<p>pixout: raw pixel values
f_mhz: frequency in mhz </p>
<h2 id="outputs">Outputs</h2>
<p>dist: distance map in meter
ampl: amplitude map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_map(self, pixout, f_mhz):
    &#34;&#34;&#34;
    Visualizes map
    Inputs:
        pixout: raw pixel values 
        f_mhz: frequency in mhz 

    Outputs:
        dist: distance map in meter 
        ampl: amplitude map 
    &#34;&#34;&#34;          
    nPhase = self.nPhases #len(pixout[0,0,:])
    V1_real = np.sum(np.array([np.cos(2*np.pi*n/nPhase)
                    for n in range(0, nPhase)]) * pixout, axis=2)
    V1_imag = np.sum(-1 * np.array([np.sin(2*np.pi*n/nPhase)
                    for n in range(0, nPhase)]) * pixout, axis=2)
    dist = (299792458/(4*np.pi*f_mhz*1000000)*np.arctan2(V1_imag, V1_real))
    dist = dist % (299792458 * (1/f_mhz/1000000) / 2) # Rolling phases
    ampl = np.abs(V1_real, V1_imag)
    
    
    return dist, ampl # in meters</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="CalibAPI.ICQtest" href="#CalibAPI.ICQtest">ICQtest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CalibAPI.CalibAPI" href="#CalibAPI.CalibAPI">CalibAPI</a></code></h4>
<ul class="">
<li><code><a title="CalibAPI.CalibAPI.CamMeasureAnaTestVoltage" href="#CalibAPI.CalibAPI.CamMeasureAnaTestVoltage">CamMeasureAnaTestVoltage</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.CaptureFramesP0" href="#CalibAPI.CalibAPI.CaptureFramesP0">CaptureFramesP0</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ConfigADSD3000" href="#CalibAPI.CalibAPI.ConfigADSD3000">ConfigADSD3000</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ConnectSensor" href="#CalibAPI.CalibAPI.ConnectSensor">ConnectSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ConvertDumpEngineRamFormatToWaves" href="#CalibAPI.CalibAPI.ConvertDumpEngineRamFormatToWaves">ConvertDumpEngineRamFormatToWaves</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ConvertWavesToDumpEngineRamFormat" href="#CalibAPI.CalibAPI.ConvertWavesToDumpEngineRamFormat">ConvertWavesToDumpEngineRamFormat</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.DisconnectSensor" href="#CalibAPI.CalibAPI.DisconnectSensor">DisconnectSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.DumpTimingTool" href="#CalibAPI.CalibAPI.DumpTimingTool">DumpTimingTool</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.DumpTimingTransformation" href="#CalibAPI.CalibAPI.DumpTimingTransformation">DumpTimingTransformation</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GenerateDumpEngineConfig" href="#CalibAPI.CalibAPI.GenerateDumpEngineConfig">GenerateDumpEngineConfig</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetFramesADCCalib" href="#CalibAPI.CalibAPI.GetFramesADCCalib">GetFramesADCCalib</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetFramesCompDACalib" href="#CalibAPI.CalibAPI.GetFramesCompDACalib">GetFramesCompDACalib</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetFramesPCGO" href="#CalibAPI.CalibAPI.GetFramesPCGO">GetFramesPCGO</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetFramesPixVoltage" href="#CalibAPI.CalibAPI.GetFramesPixVoltage">GetFramesPixVoltage</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetIndirectRegister" href="#CalibAPI.CalibAPI.GetIndirectRegister">GetIndirectRegister</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.GetLDTemp" href="#CalibAPI.CalibAPI.GetLDTemp">GetLDTemp</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ICQSensorPowerUp" href="#CalibAPI.CalibAPI.ICQSensorPowerUp">ICQSensorPowerUp</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ICQSensorStart" href="#CalibAPI.CalibAPI.ICQSensorStart">ICQSensorStart</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.Init" href="#CalibAPI.CalibAPI.Init">Init</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.InitDE_Struct" href="#CalibAPI.CalibAPI.InitDE_Struct">InitDE_Struct</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.InitModes" href="#CalibAPI.CalibAPI.InitModes">InitModes</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.InvertLSMOD" href="#CalibAPI.CalibAPI.InvertLSMOD">InvertLSMOD</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.LoadGainOffsetCalib" href="#CalibAPI.CalibAPI.LoadGainOffsetCalib">LoadGainOffsetCalib</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.PowerMonitor" href="#CalibAPI.CalibAPI.PowerMonitor">PowerMonitor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.QuickStartSensor" href="#CalibAPI.CalibAPI.QuickStartSensor">QuickStartSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.QuickStopSensor" href="#CalibAPI.CalibAPI.QuickStopSensor">QuickStopSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ReadAmpGainSetting" href="#CalibAPI.CalibAPI.ReadAmpGainSetting">ReadAmpGainSetting</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ReadBoardADC" href="#CalibAPI.CalibAPI.ReadBoardADC">ReadBoardADC</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ReadConfigFile" href="#CalibAPI.CalibAPI.ReadConfigFile">ReadConfigFile</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.ReadDEclkFreqFromChip" href="#CalibAPI.CalibAPI.ReadDEclkFreqFromChip">ReadDEclkFreqFromChip</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.SetDiffDacSfVoltage" href="#CalibAPI.CalibAPI.SetDiffDacSfVoltage">SetDiffDacSfVoltage</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.SetIndirectRegister" href="#CalibAPI.CalibAPI.SetIndirectRegister">SetIndirectRegister</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.SetLSDACValue" href="#CalibAPI.CalibAPI.SetLSDACValue">SetLSDACValue</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.Start" href="#CalibAPI.CalibAPI.Start">Start</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.StartSensor" href="#CalibAPI.CalibAPI.StartSensor">StartSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.Stop" href="#CalibAPI.CalibAPI.Stop">Stop</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.StopSensor" href="#CalibAPI.CalibAPI.StopSensor">StopSensor</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.StreamAndCapturePCM" href="#CalibAPI.CalibAPI.StreamAndCapturePCM">StreamAndCapturePCM</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.UpdateUseCaseFrameSetting" href="#CalibAPI.CalibAPI.UpdateUseCaseFrameSetting">UpdateUseCaseFrameSetting</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.WriteOrigSettings" href="#CalibAPI.CalibAPI.WriteOrigSettings">WriteOrigSettings</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.bitget" href="#CalibAPI.CalibAPI.bitget">bitget</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.block_max" href="#CalibAPI.CalibAPI.block_max">block_max</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.changeMode" href="#CalibAPI.CalibAPI.changeMode">changeMode</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_amptest0_get" href="#CalibAPI.CalibAPI.dac_amptest0_get">dac_amptest0_get</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_amptest0_set" href="#CalibAPI.CalibAPI.dac_amptest0_set">dac_amptest0_set</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_amptest1_get" href="#CalibAPI.CalibAPI.dac_amptest1_get">dac_amptest1_get</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_amptest1_set" href="#CalibAPI.CalibAPI.dac_amptest1_set">dac_amptest1_set</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_cmref_get" href="#CalibAPI.CalibAPI.dac_cmref_get">dac_cmref_get</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.dac_cmref_set" href="#CalibAPI.CalibAPI.dac_cmref_set">dac_cmref_set</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.error_assert" href="#CalibAPI.CalibAPI.error_assert">error_assert</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.generate_truthtable" href="#CalibAPI.CalibAPI.generate_truthtable">generate_truthtable</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.get_addr_hex2dec" href="#CalibAPI.CalibAPI.get_addr_hex2dec">get_addr_hex2dec</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.print_regreadburst" href="#CalibAPI.CalibAPI.print_regreadburst">print_regreadburst</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.procFrame" href="#CalibAPI.CalibAPI.procFrame">procFrame</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.programCSV" href="#CalibAPI.CalibAPI.programCSV">programCSV</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regread" href="#CalibAPI.CalibAPI.regread">regread</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regreadburst" href="#CalibAPI.CalibAPI.regreadburst">regreadburst</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regrmw" href="#CalibAPI.CalibAPI.regrmw">regrmw</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regwrite" href="#CalibAPI.CalibAPI.regwrite">regwrite</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regwriteburst" href="#CalibAPI.CalibAPI.regwriteburst">regwriteburst</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.regwritemultiple" href="#CalibAPI.CalibAPI.regwritemultiple">regwritemultiple</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.repmatdec2Hex" href="#CalibAPI.CalibAPI.repmatdec2Hex">repmatdec2Hex</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.sensorPowerDown" href="#CalibAPI.CalibAPI.sensorPowerDown">sensorPowerDown</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.sensorPowerUp" href="#CalibAPI.CalibAPI.sensorPowerUp">sensorPowerUp</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.setFPS" href="#CalibAPI.CalibAPI.setFPS">setFPS</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.testBoardADC" href="#CalibAPI.CalibAPI.testBoardADC">testBoardADC</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.testtestwrite" href="#CalibAPI.CalibAPI.testtestwrite">testtestwrite</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.tregwrite" href="#CalibAPI.CalibAPI.tregwrite">tregwrite</a></code></li>
<li><code><a title="CalibAPI.CalibAPI.visualize_map" href="#CalibAPI.CalibAPI.visualize_map">visualize_map</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>